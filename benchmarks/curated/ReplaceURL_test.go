package curated

import (
	"fmt"
	stream "github.com/KromDaniel/regengo/stream"
	"regexp"
	"strings"
	"testing"
)

// Code generated by regengo
// Tests and benchmarks for pattern: (?P<protocol>https?)://(?P<host>[\w\.-]+)(?::(?P<port>\d+))?(?P<path>/[\w\./]*)?

var replaceURLRegexp = regexp.MustCompile("(?P<protocol>https?)://(?P<host>[\\w\\.-]+)(?::(?P<port>\\d+))?(?P<path>/[\\w\\./]*)?")

var replaceURLTestInputs = []string{"Visit https://example.com/page for info", "API at http://localhost:8080/api/v1/users", "URLs: https://a.com https://b.com https://c.com https://d.com https://e.com"}

func TestReplaceURLMatchString(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		expected := replaceURLRegexp.MatchString(input)
		got := ReplaceURL{}.MatchString(input)
		if got != expected {
			t.Errorf("MatchString(%q) = %v, want %v", input, got, expected)
		}
	}
}

func TestReplaceURLMatchBytes(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		inputBytes := []byte(input)
		expected := replaceURLRegexp.Match(inputBytes)
		got := ReplaceURL{}.MatchBytes(inputBytes)
		if got != expected {
			t.Errorf("MatchBytes(%q) = %v, want %v", input, got, expected)
		}
	}
}

func TestReplaceURLFindString(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		expectedMatches := replaceURLRegexp.FindStringSubmatch(input)
		result, ok := ReplaceURL{}.FindString(input)

		if len(expectedMatches) > 0 {
			if !ok {
				t.Errorf("FindString(%q) returned false, expected match", input)
				continue
			}
			if result.Match != expectedMatches[0] {
				t.Errorf("FindString(%q).Match = %q, want %q", input, result.Match, expectedMatches[0])
			}
			{
				if result.Protocol != expectedMatches[1] {
					t.Errorf("FindString(%q).Protocol = %q, want %q", input, result.Protocol, expectedMatches[1])
				}
				if result.Host != expectedMatches[2] {
					t.Errorf("FindString(%q).Host = %q, want %q", input, result.Host, expectedMatches[2])
				}
				if result.Port != expectedMatches[3] {
					t.Errorf("FindString(%q).Port = %q, want %q", input, result.Port, expectedMatches[3])
				}
				if result.Path != expectedMatches[4] {
					t.Errorf("FindString(%q).Path = %q, want %q", input, result.Path, expectedMatches[4])
				}
			}
		} else {
			if ok {
				t.Errorf("FindString(%q) returned true, expected no match", input)
			}
		}
	}
}

func TestReplaceURLFindAllString(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		expectedAll := replaceURLRegexp.FindAllStringSubmatch(input, -1)
		results := ReplaceURL{}.FindAllString(input, -1)

		if len(results) != len(expectedAll) {
			t.Errorf("FindAllString(%q, -1) returned %d results, want %d", input, len(results), len(expectedAll))
			continue
		}
		for i := range results {
			if results[i].Match != expectedAll[i][0] {
				t.Errorf("FindAllString(%q, -1)[%d].Match = %q, want %q", input, i, results[i].Match, expectedAll[i][0])
			}
			{
				if results[i].Protocol != expectedAll[i][1] {
					t.Errorf("FindAllString(%q, -1)[%d].Protocol = %q, want %q", input, i, results[i].Protocol, expectedAll[i][1])
				}
				if results[i].Host != expectedAll[i][2] {
					t.Errorf("FindAllString(%q, -1)[%d].Host = %q, want %q", input, i, results[i].Host, expectedAll[i][2])
				}
				if results[i].Port != expectedAll[i][3] {
					t.Errorf("FindAllString(%q, -1)[%d].Port = %q, want %q", input, i, results[i].Port, expectedAll[i][3])
				}
				if results[i].Path != expectedAll[i][4] {
					t.Errorf("FindAllString(%q, -1)[%d].Path = %q, want %q", input, i, results[i].Path, expectedAll[i][4])
				}
			}
		}
	}
}

func BenchmarkReplaceURL(b *testing.B) {
	inputs := replaceURLTestInputs

	b.Run("Match", func(b *testing.B) {
		for i, input := range inputs {
			input := input
			b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
				b.Run("stdlib", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = replaceURLRegexp.MatchString(input)
					}
				})
				b.Run("regengo", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = ReplaceURL{}.MatchString(input)
					}
				})
			})
		}
	})

	b.Run("FindFirst", func(b *testing.B) {
		for i, input := range inputs {
			input := input
			b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
				b.Run("stdlib", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = replaceURLRegexp.FindStringSubmatch(input)
					}
				})
				b.Run("regengo", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_, _ = ReplaceURL{}.FindString(input)
					}
				})
				b.Run("regengo_reuse", func(b *testing.B) {
					b.ReportAllocs()
					var result *ReplaceURLResult
					for b.Loop() {
						result, _ = ReplaceURL{}.FindStringReuse(input, result)
					}
				})
			})
		}
	})

	b.Run("FindAll", func(b *testing.B) {
		for i, input := range inputs {
			input := input
			b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
				b.Run("stdlib", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = replaceURLRegexp.FindAllStringSubmatch(input, -1)
					}
				})
				b.Run("regengo", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = ReplaceURL{}.FindAllString(input, -1)
					}
				})
				b.Run("regengo_append", func(b *testing.B) {
					b.ReportAllocs()
					results := make([]*ReplaceURLResult, 0, 100)
					for b.Loop() {
						results = ReplaceURL{}.FindAllStringAppend(input, -1, results[:0])
					}
				})
			})
		}
	})

	b.Run("Replace", func(b *testing.B) {
		for j, template := range replaceURLTestReplacers {
			template := template
			stdlibTemplate := convertToStdlibTemplateReplaceURL(template)
			b.Run(fmt.Sprintf("Template[%d]", j), func(b *testing.B) {
				for i, input := range inputs {
					input := input
					inputBytes := []byte(input)
					j := j
					b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
						b.Run("stdlib", func(b *testing.B) {
							b.ReportAllocs()
							for b.Loop() {
								_ = replaceURLRegexp.ReplaceAllString(input, stdlibTemplate)
							}
						})
						b.Run("regengo_runtime", func(b *testing.B) {
							b.ReportAllocs()
							for b.Loop() {
								_ = ReplaceURL{}.ReplaceAllString(input, template)
							}
						})
						b.Run("regengo", func(b *testing.B) {
							b.ReportAllocs()
							for b.Loop() {
								switch j {
								case 0:
									_ = ReplaceURL{}.ReplaceAllString0(input)
								case 1:
									_ = ReplaceURL{}.ReplaceAllString1(input)
								case 2:
									_ = ReplaceURL{}.ReplaceAllString2(input)
								}
							}
						})
						b.Run("regengo_append", func(b *testing.B) {
							b.ReportAllocs()
							buf := make([]byte, 0, 4096)
							for b.Loop() {
								switch j {
								case 0:
									buf = ReplaceURL{}.ReplaceAllBytesAppend0(inputBytes, buf[:0])
								case 1:
									buf = ReplaceURL{}.ReplaceAllBytesAppend1(inputBytes, buf[:0])
								case 2:
									buf = ReplaceURL{}.ReplaceAllBytesAppend2(inputBytes, buf[:0])
								}
							}
						})
					})
				}
			})
		}
	})

}

func TestReplaceURLFindReader(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		// Get expected matches from stdlib
		expectedAll := replaceURLRegexp.FindAllString(input, -1)

		// Get matches from streaming API
		var streamMatches []string
		err := ReplaceURL{}.FindReader(strings.NewReader(input), stream.Config{}, func(m stream.Match[*ReplaceURLBytesResult]) bool {
			streamMatches = append(streamMatches, string(m.Result.Match))
			return true
		})
		if err != nil {
			t.Errorf("FindReader(%q) error: %v", input, err)
			continue
		}

		// Compare results
		if len(streamMatches) != len(expectedAll) {
			t.Errorf("FindReader(%q) got %d matches, want %d", input, len(streamMatches), len(expectedAll))
			continue
		}
		for i := range streamMatches {
			if streamMatches[i] != expectedAll[i] {
				t.Errorf("FindReader(%q)[%d] = %q, want %q", input, i, streamMatches[i], expectedAll[i])
			}
		}
	}
}

func TestReplaceURLFindReaderCount(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		expectedAll := replaceURLRegexp.FindAllString(input, -1)
		expected := int64(len(expectedAll))

		count, err := ReplaceURL{}.FindReaderCount(strings.NewReader(input), stream.Config{})
		if err != nil {
			t.Errorf("FindReaderCount(%q) error: %v", input, err)
			continue
		}
		if count != expected {
			t.Errorf("FindReaderCount(%q) = %d, want %d", input, count, expected)
		}
	}
}

func TestReplaceURLFindReaderFirst(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		expected := replaceURLRegexp.FindString(input)

		result, _, err := ReplaceURL{}.FindReaderFirst(strings.NewReader(input), stream.Config{})
		if err != nil {
			t.Errorf("FindReaderFirst(%q) error: %v", input, err)
			continue
		}

		if expected == "" {
			if result != nil {
				t.Errorf("FindReaderFirst(%q) = %q, want no match", input, string(result.Match))
			}
		} else {
			if result == nil {
				t.Errorf("FindReaderFirst(%q) = nil, want %q", input, expected)
			} else if string(result.Match) != expected {
				t.Errorf("FindReaderFirst(%q) = %q, want %q", input, string(result.Match), expected)
			}
		}
	}
}

func TestReplaceURLMatchLengthInfo(t *testing.T) {
	minLen, maxLen := ReplaceURL{}.MatchLengthInfo()
	// Just verify we get sensible values
	if minLen < 0 {
		t.Errorf("MinMatchLen = %d, expected >= 0", minLen)
	}
	if maxLen != -1 && maxLen < minLen {
		t.Errorf("MaxMatchLen = %d < MinMatchLen = %d", maxLen, minLen)
	}
}

var replaceURLTestReplacers = []string{"$protocol://$host[REDACTED]", "[URL]", "$host"}

// convertToStdlibTemplate converts regengo template syntax to stdlib syntax.
// regengo: $name, $1, $0 -> stdlib: ${name}, ${1}, ${0}
func convertToStdlibTemplateReplaceURL(template string) string {
	var result strings.Builder
	i := 0
	for i < len(template) {
		if template[i] != '$' {
			result.WriteByte(template[i])
			i++
			continue
		}
		// Found $
		if i+1 >= len(template) {
			result.WriteByte('$')
			i++
			continue
		}
		next := template[i+1]
		switch {
		case next == '$':
			// $$ -> $
			result.WriteString("$$")
			i += 2
		case next == '{':
			// ${...} -> ${...} (already in stdlib format)
			closeIdx := strings.Index(template[i:], "}")
			if closeIdx == -1 {
				result.WriteByte('$')
				i++
			} else {
				result.WriteString(template[i : i+closeIdx+1])
				i += closeIdx + 1
			}
		case next >= '0' && next <= '9':
			// $0, $1, etc -> ${0}, ${1}, etc
			j := i + 1
			for j < len(template) && template[j] >= '0' && template[j] <= '9' {
				j++
			}
			result.WriteString("${")
			result.WriteString(template[i+1 : j])
			result.WriteByte('}')
			i = j
		case next == '_' || (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'):
			// $name -> ${name}
			j := i + 1
			for j < len(template) && (template[j] == '_' || (template[j] >= 'a' && template[j] <= 'z') || (template[j] >= 'A' && template[j] <= 'Z') || (template[j] >= '0' && template[j] <= '9')) {
				j++
			}
			result.WriteString("${")
			result.WriteString(template[i+1 : j])
			result.WriteByte('}')
			i = j
		default:
			// Lone $ followed by something else
			result.WriteByte('$')
			i++
		}
	}
	return result.String()
}

func TestReplaceURLReplaceAllString(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		for _, replacer := range replaceURLTestReplacers {
			stdlibTemplate := convertToStdlibTemplateReplaceURL(replacer)
			expected := replaceURLRegexp.ReplaceAllString(input, stdlibTemplate)
			got := ReplaceURL{}.ReplaceAllString(input, replacer)
			if got != expected {
				t.Errorf("ReplaceAllString(%q, %q) = %q, want %q", input, replacer, got, expected)
			}
		}
	}
}

func TestReplaceURLReplaceFirstString(t *testing.T) {
	for _, input := range replaceURLTestInputs {
		for _, replacer := range replaceURLTestReplacers {
			// Simulate ReplaceFirst using ReplaceAllStringFunc with a once flag
			stdlibTemplate := convertToStdlibTemplateReplaceURL(replacer)
			replaced := false
			expected := replaceURLRegexp.ReplaceAllStringFunc(input, func(match string) string {
				if replaced {
					return match
				}
				replaced = true
				// Use Expand to apply template to single match
				submatch := replaceURLRegexp.FindStringSubmatchIndex(match)
				if submatch == nil {
					return match
				}
				var dst []byte
				dst = replaceURLRegexp.ExpandString(dst, stdlibTemplate, match, submatch)
				return string(dst)
			})
			got := ReplaceURL{}.ReplaceFirstString(input, replacer)
			if got != expected {
				t.Errorf("ReplaceFirstString(%q, %q) = %q, want %q", input, replacer, got, expected)
			}
		}
	}
}

func TestReplaceURLReplaceAllString0(t *testing.T) {
	replacer := "$protocol://$host[REDACTED]"
	for _, input := range replaceURLTestInputs {
		runtime := ReplaceURL{}.ReplaceAllString(input, replacer)
		precompiled := ReplaceURL{}.ReplaceAllString0(input)
		if precompiled != runtime {
			t.Errorf("ReplaceAllString0(%q) = %q, want %q (runtime)", input, precompiled, runtime)
		}
	}
}

func TestReplaceURLReplaceAllString1(t *testing.T) {
	replacer := "[URL]"
	for _, input := range replaceURLTestInputs {
		runtime := ReplaceURL{}.ReplaceAllString(input, replacer)
		precompiled := ReplaceURL{}.ReplaceAllString1(input)
		if precompiled != runtime {
			t.Errorf("ReplaceAllString1(%q) = %q, want %q (runtime)", input, precompiled, runtime)
		}
	}
}

func TestReplaceURLReplaceAllString2(t *testing.T) {
	replacer := "$host"
	for _, input := range replaceURLTestInputs {
		runtime := ReplaceURL{}.ReplaceAllString(input, replacer)
		precompiled := ReplaceURL{}.ReplaceAllString2(input)
		if precompiled != runtime {
			t.Errorf("ReplaceAllString2(%q) = %q, want %q (runtime)", input, precompiled, runtime)
		}
	}
}

package curated

import (
	"bytes"
	"fmt"
	replace "github.com/KromDaniel/regengo/replace"
	stream "github.com/KromDaniel/regengo/stream"
	"io"
	"strings"
	"sync"
)

// Code generated by regengo for pattern: (?P<scheme>https?)://(?P<auth>(?P<user>[\w.-]+)(?::(?P<pass>[\w.-]+))?@)?(?P<host>[\w.-]+)(?::(?P<port>\d+))?(?P<path>/[\w./-]*)?(?:\?(?P<query>[\w=&.-]+))?
// DO NOT EDIT.

var tDFAComplexURLStackPool = sync.Pool{New: func() interface{} {
	stack := make([][3]int, 0, 32)
	return &stack
}}

var tDFAComplexURLCaptureStackPool = sync.Pool{New: func() interface{} {
	stack := make([]int, 0, 288)
	return &stack
}}

var tDFAComplexURLVisitedPool = sync.Pool{New: func() interface{} {
	return new([]uint32)
}}

type TDFAComplexURL struct{}

var CompiledTDFAComplexURL = TDFAComplexURL{}

// MinMatchLen is the minimum number of bytes any match can have.
const TDFAComplexURLMinMatchLen = 8

// MaxMatchLen is the maximum number of bytes any match can have.
// -1 means unbounded (pattern contains * or + quantifiers).
const TDFAComplexURLMaxMatchLen = -1

func (TDFAComplexURL) MatchLengthInfo() (minLen, maxLen int) {
	return TDFAComplexURLMinMatchLen, TDFAComplexURLMaxMatchLen
}

func (TDFAComplexURL) MatchString(input string) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x1000000000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := [49]uint64{2: uint64(uint64(0x8)), 3: uint64(uint64(0x10)), 4: uint64(uint64(0x20)), 5: uint64(uint64(0x3c0)), 6: uint64(uint64(0x300)), 9: uint64(uint64(0x400)), 10: uint64(uint64(0x800)), 11: uint64(uint64(0xe007000)), 14: uint64(uint64(0xc3c000)), 17: uint64(uint64(0xc0000)), 19: uint64(uint64(0xb80000)), 23: uint64(uint64(0xd000000)), 27: uint64(uint64(0x1863878000000)), 30: uint64(uint64(0x180000000)), 32: uint64(uint64(0x1863700000000)), 37: uint64(uint64(0x185c000000000)), 38: uint64(uint64(0x185c000000000)), 42: uint64(uint64(0x180000000000)), 44: uint64(uint64(0x1700000000000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x68) {
				next |= epsilonClosures[2]
			}
			// State 3
			if current&uint64(uint64(0x8)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[3]
			}
			// State 4
			if current&uint64(uint64(0x10)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[4]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x70) {
				next |= epsilonClosures[5]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x73) {
				next |= epsilonClosures[6]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[9]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[10]
			}
			// State 1
			if current&uint64(uint64(0x800)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[11]
			}
			// State 4
			if current&uint64(uint64(0x4000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[14]
			}
			// State 7
			if current&uint64(uint64(0x20000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[17]
			}
			// State 9
			if current&uint64(uint64(0x80000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[19]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && c == uint8(0x40) {
				next |= epsilonClosures[23]
			}
			// State 7
			if current&uint64(uint64(0x8000000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[27]
			}
			// State 0
			if current&uint64(uint64(0x40000000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[30]
			}
			// State 2
			if current&uint64(uint64(0x100000000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[32]
			}
			// State 7
			if current&uint64(uint64(0x2000000000)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[37]
			}
			// State 8
			if current&uint64(uint64(0x4000000000)) != 0 && ((((c >= uint8(0x2d) && c <= uint8(0x39)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[38]
			}
			// State 2
			if current&uint64(uint64(0x40000000000)) != 0 && c == uint8(0x3f) {
				next |= epsilonClosures[42]
			}
			// State 4
			if current&uint64(uint64(0x100000000000)) != 0 && (((((((c == uint8(0x26)) || (c >= uint8(0x2d) && c <= uint8(0x2e))) || (c >= uint8(0x30) && c <= uint8(0x39))) || c == uint8(0x3d)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[44]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}
func (TDFAComplexURL) MatchBytes(input []byte) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x1000000000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := [49]uint64{2: uint64(uint64(0x8)), 3: uint64(uint64(0x10)), 4: uint64(uint64(0x20)), 5: uint64(uint64(0x3c0)), 6: uint64(uint64(0x300)), 9: uint64(uint64(0x400)), 10: uint64(uint64(0x800)), 11: uint64(uint64(0xe007000)), 14: uint64(uint64(0xc3c000)), 17: uint64(uint64(0xc0000)), 19: uint64(uint64(0xb80000)), 23: uint64(uint64(0xd000000)), 27: uint64(uint64(0x1863878000000)), 30: uint64(uint64(0x180000000)), 32: uint64(uint64(0x1863700000000)), 37: uint64(uint64(0x185c000000000)), 38: uint64(uint64(0x185c000000000)), 42: uint64(uint64(0x180000000000)), 44: uint64(uint64(0x1700000000000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x68) {
				next |= epsilonClosures[2]
			}
			// State 3
			if current&uint64(uint64(0x8)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[3]
			}
			// State 4
			if current&uint64(uint64(0x10)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[4]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x70) {
				next |= epsilonClosures[5]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x73) {
				next |= epsilonClosures[6]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[9]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[10]
			}
			// State 1
			if current&uint64(uint64(0x800)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[11]
			}
			// State 4
			if current&uint64(uint64(0x4000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[14]
			}
			// State 7
			if current&uint64(uint64(0x20000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[17]
			}
			// State 9
			if current&uint64(uint64(0x80000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[19]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && c == uint8(0x40) {
				next |= epsilonClosures[23]
			}
			// State 7
			if current&uint64(uint64(0x8000000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[27]
			}
			// State 0
			if current&uint64(uint64(0x40000000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[30]
			}
			// State 2
			if current&uint64(uint64(0x100000000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[32]
			}
			// State 7
			if current&uint64(uint64(0x2000000000)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[37]
			}
			// State 8
			if current&uint64(uint64(0x4000000000)) != 0 && ((((c >= uint8(0x2d) && c <= uint8(0x39)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[38]
			}
			// State 2
			if current&uint64(uint64(0x40000000000)) != 0 && c == uint8(0x3f) {
				next |= epsilonClosures[42]
			}
			// State 4
			if current&uint64(uint64(0x100000000000)) != 0 && (((((((c == uint8(0x26)) || (c >= uint8(0x2d) && c <= uint8(0x2e))) || (c >= uint8(0x30) && c <= uint8(0x39))) || c == uint8(0x3d)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[44]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty string when not matched.

type TDFAComplexURLResult struct {
	Match  string // Full match
	Scheme string
	Auth   string
	User   string
	Pass   string
	Host   string
	Port   string
	Path   string
	Query  string
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty slice when not matched.

type TDFAComplexURLBytesResult struct {
	Match  []byte // Full match
	Scheme []byte
	Auth   []byte
	User   []byte
	Pass   []byte
	Host   []byte
	Port   []byte
	Path   []byte
	Query  []byte
}

func (TDFAComplexURL) FindStringReuse(input string, r *TDFAComplexURLResult) (*TDFAComplexURLResult, bool) {
	l := len(input)
	offset := 0
	var captures [18]int
	stackPtr := tDFAComplexURLStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		tDFAComplexURLStackPool.Put(stackPtr)
	}()
	visitedSize := 49 * (l + 1)
	visitedWords := (visitedSize + 31) / 32
	visitedPtr := tDFAComplexURLVisitedPool.Get().(*[]uint32)
	visited := *visitedPtr
	if cap(visited) < visitedWords {
		visited = make([]uint32, visitedWords)
	} else {
		visited = visited[:visitedWords]
		for i := range visited {
			visited[i] = 0
		}
	}
	defer func() {
		*visitedPtr = visited
		tDFAComplexURLVisitedPool.Put(visitedPtr)
	}()
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	for len(stack) > 0 {
		last := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if last[2] == 2 {
			captures[last[1]] = last[0]
			continue
		}
		offset = last[0]
		nextInstruction = last[1]
		goto StepSelect
	}
	{
		if l > offset {
			offset++
			for i := range captures {
				captures[i] = 0
			}
			for i := range visited {
				visited[i] = 0
			}
			captures[0] = offset
			nextInstruction = 1
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	case 18:
		goto Ins18
	case 19:
		goto Ins19
	case 20:
		goto Ins20
	case 21:
		goto Ins21
	case 22:
		goto Ins22
	case 23:
		goto Ins23
	case 24:
		goto Ins24
	case 25:
		goto Ins25
	case 26:
		goto Ins26
	case 27:
		goto Ins27
	case 28:
		goto Ins28
	case 29:
		goto Ins29
	case 30:
		goto Ins30
	case 31:
		goto Ins31
	case 32:
		goto Ins32
	case 33:
		goto Ins33
	case 34:
		goto Ins34
	case 35:
		goto Ins35
	case 36:
		goto Ins36
	case 37:
		goto Ins37
	case 38:
		goto Ins38
	case 39:
		goto Ins39
	case 40:
		goto Ins40
	case 41:
		goto Ins41
	case 42:
		goto Ins42
	case 43:
		goto Ins43
	case 44:
		goto Ins44
	case 45:
		goto Ins45
	case 46:
		goto Ins46
	case 47:
		goto Ins47
	case 48:
		goto Ins48
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		stack = append(stack, [3]int{captures[2], 2, 2})
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x68) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x74) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x74) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x70) {
			goto TryFallback
		}
		offset++
		goto Ins7
	}
Ins6:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x73) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins7:
	{
		idx := 7*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 8, 0})
		goto Ins6
	}
Ins8:
	{
		stack = append(stack, [3]int{captures[3], 3, 2})
		captures[3] = offset
		nextInstruction = 9
		goto StepSelect
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3a) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2f) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2f) {
			goto TryFallback
		}
		offset++
		goto Ins25
	}
Ins12:
	{
		stack = append(stack, [3]int{captures[4], 4, 2})
		captures[4] = offset
		nextInstruction = 13
		goto StepSelect
	}
Ins13:
	{
		stack = append(stack, [3]int{captures[6], 6, 2})
		captures[6] = offset
		nextInstruction = 14
		goto StepSelect
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		idx := 15*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 16, 0})
		goto Ins14
	}
Ins16:
	{
		stack = append(stack, [3]int{captures[7], 7, 2})
		captures[7] = offset
		nextInstruction = 22
		goto StepSelect
	}
Ins17:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3a) {
			goto TryFallback
		}
		offset++
		goto Ins18
	}
Ins18:
	{
		stack = append(stack, [3]int{captures[8], 8, 2})
		captures[8] = offset
		nextInstruction = 19
		goto StepSelect
	}
Ins19:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins20
	}
Ins20:
	{
		idx := 20*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 21, 0})
		goto Ins19
	}
Ins21:
	{
		stack = append(stack, [3]int{captures[9], 9, 2})
		captures[9] = offset
		nextInstruction = 23
		goto StepSelect
	}
Ins22:
	{
		idx := 22*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 23, 0})
		goto Ins17
	}
Ins23:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins24
	}
Ins24:
	{
		stack = append(stack, [3]int{captures[5], 5, 2})
		captures[5] = offset
		nextInstruction = 26
		goto StepSelect
	}
Ins25:
	{
		idx := 25*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 26, 0})
		goto Ins12
	}
Ins26:
	{
		stack = append(stack, [3]int{captures[10], 10, 2})
		captures[10] = offset
		nextInstruction = 27
		goto StepSelect
	}
Ins27:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins28
	}
Ins28:
	{
		idx := 28*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 29, 0})
		goto Ins27
	}
Ins29:
	{
		stack = append(stack, [3]int{captures[11], 11, 2})
		captures[11] = offset
		nextInstruction = 35
		goto StepSelect
	}
Ins30:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3a) {
			goto TryFallback
		}
		offset++
		goto Ins31
	}
Ins31:
	{
		stack = append(stack, [3]int{captures[12], 12, 2})
		captures[12] = offset
		nextInstruction = 32
		goto StepSelect
	}
Ins32:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins33
	}
Ins33:
	{
		idx := 33*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 34, 0})
		goto Ins32
	}
Ins34:
	{
		stack = append(stack, [3]int{captures[13], 13, 2})
		captures[13] = offset
		nextInstruction = 41
		goto StepSelect
	}
Ins35:
	{
		idx := 35*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 41, 0})
		goto Ins30
	}
Ins36:
	{
		stack = append(stack, [3]int{captures[14], 14, 2})
		captures[14] = offset
		nextInstruction = 37
		goto StepSelect
	}
Ins37:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2f) {
			goto TryFallback
		}
		offset++
		goto Ins39
	}
Ins38:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0xe0), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins39
	}
Ins39:
	{
		idx := 39*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 40, 0})
		goto Ins38
	}
Ins40:
	{
		stack = append(stack, [3]int{captures[15], 15, 2})
		captures[15] = offset
		nextInstruction = 47
		goto StepSelect
	}
Ins41:
	{
		idx := 41*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 47, 0})
		goto Ins36
	}
Ins42:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3f) {
			goto TryFallback
		}
		offset++
		goto Ins43
	}
Ins43:
	{
		stack = append(stack, [3]int{captures[16], 16, 2})
		captures[16] = offset
		nextInstruction = 44
		goto StepSelect
	}
Ins44:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x40), uint8(0x60), uint8(0xff), uint8(0x23), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins45
	}
Ins45:
	{
		idx := 45*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 46, 0})
		goto Ins44
	}
Ins46:
	{
		stack = append(stack, [3]int{captures[17], 17, 2})
		captures[17] = offset
		nextInstruction = 48
		goto StepSelect
	}
Ins47:
	{
		idx := 47*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 48, 0})
		goto Ins42
	}
Ins48:
	{
		captures[1] = offset
		if r == nil {
			r = &TDFAComplexURLResult{}
		}
		r.Match = string(input[captures[0]:captures[1]])
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.Scheme = string(input[captures[2]:captures[3]])
		} else {
			r.Scheme = ""
		}
		if captures[4] <= captures[5] && captures[5] <= len(input) {
			r.Auth = string(input[captures[4]:captures[5]])
		} else {
			r.Auth = ""
		}
		if captures[6] <= captures[7] && captures[7] <= len(input) {
			r.User = string(input[captures[6]:captures[7]])
		} else {
			r.User = ""
		}
		if captures[8] <= captures[9] && captures[9] <= len(input) {
			r.Pass = string(input[captures[8]:captures[9]])
		} else {
			r.Pass = ""
		}
		if captures[10] <= captures[11] && captures[11] <= len(input) {
			r.Host = string(input[captures[10]:captures[11]])
		} else {
			r.Host = ""
		}
		if captures[12] <= captures[13] && captures[13] <= len(input) {
			r.Port = string(input[captures[12]:captures[13]])
		} else {
			r.Port = ""
		}
		if captures[14] <= captures[15] && captures[15] <= len(input) {
			r.Path = string(input[captures[14]:captures[15]])
		} else {
			r.Path = ""
		}
		if captures[16] <= captures[17] && captures[17] <= len(input) {
			r.Query = string(input[captures[16]:captures[17]])
		} else {
			r.Query = ""
		}
		return r, true
	}
}
func (recv TDFAComplexURL) FindString(input string) (*TDFAComplexURLResult, bool) {
	return recv.FindStringReuse(input, nil)
}
func (TDFAComplexURL) FindAllStringAppend(input string, n int, s []*TDFAComplexURLResult) []*TDFAComplexURLResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	stackPtr := tDFAComplexURLStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		tDFAComplexURLStackPool.Put(stackPtr)
	}()
	visitedSize := 49 * (l + 1)
	visitedWords := (visitedSize + 31) / 32
	visitedPtr := tDFAComplexURLVisitedPool.Get().(*[]uint32)
	visited := *visitedPtr
	if cap(visited) < visitedWords {
		visited = make([]uint32, visitedWords)
	} else {
		visited = visited[:visitedWords]
		for i := range visited {
			visited[i] = 0
		}
	}
	defer func() {
		*visitedPtr = visited
		tDFAComplexURLVisitedPool.Put(visitedPtr)
	}()
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [18]int
		stack = stack[:0]
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		for len(stack) > 0 {
			last := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			if last[2] == 2 {
				captures[last[1]] = last[0]
				continue
			}
			offset = last[0]
			nextInstruction = last[1]
			goto StepSelect
		}
		searchStart++
		continue
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		case 16:
			goto Ins16
		case 17:
			goto Ins17
		case 18:
			goto Ins18
		case 19:
			goto Ins19
		case 20:
			goto Ins20
		case 21:
			goto Ins21
		case 22:
			goto Ins22
		case 23:
			goto Ins23
		case 24:
			goto Ins24
		case 25:
			goto Ins25
		case 26:
			goto Ins26
		case 27:
			goto Ins27
		case 28:
			goto Ins28
		case 29:
			goto Ins29
		case 30:
			goto Ins30
		case 31:
			goto Ins31
		case 32:
			goto Ins32
		case 33:
			goto Ins33
		case 34:
			goto Ins34
		case 35:
			goto Ins35
		case 36:
			goto Ins36
		case 37:
			goto Ins37
		case 38:
			goto Ins38
		case 39:
			goto Ins39
		case 40:
			goto Ins40
		case 41:
			goto Ins41
		case 42:
			goto Ins42
		case 43:
			goto Ins43
		case 44:
			goto Ins44
		case 45:
			goto Ins45
		case 46:
			goto Ins46
		case 47:
			goto Ins47
		case 48:
			goto Ins48
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			stack = append(stack, [3]int{captures[2], 2, 2})
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x68) {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x74) {
				goto TryFallback
			}
			offset++
			goto Ins4
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x74) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x70) {
				goto TryFallback
			}
			offset++
			goto Ins7
		}
	Ins6:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x73) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins7:
		{
			idx := 7*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 8, 0})
			goto Ins6
		}
	Ins8:
		{
			stack = append(stack, [3]int{captures[3], 3, 2})
			captures[3] = offset
			nextInstruction = 9
			goto StepSelect
		}
	Ins9:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3a) {
				goto TryFallback
			}
			offset++
			goto Ins10
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2f) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2f) {
				goto TryFallback
			}
			offset++
			goto Ins25
		}
	Ins12:
		{
			stack = append(stack, [3]int{captures[4], 4, 2})
			captures[4] = offset
			nextInstruction = 13
			goto StepSelect
		}
	Ins13:
		{
			stack = append(stack, [3]int{captures[6], 6, 2})
			captures[6] = offset
			nextInstruction = 14
			goto StepSelect
		}
	Ins14:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins15
		}
	Ins15:
		{
			idx := 15*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 16, 0})
			goto Ins14
		}
	Ins16:
		{
			stack = append(stack, [3]int{captures[7], 7, 2})
			captures[7] = offset
			nextInstruction = 22
			goto StepSelect
		}
	Ins17:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3a) {
				goto TryFallback
			}
			offset++
			goto Ins18
		}
	Ins18:
		{
			stack = append(stack, [3]int{captures[8], 8, 2})
			captures[8] = offset
			nextInstruction = 19
			goto StepSelect
		}
	Ins19:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins20
		}
	Ins20:
		{
			idx := 20*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 21, 0})
			goto Ins19
		}
	Ins21:
		{
			stack = append(stack, [3]int{captures[9], 9, 2})
			captures[9] = offset
			nextInstruction = 23
			goto StepSelect
		}
	Ins22:
		{
			idx := 22*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 23, 0})
			goto Ins17
		}
	Ins23:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x40) {
				goto TryFallback
			}
			offset++
			goto Ins24
		}
	Ins24:
		{
			stack = append(stack, [3]int{captures[5], 5, 2})
			captures[5] = offset
			nextInstruction = 26
			goto StepSelect
		}
	Ins25:
		{
			idx := 25*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 26, 0})
			goto Ins12
		}
	Ins26:
		{
			stack = append(stack, [3]int{captures[10], 10, 2})
			captures[10] = offset
			nextInstruction = 27
			goto StepSelect
		}
	Ins27:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins28
		}
	Ins28:
		{
			idx := 28*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 29, 0})
			goto Ins27
		}
	Ins29:
		{
			stack = append(stack, [3]int{captures[11], 11, 2})
			captures[11] = offset
			nextInstruction = 35
			goto StepSelect
		}
	Ins30:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3a) {
				goto TryFallback
			}
			offset++
			goto Ins31
		}
	Ins31:
		{
			stack = append(stack, [3]int{captures[12], 12, 2})
			captures[12] = offset
			nextInstruction = 32
			goto StepSelect
		}
	Ins32:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins33
		}
	Ins33:
		{
			idx := 33*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 34, 0})
			goto Ins32
		}
	Ins34:
		{
			stack = append(stack, [3]int{captures[13], 13, 2})
			captures[13] = offset
			nextInstruction = 41
			goto StepSelect
		}
	Ins35:
		{
			idx := 35*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 41, 0})
			goto Ins30
		}
	Ins36:
		{
			stack = append(stack, [3]int{captures[14], 14, 2})
			captures[14] = offset
			nextInstruction = 37
			goto StepSelect
		}
	Ins37:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2f) {
				goto TryFallback
			}
			offset++
			goto Ins39
		}
	Ins38:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0xe0), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins39
		}
	Ins39:
		{
			idx := 39*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 40, 0})
			goto Ins38
		}
	Ins40:
		{
			stack = append(stack, [3]int{captures[15], 15, 2})
			captures[15] = offset
			nextInstruction = 47
			goto StepSelect
		}
	Ins41:
		{
			idx := 41*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 47, 0})
			goto Ins36
		}
	Ins42:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3f) {
				goto TryFallback
			}
			offset++
			goto Ins43
		}
	Ins43:
		{
			stack = append(stack, [3]int{captures[16], 16, 2})
			captures[16] = offset
			nextInstruction = 44
			goto StepSelect
		}
	Ins44:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x40), uint8(0x60), uint8(0xff), uint8(0x23), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins45
		}
	Ins45:
		{
			idx := 45*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 46, 0})
			goto Ins44
		}
	Ins46:
		{
			stack = append(stack, [3]int{captures[17], 17, 2})
			captures[17] = offset
			nextInstruction = 48
			goto StepSelect
		}
	Ins47:
		{
			idx := 47*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 48, 0})
			goto Ins42
		}
	Ins48:
		{
			captures[1] = offset
			var item *TDFAComplexURLResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &TDFAComplexURLResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &TDFAComplexURLResult{}
				result = append(result, item)
			}
			item.Match = string(input[captures[0]:captures[1]])
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.Scheme = string(input[captures[2]:captures[3]])
			} else {
				item.Scheme = ""
			}
			if captures[4] <= captures[5] && captures[5] <= len(input) {
				item.Auth = string(input[captures[4]:captures[5]])
			} else {
				item.Auth = ""
			}
			if captures[6] <= captures[7] && captures[7] <= len(input) {
				item.User = string(input[captures[6]:captures[7]])
			} else {
				item.User = ""
			}
			if captures[8] <= captures[9] && captures[9] <= len(input) {
				item.Pass = string(input[captures[8]:captures[9]])
			} else {
				item.Pass = ""
			}
			if captures[10] <= captures[11] && captures[11] <= len(input) {
				item.Host = string(input[captures[10]:captures[11]])
			} else {
				item.Host = ""
			}
			if captures[12] <= captures[13] && captures[13] <= len(input) {
				item.Port = string(input[captures[12]:captures[13]])
			} else {
				item.Port = ""
			}
			if captures[14] <= captures[15] && captures[15] <= len(input) {
				item.Path = string(input[captures[14]:captures[15]])
			} else {
				item.Path = ""
			}
			if captures[16] <= captures[17] && captures[17] <= len(input) {
				item.Query = string(input[captures[16]:captures[17]])
			} else {
				item.Query = ""
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r TDFAComplexURL) FindAllString(input string, n int) []*TDFAComplexURLResult {
	return r.FindAllStringAppend(input, n, nil)
}
func (TDFAComplexURL) FindBytesReuse(input []byte, r *TDFAComplexURLBytesResult) (*TDFAComplexURLBytesResult, bool) {
	l := len(input)
	offset := 0
	var captures [18]int
	stackPtr := tDFAComplexURLStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		tDFAComplexURLStackPool.Put(stackPtr)
	}()
	visitedSize := 49 * (l + 1)
	visitedWords := (visitedSize + 31) / 32
	visitedPtr := tDFAComplexURLVisitedPool.Get().(*[]uint32)
	visited := *visitedPtr
	if cap(visited) < visitedWords {
		visited = make([]uint32, visitedWords)
	} else {
		visited = visited[:visitedWords]
		for i := range visited {
			visited[i] = 0
		}
	}
	defer func() {
		*visitedPtr = visited
		tDFAComplexURLVisitedPool.Put(visitedPtr)
	}()
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	for len(stack) > 0 {
		last := stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		if last[2] == 2 {
			captures[last[1]] = last[0]
			continue
		}
		offset = last[0]
		nextInstruction = last[1]
		goto StepSelect
	}
	{
		if l > offset {
			offset++
			for i := range captures {
				captures[i] = 0
			}
			for i := range visited {
				visited[i] = 0
			}
			captures[0] = offset
			nextInstruction = 1
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	case 18:
		goto Ins18
	case 19:
		goto Ins19
	case 20:
		goto Ins20
	case 21:
		goto Ins21
	case 22:
		goto Ins22
	case 23:
		goto Ins23
	case 24:
		goto Ins24
	case 25:
		goto Ins25
	case 26:
		goto Ins26
	case 27:
		goto Ins27
	case 28:
		goto Ins28
	case 29:
		goto Ins29
	case 30:
		goto Ins30
	case 31:
		goto Ins31
	case 32:
		goto Ins32
	case 33:
		goto Ins33
	case 34:
		goto Ins34
	case 35:
		goto Ins35
	case 36:
		goto Ins36
	case 37:
		goto Ins37
	case 38:
		goto Ins38
	case 39:
		goto Ins39
	case 40:
		goto Ins40
	case 41:
		goto Ins41
	case 42:
		goto Ins42
	case 43:
		goto Ins43
	case 44:
		goto Ins44
	case 45:
		goto Ins45
	case 46:
		goto Ins46
	case 47:
		goto Ins47
	case 48:
		goto Ins48
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		stack = append(stack, [3]int{captures[2], 2, 2})
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x68) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x74) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x74) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x70) {
			goto TryFallback
		}
		offset++
		goto Ins7
	}
Ins6:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x73) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins7:
	{
		idx := 7*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 8, 0})
		goto Ins6
	}
Ins8:
	{
		stack = append(stack, [3]int{captures[3], 3, 2})
		captures[3] = offset
		nextInstruction = 9
		goto StepSelect
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3a) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2f) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2f) {
			goto TryFallback
		}
		offset++
		goto Ins25
	}
Ins12:
	{
		stack = append(stack, [3]int{captures[4], 4, 2})
		captures[4] = offset
		nextInstruction = 13
		goto StepSelect
	}
Ins13:
	{
		stack = append(stack, [3]int{captures[6], 6, 2})
		captures[6] = offset
		nextInstruction = 14
		goto StepSelect
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		idx := 15*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 16, 0})
		goto Ins14
	}
Ins16:
	{
		stack = append(stack, [3]int{captures[7], 7, 2})
		captures[7] = offset
		nextInstruction = 22
		goto StepSelect
	}
Ins17:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3a) {
			goto TryFallback
		}
		offset++
		goto Ins18
	}
Ins18:
	{
		stack = append(stack, [3]int{captures[8], 8, 2})
		captures[8] = offset
		nextInstruction = 19
		goto StepSelect
	}
Ins19:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins20
	}
Ins20:
	{
		idx := 20*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 21, 0})
		goto Ins19
	}
Ins21:
	{
		stack = append(stack, [3]int{captures[9], 9, 2})
		captures[9] = offset
		nextInstruction = 23
		goto StepSelect
	}
Ins22:
	{
		idx := 22*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 23, 0})
		goto Ins17
	}
Ins23:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins24
	}
Ins24:
	{
		stack = append(stack, [3]int{captures[5], 5, 2})
		captures[5] = offset
		nextInstruction = 26
		goto StepSelect
	}
Ins25:
	{
		idx := 25*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 26, 0})
		goto Ins12
	}
Ins26:
	{
		stack = append(stack, [3]int{captures[10], 10, 2})
		captures[10] = offset
		nextInstruction = 27
		goto StepSelect
	}
Ins27:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins28
	}
Ins28:
	{
		idx := 28*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 29, 0})
		goto Ins27
	}
Ins29:
	{
		stack = append(stack, [3]int{captures[11], 11, 2})
		captures[11] = offset
		nextInstruction = 35
		goto StepSelect
	}
Ins30:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3a) {
			goto TryFallback
		}
		offset++
		goto Ins31
	}
Ins31:
	{
		stack = append(stack, [3]int{captures[12], 12, 2})
		captures[12] = offset
		nextInstruction = 32
		goto StepSelect
	}
Ins32:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins33
	}
Ins33:
	{
		idx := 33*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 34, 0})
		goto Ins32
	}
Ins34:
	{
		stack = append(stack, [3]int{captures[13], 13, 2})
		captures[13] = offset
		nextInstruction = 41
		goto StepSelect
	}
Ins35:
	{
		idx := 35*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 41, 0})
		goto Ins30
	}
Ins36:
	{
		stack = append(stack, [3]int{captures[14], 14, 2})
		captures[14] = offset
		nextInstruction = 37
		goto StepSelect
	}
Ins37:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2f) {
			goto TryFallback
		}
		offset++
		goto Ins39
	}
Ins38:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0xe0), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins39
	}
Ins39:
	{
		idx := 39*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 40, 0})
		goto Ins38
	}
Ins40:
	{
		stack = append(stack, [3]int{captures[15], 15, 2})
		captures[15] = offset
		nextInstruction = 47
		goto StepSelect
	}
Ins41:
	{
		idx := 41*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 47, 0})
		goto Ins36
	}
Ins42:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x3f) {
			goto TryFallback
		}
		offset++
		goto Ins43
	}
Ins43:
	{
		stack = append(stack, [3]int{captures[16], 16, 2})
		captures[16] = offset
		nextInstruction = 44
		goto StepSelect
	}
Ins44:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x40), uint8(0x60), uint8(0xff), uint8(0x23), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins45
	}
Ins45:
	{
		idx := 45*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 46, 0})
		goto Ins44
	}
Ins46:
	{
		stack = append(stack, [3]int{captures[17], 17, 2})
		captures[17] = offset
		nextInstruction = 48
		goto StepSelect
	}
Ins47:
	{
		idx := 47*(l+1) + offset
		word, bit := idx/32, uint32(1)<<(idx%32)
		if visited[word]&bit != 0 {
			goto TryFallback
		}
		visited[word] |= bit
		stack = append(stack, [3]int{offset, 48, 0})
		goto Ins42
	}
Ins48:
	{
		captures[1] = offset
		if r == nil {
			r = &TDFAComplexURLBytesResult{}
		}
		r.Match = input[captures[0]:captures[1]]
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.Scheme = input[captures[2]:captures[3]]
		} else {
			r.Scheme = nil
		}
		if captures[4] <= captures[5] && captures[5] <= len(input) {
			r.Auth = input[captures[4]:captures[5]]
		} else {
			r.Auth = nil
		}
		if captures[6] <= captures[7] && captures[7] <= len(input) {
			r.User = input[captures[6]:captures[7]]
		} else {
			r.User = nil
		}
		if captures[8] <= captures[9] && captures[9] <= len(input) {
			r.Pass = input[captures[8]:captures[9]]
		} else {
			r.Pass = nil
		}
		if captures[10] <= captures[11] && captures[11] <= len(input) {
			r.Host = input[captures[10]:captures[11]]
		} else {
			r.Host = nil
		}
		if captures[12] <= captures[13] && captures[13] <= len(input) {
			r.Port = input[captures[12]:captures[13]]
		} else {
			r.Port = nil
		}
		if captures[14] <= captures[15] && captures[15] <= len(input) {
			r.Path = input[captures[14]:captures[15]]
		} else {
			r.Path = nil
		}
		if captures[16] <= captures[17] && captures[17] <= len(input) {
			r.Query = input[captures[16]:captures[17]]
		} else {
			r.Query = nil
		}
		return r, true
	}
}
func (recv TDFAComplexURL) FindBytes(input []byte) (*TDFAComplexURLBytesResult, bool) {
	return recv.FindBytesReuse(input, nil)
}
func (TDFAComplexURL) FindAllBytesAppend(input []byte, n int, s []*TDFAComplexURLBytesResult) []*TDFAComplexURLBytesResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	stackPtr := tDFAComplexURLStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		tDFAComplexURLStackPool.Put(stackPtr)
	}()
	visitedSize := 49 * (l + 1)
	visitedWords := (visitedSize + 31) / 32
	visitedPtr := tDFAComplexURLVisitedPool.Get().(*[]uint32)
	visited := *visitedPtr
	if cap(visited) < visitedWords {
		visited = make([]uint32, visitedWords)
	} else {
		visited = visited[:visitedWords]
		for i := range visited {
			visited[i] = 0
		}
	}
	defer func() {
		*visitedPtr = visited
		tDFAComplexURLVisitedPool.Put(visitedPtr)
	}()
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [18]int
		stack = stack[:0]
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		for len(stack) > 0 {
			last := stack[len(stack)-1]
			stack = stack[:len(stack)-1]
			if last[2] == 2 {
				captures[last[1]] = last[0]
				continue
			}
			offset = last[0]
			nextInstruction = last[1]
			goto StepSelect
		}
		searchStart++
		continue
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		case 16:
			goto Ins16
		case 17:
			goto Ins17
		case 18:
			goto Ins18
		case 19:
			goto Ins19
		case 20:
			goto Ins20
		case 21:
			goto Ins21
		case 22:
			goto Ins22
		case 23:
			goto Ins23
		case 24:
			goto Ins24
		case 25:
			goto Ins25
		case 26:
			goto Ins26
		case 27:
			goto Ins27
		case 28:
			goto Ins28
		case 29:
			goto Ins29
		case 30:
			goto Ins30
		case 31:
			goto Ins31
		case 32:
			goto Ins32
		case 33:
			goto Ins33
		case 34:
			goto Ins34
		case 35:
			goto Ins35
		case 36:
			goto Ins36
		case 37:
			goto Ins37
		case 38:
			goto Ins38
		case 39:
			goto Ins39
		case 40:
			goto Ins40
		case 41:
			goto Ins41
		case 42:
			goto Ins42
		case 43:
			goto Ins43
		case 44:
			goto Ins44
		case 45:
			goto Ins45
		case 46:
			goto Ins46
		case 47:
			goto Ins47
		case 48:
			goto Ins48
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			stack = append(stack, [3]int{captures[2], 2, 2})
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x68) {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x74) {
				goto TryFallback
			}
			offset++
			goto Ins4
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x74) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x70) {
				goto TryFallback
			}
			offset++
			goto Ins7
		}
	Ins6:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x73) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins7:
		{
			idx := 7*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 8, 0})
			goto Ins6
		}
	Ins8:
		{
			stack = append(stack, [3]int{captures[3], 3, 2})
			captures[3] = offset
			nextInstruction = 9
			goto StepSelect
		}
	Ins9:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3a) {
				goto TryFallback
			}
			offset++
			goto Ins10
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2f) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2f) {
				goto TryFallback
			}
			offset++
			goto Ins25
		}
	Ins12:
		{
			stack = append(stack, [3]int{captures[4], 4, 2})
			captures[4] = offset
			nextInstruction = 13
			goto StepSelect
		}
	Ins13:
		{
			stack = append(stack, [3]int{captures[6], 6, 2})
			captures[6] = offset
			nextInstruction = 14
			goto StepSelect
		}
	Ins14:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins15
		}
	Ins15:
		{
			idx := 15*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 16, 0})
			goto Ins14
		}
	Ins16:
		{
			stack = append(stack, [3]int{captures[7], 7, 2})
			captures[7] = offset
			nextInstruction = 22
			goto StepSelect
		}
	Ins17:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3a) {
				goto TryFallback
			}
			offset++
			goto Ins18
		}
	Ins18:
		{
			stack = append(stack, [3]int{captures[8], 8, 2})
			captures[8] = offset
			nextInstruction = 19
			goto StepSelect
		}
	Ins19:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins20
		}
	Ins20:
		{
			idx := 20*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 21, 0})
			goto Ins19
		}
	Ins21:
		{
			stack = append(stack, [3]int{captures[9], 9, 2})
			captures[9] = offset
			nextInstruction = 23
			goto StepSelect
		}
	Ins22:
		{
			idx := 22*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 23, 0})
			goto Ins17
		}
	Ins23:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x40) {
				goto TryFallback
			}
			offset++
			goto Ins24
		}
	Ins24:
		{
			stack = append(stack, [3]int{captures[5], 5, 2})
			captures[5] = offset
			nextInstruction = 26
			goto StepSelect
		}
	Ins25:
		{
			idx := 25*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 26, 0})
			goto Ins12
		}
	Ins26:
		{
			stack = append(stack, [3]int{captures[10], 10, 2})
			captures[10] = offset
			nextInstruction = 27
			goto StepSelect
		}
	Ins27:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins28
		}
	Ins28:
		{
			idx := 28*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 29, 0})
			goto Ins27
		}
	Ins29:
		{
			stack = append(stack, [3]int{captures[11], 11, 2})
			captures[11] = offset
			nextInstruction = 35
			goto StepSelect
		}
	Ins30:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3a) {
				goto TryFallback
			}
			offset++
			goto Ins31
		}
	Ins31:
		{
			stack = append(stack, [3]int{captures[12], 12, 2})
			captures[12] = offset
			nextInstruction = 32
			goto StepSelect
		}
	Ins32:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins33
		}
	Ins33:
		{
			idx := 33*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 34, 0})
			goto Ins32
		}
	Ins34:
		{
			stack = append(stack, [3]int{captures[13], 13, 2})
			captures[13] = offset
			nextInstruction = 41
			goto StepSelect
		}
	Ins35:
		{
			idx := 35*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 41, 0})
			goto Ins30
		}
	Ins36:
		{
			stack = append(stack, [3]int{captures[14], 14, 2})
			captures[14] = offset
			nextInstruction = 37
			goto StepSelect
		}
	Ins37:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2f) {
				goto TryFallback
			}
			offset++
			goto Ins39
		}
	Ins38:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0xe0), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins39
		}
	Ins39:
		{
			idx := 39*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 40, 0})
			goto Ins38
		}
	Ins40:
		{
			stack = append(stack, [3]int{captures[15], 15, 2})
			captures[15] = offset
			nextInstruction = 47
			goto StepSelect
		}
	Ins41:
		{
			idx := 41*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 47, 0})
			goto Ins36
		}
	Ins42:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x3f) {
				goto TryFallback
			}
			offset++
			goto Ins43
		}
	Ins43:
		{
			stack = append(stack, [3]int{captures[16], 16, 2})
			captures[16] = offset
			nextInstruction = 44
			goto StepSelect
		}
	Ins44:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x40), uint8(0x60), uint8(0xff), uint8(0x23), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins45
		}
	Ins45:
		{
			idx := 45*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 46, 0})
			goto Ins44
		}
	Ins46:
		{
			stack = append(stack, [3]int{captures[17], 17, 2})
			captures[17] = offset
			nextInstruction = 48
			goto StepSelect
		}
	Ins47:
		{
			idx := 47*(l+1) + offset
			word, bit := idx/32, uint32(1)<<(idx%32)
			if visited[word]&bit != 0 {
				goto TryFallback
			}
			visited[word] |= bit
			stack = append(stack, [3]int{offset, 48, 0})
			goto Ins42
		}
	Ins48:
		{
			captures[1] = offset
			var item *TDFAComplexURLBytesResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &TDFAComplexURLBytesResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &TDFAComplexURLBytesResult{}
				result = append(result, item)
			}
			item.Match = input[captures[0]:captures[1]]
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.Scheme = input[captures[2]:captures[3]]
			} else {
				item.Scheme = nil
			}
			if captures[4] <= captures[5] && captures[5] <= len(input) {
				item.Auth = input[captures[4]:captures[5]]
			} else {
				item.Auth = nil
			}
			if captures[6] <= captures[7] && captures[7] <= len(input) {
				item.User = input[captures[6]:captures[7]]
			} else {
				item.User = nil
			}
			if captures[8] <= captures[9] && captures[9] <= len(input) {
				item.Pass = input[captures[8]:captures[9]]
			} else {
				item.Pass = nil
			}
			if captures[10] <= captures[11] && captures[11] <= len(input) {
				item.Host = input[captures[10]:captures[11]]
			} else {
				item.Host = nil
			}
			if captures[12] <= captures[13] && captures[13] <= len(input) {
				item.Port = input[captures[12]:captures[13]]
			} else {
				item.Port = nil
			}
			if captures[14] <= captures[15] && captures[15] <= len(input) {
				item.Path = input[captures[14]:captures[15]]
			} else {
				item.Path = nil
			}
			if captures[16] <= captures[17] && captures[17] <= len(input) {
				item.Query = input[captures[16]:captures[17]]
			} else {
				item.Query = nil
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r TDFAComplexURL) FindAllBytes(input []byte, n int) []*TDFAComplexURLBytesResult {
	return r.FindAllBytesAppend(input, n, nil)
}

// DefaultMaxLeftover returns the recommended MaxLeftover value for streaming.
// For bounded patterns, this is 10 * MaxMatchLen.
// For unbounded patterns, this returns 1MB as a safety limit.
func (TDFAComplexURL) DefaultMaxLeftover() int {
	return 1048576
}

// FindReader streams matches from an io.Reader.
//
// The onMatch callback is called for each match found. Return false to stop
// processing early. The StreamMatch.Result points into an internal buffer
// and is only valid during the callback - copy if needed.
//
// Returns nil on success (including early termination via callback).
// Returns error on read failure.
func (TDFAComplexURL) FindReader(r io.Reader, cfg stream.Config, onMatch func(stream.Match[*TDFAComplexURLBytesResult]) bool) error {
	if err := cfg.Validate(65536); err != nil {
		return err
	}
	cfg = cfg.ApplyDefaults(65536, 1048576)

	buf := make([]byte, cfg.BufferSize)
	leftover := 0
	streamOffset := int64(0)
	chunkIndex := 0

	reuseResult := &TDFAComplexURLBytesResult{}

	for {
		n, err := r.Read(buf[leftover:])
		if n == 0 && err != nil {
			if err == io.EOF {
				// Process any remaining data in leftover
				if leftover > 0 {
					chunk := buf[:leftover]
					searchPos := 0
					for searchPos < len(chunk) {
						result, ok := TDFAComplexURL{}.FindBytesReuse(chunk[searchPos:], reuseResult)
						if !ok {
							break
						}
						matchIdx := bytes.Index(chunk[searchPos:], result.Match)
						if matchIdx < 0 {
							break
						}
						matchStart := searchPos + matchIdx

						m := stream.Match[*TDFAComplexURLBytesResult]{
							ChunkIndex:   chunkIndex,
							Result:       result,
							StreamOffset: streamOffset + int64(matchStart),
						}
						if !onMatch(m) {
							return nil
						}
						if len(result.Match) > 0 {
							searchPos = matchStart + len(result.Match)
						} else {
							searchPos++
						}
					}
				}
				return nil
			}
			return err
		}

		dataLen := leftover + n
		chunk := buf[:dataLen]
		isFull := n == cfg.BufferSize-leftover

		searchPos := 0
		committed := 0
		for searchPos < len(chunk) {
			result, ok := TDFAComplexURL{}.FindBytesReuse(chunk[searchPos:], reuseResult)
			if !ok {
				break
			}
			matchIdx := bytes.Index(chunk[searchPos:], result.Match)
			if matchIdx < 0 {
				break
			}
			matchStart := searchPos + matchIdx
			matchEnd := matchStart + len(result.Match)

			if isFull && matchEnd > dataLen-cfg.MaxLeftover {
				// Match too close to boundary, defer to next chunk
				break
			}

			m := stream.Match[*TDFAComplexURLBytesResult]{
				ChunkIndex:   chunkIndex,
				Result:       result,
				StreamOffset: streamOffset + int64(matchStart),
			}
			if !onMatch(m) {
				return nil
			}
			committed = matchEnd
			if len(result.Match) > 0 {
				searchPos = matchEnd
			} else {
				searchPos++
			}
		}

		// Prepare leftover for next iteration
		if isFull {
			// Buffer was full, need to keep leftover
			keepFrom := dataLen - cfg.MaxLeftover
			if keepFrom < committed {
				keepFrom = committed
			}
			leftover = dataLen - keepFrom
			streamOffset += int64(keepFrom)
			copy(buf[:leftover], buf[keepFrom:dataLen])
		} else {
			// Reached EOF or short read, no more data
			leftover = 0
		}
		chunkIndex++
		if err == io.EOF {
			return nil
		}
	}
}

// FindReaderCount counts matches without allocating result structs.
// More efficient when you only need the count.
func (TDFAComplexURL) FindReaderCount(r io.Reader, cfg stream.Config) (int64, error) {
	var count int64
	err := TDFAComplexURL{}.FindReader(r, cfg, func(_ stream.Match[*TDFAComplexURLBytesResult]) bool {
		count++
		return true
	})
	return count, err
}

// FindReaderFirst returns the first match, or nil if none found.
// The returned result is a copy (safe to use after call returns).
func (TDFAComplexURL) FindReaderFirst(r io.Reader, cfg stream.Config) (*TDFAComplexURLBytesResult, int64, error) {
	var result *TDFAComplexURLBytesResult
	var offset int64
	err := TDFAComplexURL{}.FindReader(r, cfg, func(m stream.Match[*TDFAComplexURLBytesResult]) bool {
		// Copy the result since buffer will be reused
		result = TDFAComplexURL{}.copyBytesResult(m.Result)
		offset = m.StreamOffset
		return false
	})
	return result, offset, err
}

// copyBytesResult creates a deep copy of a BytesResult.
// This is needed because the original slices point into the stream buffer.
func (TDFAComplexURL) copyBytesResult(src *TDFAComplexURLBytesResult) *TDFAComplexURLBytesResult {
	if src == nil {
		return nil
	}
	dst := &TDFAComplexURLBytesResult{}
	// Copy Match slice
	dst.Match = append([]byte{}, src.Match...)
	if src.Scheme != nil {
		dst.Scheme = append([]byte{}, src.Scheme...)
	}
	if src.Auth != nil {
		dst.Auth = append([]byte{}, src.Auth...)
	}
	if src.User != nil {
		dst.User = append([]byte{}, src.User...)
	}
	if src.Pass != nil {
		dst.Pass = append([]byte{}, src.Pass...)
	}
	if src.Host != nil {
		dst.Host = append([]byte{}, src.Host...)
	}
	if src.Port != nil {
		dst.Port = append([]byte{}, src.Port...)
	}
	if src.Path != nil {
		dst.Path = append([]byte{}, src.Path...)
	}
	if src.Query != nil {
		dst.Query = append([]byte{}, src.Query...)
	}
	return dst
}

// CaptureByIndex returns the capture group value by its 0-based index.
// Index 0 returns the full match, 1+ returns capture groups.
func (r *TDFAComplexURLResult) CaptureByIndex(idx int) string {
	switch idx {
	case 0:
		return r.Match
	case 1:
		return r.Scheme
	case 2:
		return r.Auth
	case 3:
		return r.User
	case 4:
		return r.Pass
	case 5:
		return r.Host
	case 6:
		return r.Port
	case 7:
		return r.Path
	case 8:
		return r.Query
	default:
		return ""
	}
}

// CaptureByIndex returns the capture group value by its 0-based index.
// Index 0 returns the full match, 1+ returns capture groups.
func (r *TDFAComplexURLBytesResult) CaptureByIndex(idx int) []byte {
	switch idx {
	case 0:
		return r.Match
	case 1:
		return r.Scheme
	case 2:
		return r.Auth
	case 3:
		return r.User
	case 4:
		return r.Pass
	case 5:
		return r.Host
	case 6:
		return r.Port
	case 7:
		return r.Path
	case 8:
		return r.Query
	default:
		return nil
	}
}

// ReplaceAllString replaces all matches in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (TDFAComplexURL) ReplaceAllString(input string, template string) string {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var result strings.Builder
	lastEnd := 0
	var r TDFAComplexURLResult

	remaining := input
	offset := 0

	for {
		match, ok := TDFAComplexURL{}.FindStringReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := strings.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := offset + matchIdx
		matchEnd := matchStart + len(match.Match)

		result.WriteString(input[lastEnd:matchStart])

		for _, seg := range tmpl.Segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result.WriteString(seg.Literal)
			case replace.SegmentFullMatch:
				result.WriteString(match.Match)
			case replace.SegmentCaptureIndex:
				result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
			case replace.SegmentCaptureName:
				switch seg.CaptureName {
				case "scheme":
					result.WriteString(match.Scheme)
				case "auth":
					result.WriteString(match.Auth)
				case "user":
					result.WriteString(match.User)
				case "pass":
					result.WriteString(match.Pass)
				case "host":
					result.WriteString(match.Host)
				case "port":
					result.WriteString(match.Port)
				case "path":
					result.WriteString(match.Path)
				case "query":
					result.WriteString(match.Query)
				}
			}
		}

		lastEnd = matchEnd
		if len(match.Match) > 0 {
			remaining = input[matchEnd:]
			offset = matchEnd
		} else {
			if matchEnd < len(input) {
				remaining = input[matchEnd+1:]
				offset = matchEnd + 1
			} else {
				break
			}
		}
	}

	result.WriteString(input[lastEnd:])
	return result.String()
}

// ReplaceAllBytes replaces all matches in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (TDFAComplexURL) ReplaceAllBytes(input []byte, template string) []byte {
	return TDFAComplexURL{}.ReplaceAllBytesAppend(input, template, nil)
}

// ReplaceAllBytesAppend replaces all matches and appends to buf.
// If buf has sufficient capacity, no allocation occurs.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (TDFAComplexURL) ReplaceAllBytesAppend(input []byte, template string, buf []byte) []byte {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	result := buf[:0]
	lastEnd := 0
	var r TDFAComplexURLBytesResult

	remaining := input
	offset := 0

	for {
		match, ok := TDFAComplexURL{}.FindBytesReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := bytes.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := offset + matchIdx
		matchEnd := matchStart + len(match.Match)

		result = append(result, input[lastEnd:matchStart]...)

		for _, seg := range tmpl.Segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, match.Match...)
			case replace.SegmentCaptureIndex:
				result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
			case replace.SegmentCaptureName:
				switch seg.CaptureName {
				case "scheme":
					result = append(result, match.Scheme...)
				case "auth":
					result = append(result, match.Auth...)
				case "user":
					result = append(result, match.User...)
				case "pass":
					result = append(result, match.Pass...)
				case "host":
					result = append(result, match.Host...)
				case "port":
					result = append(result, match.Port...)
				case "path":
					result = append(result, match.Path...)
				case "query":
					result = append(result, match.Query...)
				}
			}
		}

		lastEnd = matchEnd
		if len(match.Match) > 0 {
			remaining = input[matchEnd:]
			offset = matchEnd
		} else {
			if matchEnd < len(input) {
				remaining = input[matchEnd+1:]
				offset = matchEnd + 1
			} else {
				break
			}
		}
	}

	result = append(result, input[lastEnd:]...)
	return result
}

// ReplaceFirstString replaces only the first match in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (TDFAComplexURL) ReplaceFirstString(input string, template string) string {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var r TDFAComplexURLResult
	match, ok := TDFAComplexURL{}.FindStringReuse(input, &r)
	if !ok {
		return input
	}

	matchIdx := strings.Index(input, match.Match)
	if matchIdx < 0 {
		return input
	}

	var result strings.Builder
	result.WriteString(input[:matchIdx])

	for _, seg := range tmpl.Segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result.WriteString(seg.Literal)
		case replace.SegmentFullMatch:
			result.WriteString(match.Match)
		case replace.SegmentCaptureIndex:
			result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
		case replace.SegmentCaptureName:
			switch seg.CaptureName {
			case "scheme":
				result.WriteString(match.Scheme)
			case "auth":
				result.WriteString(match.Auth)
			case "user":
				result.WriteString(match.User)
			case "pass":
				result.WriteString(match.Pass)
			case "host":
				result.WriteString(match.Host)
			case "port":
				result.WriteString(match.Port)
			case "path":
				result.WriteString(match.Path)
			case "query":
				result.WriteString(match.Query)
			}
		}
	}

	result.WriteString(input[matchIdx+len(match.Match):])
	return result.String()
}

// ReplaceFirstBytes replaces only the first match in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (TDFAComplexURL) ReplaceFirstBytes(input []byte, template string) []byte {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var r TDFAComplexURLBytesResult
	match, ok := TDFAComplexURL{}.FindBytesReuse(input, &r)
	if !ok {
		return append([]byte{}, input...)
	}

	matchIdx := bytes.Index(input, match.Match)
	if matchIdx < 0 {
		return append([]byte{}, input...)
	}

	var result []byte
	result = append(result, input[:matchIdx]...)

	for _, seg := range tmpl.Segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result = append(result, seg.Literal...)
		case replace.SegmentFullMatch:
			result = append(result, match.Match...)
		case replace.SegmentCaptureIndex:
			result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
		case replace.SegmentCaptureName:
			switch seg.CaptureName {
			case "scheme":
				result = append(result, match.Scheme...)
			case "auth":
				result = append(result, match.Auth...)
			case "user":
				result = append(result, match.User...)
			case "pass":
				result = append(result, match.Pass...)
			case "host":
				result = append(result, match.Host...)
			case "port":
				result = append(result, match.Port...)
			case "path":
				result = append(result, match.Path...)
			case "query":
				result = append(result, match.Query...)
			}
		}
	}

	result = append(result, input[matchIdx+len(match.Match):]...)
	return result
}

// TDFAComplexURLReplaceTemplate holds a pre-compiled replace template for the TDFAComplexURL pattern.
// Use CompileReplaceTemplate to create one, then call its Replace methods.
type TDFAComplexURLReplaceTemplate struct {
	original string
	segments []replace.Segment
}

// CompileReplaceTemplate parses and validates a replace template.
// Returns an error if the template syntax is invalid or references non-existent captures.
// The compiled template can be reused for multiple replacements without re-parsing.
//
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (TDFAComplexURL) CompileReplaceTemplate(template string) (*TDFAComplexURLReplaceTemplate, error) {
	tmpl, err := replace.Parse(template)
	if err != nil {
		return nil, err
	}

	captureNames := map[string]int{
		"auth":   2,
		"host":   5,
		"pass":   4,
		"path":   7,
		"port":   6,
		"query":  8,
		"scheme": 1,
		"user":   3,
	}

	resolved, err := tmpl.ValidateAndResolve(captureNames, 8)
	if err != nil {
		return nil, err
	}

	return &TDFAComplexURLReplaceTemplate{
		original: template,
		segments: resolved,
	}, nil
}

// String returns the original template string.
func (t *TDFAComplexURLReplaceTemplate) String() string {
	return t.original
}

// ReplaceAllString replaces all matches in input using this compiled template.
func (t *TDFAComplexURLReplaceTemplate) ReplaceAllString(input string) string {
	var result strings.Builder
	lastEnd := 0
	var r TDFAComplexURLResult

	remaining := input
	offset := 0

	for {
		match, ok := TDFAComplexURL{}.FindStringReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := strings.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		absMatchStart := offset + matchIdx
		absMatchEnd := absMatchStart + len(match.Match)

		result.WriteString(input[lastEnd:absMatchStart])

		for _, seg := range t.segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result.WriteString(seg.Literal)
			case replace.SegmentFullMatch:
				result.WriteString(match.Match)
			case replace.SegmentCaptureIndex:
				result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
			}
		}

		lastEnd = absMatchEnd
		remaining = input[absMatchEnd:]
		offset = absMatchEnd
	}

	result.WriteString(input[lastEnd:])
	return result.String()
}

// ReplaceAllBytes replaces all matches in input using this compiled template.
func (t *TDFAComplexURLReplaceTemplate) ReplaceAllBytes(input []byte) []byte {
	return t.ReplaceAllBytesAppend(input, nil)
}

// ReplaceAllBytesAppend replaces all matches and appends to buf.
// If buf has sufficient capacity, no allocation occurs.
func (t *TDFAComplexURLReplaceTemplate) ReplaceAllBytesAppend(input []byte, buf []byte) []byte {
	result := buf[:0]
	lastEnd := 0
	var r TDFAComplexURLBytesResult

	remaining := input
	offset := 0

	for {
		match, ok := TDFAComplexURL{}.FindBytesReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := bytes.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		absMatchStart := offset + matchIdx
		absMatchEnd := absMatchStart + len(match.Match)

		result = append(result, input[lastEnd:absMatchStart]...)

		for _, seg := range t.segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, match.Match...)
			case replace.SegmentCaptureIndex:
				result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
			}
		}

		lastEnd = absMatchEnd
		remaining = input[absMatchEnd:]
		offset = absMatchEnd
	}

	result = append(result, input[lastEnd:]...)
	return result
}

// ReplaceFirstString replaces only the first match using this compiled template.
func (t *TDFAComplexURLReplaceTemplate) ReplaceFirstString(input string) string {
	var r TDFAComplexURLResult
	match, ok := TDFAComplexURL{}.FindStringReuse(input, &r)
	if !ok {
		return input
	}

	matchIdx := strings.Index(input, match.Match)
	if matchIdx < 0 {
		return input
	}

	var result strings.Builder
	result.WriteString(input[:matchIdx])

	for _, seg := range t.segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result.WriteString(seg.Literal)
		case replace.SegmentFullMatch:
			result.WriteString(match.Match)
		case replace.SegmentCaptureIndex:
			result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
		}
	}

	result.WriteString(input[matchIdx+len(match.Match):])
	return result.String()
}

// ReplaceFirstBytes replaces only the first match using this compiled template.
func (t *TDFAComplexURLReplaceTemplate) ReplaceFirstBytes(input []byte) []byte {
	var r TDFAComplexURLBytesResult
	match, ok := TDFAComplexURL{}.FindBytesReuse(input, &r)
	if !ok {
		return append([]byte{}, input...)
	}

	matchIdx := bytes.Index(input, match.Match)
	if matchIdx < 0 {
		return append([]byte{}, input...)
	}

	var result []byte
	result = append(result, input[:matchIdx]...)

	for _, seg := range t.segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result = append(result, seg.Literal...)
		case replace.SegmentFullMatch:
			result = append(result, match.Match...)
		case replace.SegmentCaptureIndex:
			result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
		}
	}

	result = append(result, input[matchIdx+len(match.Match):]...)
	return result
}

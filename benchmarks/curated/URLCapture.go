package curated

import (
	"bytes"
	"fmt"
	replace "github.com/KromDaniel/regengo/replace"
	stream "github.com/KromDaniel/regengo/stream"
	"io"
	"strings"
	"sync"
)

// Code generated by regengo for pattern: (?P<protocol>https?)://(?P<host>[\w\.-]+)(?::(?P<port>\d+))?(?P<path>/[\w\./]*)?
// DO NOT EDIT.

var uRLCaptureStackPool = sync.Pool{New: func() interface{} {
	stack := make([][2]int, 0, 32)
	return &stack
}}

type URLCapture struct{}

var CompiledURLCapture = URLCapture{}

// MinMatchLen is the minimum number of bytes any match can have.
const URLCaptureMinMatchLen = 8

// MaxMatchLen is the maximum number of bytes any match can have.
// -1 means unbounded (pattern contains * or + quantifiers).
const URLCaptureMaxMatchLen = -1

func (URLCapture) MatchLengthInfo() (minLen, maxLen int) {
	return URLCaptureMinMatchLen, URLCaptureMaxMatchLen
}

func (URLCapture) MatchString(input string) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x10000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := [29]uint64{2: uint64(uint64(0x8)), 3: uint64(uint64(0x10)), 4: uint64(uint64(0x20)), 5: uint64(uint64(0x3c0)), 6: uint64(uint64(0x300)), 9: uint64(uint64(0x400)), 10: uint64(uint64(0x800)), 11: uint64(uint64(0x3000)), 13: uint64(uint64(0x18e1e000)), 16: uint64(uint64(0x60000)), 18: uint64(uint64(0x18dc0000)), 23: uint64(uint64(0x17000000)), 24: uint64(uint64(0x17000000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x68) {
				next |= epsilonClosures[2]
			}
			// State 3
			if current&uint64(uint64(0x8)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[3]
			}
			// State 4
			if current&uint64(uint64(0x10)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[4]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x70) {
				next |= epsilonClosures[5]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x73) {
				next |= epsilonClosures[6]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[9]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[10]
			}
			// State 1
			if current&uint64(uint64(0x800)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[11]
			}
			// State 3
			if current&uint64(uint64(0x2000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[13]
			}
			// State 6
			if current&uint64(uint64(0x10000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[16]
			}
			// State 8
			if current&uint64(uint64(0x40000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[18]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[23]
			}
			// State 4
			if current&uint64(uint64(0x1000000)) != 0 && ((((c >= uint8(0x2e) && c <= uint8(0x39)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[24]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}
func (URLCapture) MatchBytes(input []byte) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x10000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := [29]uint64{2: uint64(uint64(0x8)), 3: uint64(uint64(0x10)), 4: uint64(uint64(0x20)), 5: uint64(uint64(0x3c0)), 6: uint64(uint64(0x300)), 9: uint64(uint64(0x400)), 10: uint64(uint64(0x800)), 11: uint64(uint64(0x3000)), 13: uint64(uint64(0x18e1e000)), 16: uint64(uint64(0x60000)), 18: uint64(uint64(0x18dc0000)), 23: uint64(uint64(0x17000000)), 24: uint64(uint64(0x17000000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x68) {
				next |= epsilonClosures[2]
			}
			// State 3
			if current&uint64(uint64(0x8)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[3]
			}
			// State 4
			if current&uint64(uint64(0x10)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[4]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x70) {
				next |= epsilonClosures[5]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x73) {
				next |= epsilonClosures[6]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[9]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[10]
			}
			// State 1
			if current&uint64(uint64(0x800)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[11]
			}
			// State 3
			if current&uint64(uint64(0x2000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[13]
			}
			// State 6
			if current&uint64(uint64(0x10000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[16]
			}
			// State 8
			if current&uint64(uint64(0x40000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[18]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[23]
			}
			// State 4
			if current&uint64(uint64(0x1000000)) != 0 && ((((c >= uint8(0x2e) && c <= uint8(0x39)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[24]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty string when not matched.

type URLCaptureResult struct {
	Match    string // Full match
	Protocol string
	Host     string
	Port     string
	Path     string
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty slice when not matched.

type URLCaptureBytesResult struct {
	Match    []byte // Full match
	Protocol []byte
	Host     []byte
	Port     []byte
	Path     []byte
}

// TDFA transition table [state][char] -> next state (-1 = no transition)
var transitionsURLCapture = [13][128]int{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, 10, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}

// Tag action counts [state][char] -> number of actions
var tagActionCountURLCapture = [13][128]int{{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // Tag action tags [state][char][actionIdx] -> tag index
var tagActionTagsURLCapture = [13][128][2]int{{{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {2, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {3, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {3, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {4, 0}, {4, 0}, {0, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {4, 0}, {0, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {4, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {5, 8}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {5, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {6, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {7, 8}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}} // Tag action offsets [state][char][actionIdx] -> offset
var tagActionOffsetsURLCapture = [13][128][2]int{{{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {1, 0}, {0, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {0, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {1, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}, {{0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {1, 1}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}, {0, 0}}}

// Accept states array
var acceptStatesURLCapture = [13]bool{false, false, false, false, false, false, false, false, false, true, true, false, true}

// Accept states array (End of Text)
var acceptStatesEOTURLCapture = [13]bool{false, false, false, false, false, false, false, false, false, true, true, false, true}

// Accept action counts [state] -> number of actions
var acceptActionCountURLCapture = [13]int{0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}                             // Accept action tags [state][actionIdx] -> tag index
var acceptActionTagsURLCapture = [13][1]int{{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {5}, {9}, {0}, {7}} // Accept action offsets [state][actionIdx] -> offset
var acceptActionOffsetsURLCapture = [13][1]int{{0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}, {0}}

func (URLCapture) FindStringReuse(input string, r *URLCaptureResult) (*URLCaptureResult, bool) {
	if r == nil {
		r = new(URLCaptureResult)
	}
	ok := URLCapture{}.findStringInternal(input, r)
	if !ok {
		return nil, false
	}
	return r, true
}
func (URLCapture) findStringInternal(input string, r *URLCaptureResult) bool {
	l := len(input)
	// Tag registers for capture positions (pre-allocated)
	var tags [10]int
	// Match tags (pre-allocated outside loop to avoid allocations)
	var matchTags [10]int
	state := 0
	matchEnd := -1
	// Initialize matchTags to -1 (pre-allocated in outer scope)
	for j := range matchTags {
		matchTags[j] = -1
	}

	// Iterate over all possible start positions
	for start := 0; start <= l; start++ {
		// Optimization: fast-forward to next prefix occurrence
		idx := strings.IndexByte(input[start:], uint8(0x68))
		if idx < 0 {
			break
		}
		start += idx

		// Reset tags for this attempt
		for j := range tags {
			tags[j] = -1
		}
		tags[0] = start

		// Choose start state based on position
		if start == 0 {
			state = 0
		} else {
			state = 0
		}

		// Check if start state is accepting (empty match)
		if acceptStatesURLCapture[state] {
			matchEnd = start
			matchTags[0] = tags[0]
			matchTags[1] = tags[1]
			matchTags[2] = tags[2]
			matchTags[3] = tags[3]
			matchTags[4] = tags[4]
			matchTags[5] = tags[5]
			matchTags[6] = tags[6]
			matchTags[7] = tags[7]
			matchTags[8] = tags[8]
			matchTags[9] = tags[9]
		}
		// Check if start state is accepting at EOT
		if start == l && acceptStatesEOTURLCapture[state] {
			matchEnd = start
			matchTags[0] = tags[0]
			matchTags[1] = tags[1]
			matchTags[2] = tags[2]
			matchTags[3] = tags[3]
			matchTags[4] = tags[4]
			matchTags[5] = tags[5]
			matchTags[6] = tags[6]
			matchTags[7] = tags[7]
			matchTags[8] = tags[8]
			matchTags[9] = tags[9]
		}

		for i := start; i < l; i++ {
			c := input[i]
			if c >= 128 {
				break
			}

			// Look up transition (array-based for speed)
			nextState := transitionsURLCapture[state][c]
			if nextState < 0 {
				break
			}

			// Apply tag actions (array-based, zero allocations)
			for a := 0; a < tagActionCountURLCapture[state][c]; a++ {
				tags[tagActionTagsURLCapture[state][c][a]] = i + 1 - tagActionOffsetsURLCapture[state][c][a]
			}

			state = nextState
			if acceptStatesURLCapture[state] {
				for a := 0; a < acceptActionCountURLCapture[state]; a++ {
					tags[acceptActionTagsURLCapture[state][a]] = i + 1 - acceptActionOffsetsURLCapture[state][a]
				}
				matchEnd = i + 1
				matchTags[0] = tags[0]
				matchTags[1] = tags[1]
				matchTags[2] = tags[2]
				matchTags[3] = tags[3]
				matchTags[4] = tags[4]
				matchTags[5] = tags[5]
				matchTags[6] = tags[6]
				matchTags[7] = tags[7]
				matchTags[8] = tags[8]
				matchTags[9] = tags[9]
			}
			if i == l-1 && acceptStatesEOTURLCapture[state] {
				for a := 0; a < acceptActionCountURLCapture[state]; a++ {
					tags[acceptActionTagsURLCapture[state][a]] = i + 1 - acceptActionOffsetsURLCapture[state][a]
				}
				matchEnd = i + 1
				matchTags[0] = tags[0]
				matchTags[1] = tags[1]
				matchTags[2] = tags[2]
				matchTags[3] = tags[3]
				matchTags[4] = tags[4]
				matchTags[5] = tags[5]
				matchTags[6] = tags[6]
				matchTags[7] = tags[7]
				matchTags[8] = tags[8]
				matchTags[9] = tags[9]
			}
		}

		// If we found a match, return it
		if matchEnd >= 0 {
			matchTags[1] = matchEnd
			if matchTags[0] >= 0 {
				r.Match = input[matchTags[0]:matchTags[1]]
			}
			if matchTags[2] >= 0 {
				if matchTags[3] < 0 {
					matchTags[3] = matchTags[1]
				}
				r.Protocol = input[matchTags[2]:matchTags[3]]
			}
			if matchTags[4] >= 0 {
				if matchTags[5] < 0 {
					matchTags[5] = matchTags[1]
				}
				r.Host = input[matchTags[4]:matchTags[5]]
			}
			if matchTags[6] >= 0 {
				if matchTags[7] < 0 {
					matchTags[7] = matchTags[1]
				}
				r.Port = input[matchTags[6]:matchTags[7]]
			}
			if matchTags[8] >= 0 {
				if matchTags[9] < 0 {
					matchTags[9] = matchTags[1]
				}
				r.Path = input[matchTags[8]:matchTags[9]]
			}
			return true
		}
	}
	return false
}
func (URLCapture) FindString(input string) (*URLCaptureResult, bool) {
	return URLCapture{}.FindStringReuse(input, nil)
}
func (URLCapture) FindBytesReuse(input []byte, r *URLCaptureBytesResult) (*URLCaptureBytesResult, bool) {
	if r == nil {
		r = new(URLCaptureBytesResult)
	}
	ok := URLCapture{}.findBytesInternal(input, r)
	if !ok {
		return nil, false
	}
	return r, true
}
func (URLCapture) findBytesInternal(input []byte, r *URLCaptureBytesResult) bool {
	l := len(input)
	// Tag registers for capture positions (pre-allocated)
	var tags [10]int
	// Match tags (pre-allocated outside loop to avoid allocations)
	var matchTags [10]int
	state := 0
	matchEnd := -1
	// Initialize matchTags to -1 (pre-allocated in outer scope)
	for j := range matchTags {
		matchTags[j] = -1
	}

	// Iterate over all possible start positions
	for start := 0; start <= l; start++ {
		// Optimization: fast-forward to next prefix occurrence
		idx := bytes.IndexByte(input[start:], uint8(0x68))
		if idx < 0 {
			break
		}
		start += idx

		// Reset tags for this attempt
		for j := range tags {
			tags[j] = -1
		}
		tags[0] = start

		// Choose start state based on position
		if start == 0 {
			state = 0
		} else {
			state = 0
		}

		// Check if start state is accepting (empty match)
		if acceptStatesURLCapture[state] {
			matchEnd = start
			matchTags[0] = tags[0]
			matchTags[1] = tags[1]
			matchTags[2] = tags[2]
			matchTags[3] = tags[3]
			matchTags[4] = tags[4]
			matchTags[5] = tags[5]
			matchTags[6] = tags[6]
			matchTags[7] = tags[7]
			matchTags[8] = tags[8]
			matchTags[9] = tags[9]
		}
		// Check if start state is accepting at EOT
		if start == l && acceptStatesEOTURLCapture[state] {
			matchEnd = start
			matchTags[0] = tags[0]
			matchTags[1] = tags[1]
			matchTags[2] = tags[2]
			matchTags[3] = tags[3]
			matchTags[4] = tags[4]
			matchTags[5] = tags[5]
			matchTags[6] = tags[6]
			matchTags[7] = tags[7]
			matchTags[8] = tags[8]
			matchTags[9] = tags[9]
		}

		for i := start; i < l; i++ {
			c := input[i]
			if c >= 128 {
				break
			}

			// Look up transition (array-based for speed)
			nextState := transitionsURLCapture[state][c]
			if nextState < 0 {
				break
			}

			// Apply tag actions (array-based, zero allocations)
			for a := 0; a < tagActionCountURLCapture[state][c]; a++ {
				tags[tagActionTagsURLCapture[state][c][a]] = i + 1 - tagActionOffsetsURLCapture[state][c][a]
			}

			state = nextState
			if acceptStatesURLCapture[state] {
				for a := 0; a < acceptActionCountURLCapture[state]; a++ {
					tags[acceptActionTagsURLCapture[state][a]] = i + 1 - acceptActionOffsetsURLCapture[state][a]
				}
				matchEnd = i + 1
				matchTags[0] = tags[0]
				matchTags[1] = tags[1]
				matchTags[2] = tags[2]
				matchTags[3] = tags[3]
				matchTags[4] = tags[4]
				matchTags[5] = tags[5]
				matchTags[6] = tags[6]
				matchTags[7] = tags[7]
				matchTags[8] = tags[8]
				matchTags[9] = tags[9]
			}
			if i == l-1 && acceptStatesEOTURLCapture[state] {
				for a := 0; a < acceptActionCountURLCapture[state]; a++ {
					tags[acceptActionTagsURLCapture[state][a]] = i + 1 - acceptActionOffsetsURLCapture[state][a]
				}
				matchEnd = i + 1
				matchTags[0] = tags[0]
				matchTags[1] = tags[1]
				matchTags[2] = tags[2]
				matchTags[3] = tags[3]
				matchTags[4] = tags[4]
				matchTags[5] = tags[5]
				matchTags[6] = tags[6]
				matchTags[7] = tags[7]
				matchTags[8] = tags[8]
				matchTags[9] = tags[9]
			}
		}

		// If we found a match, return it
		if matchEnd >= 0 {
			matchTags[1] = matchEnd
			if matchTags[0] >= 0 {
				r.Match = input[matchTags[0]:matchTags[1]]
			}
			if matchTags[2] >= 0 {
				if matchTags[3] < 0 {
					matchTags[3] = matchTags[1]
				}
				r.Protocol = input[matchTags[2]:matchTags[3]]
			}
			if matchTags[4] >= 0 {
				if matchTags[5] < 0 {
					matchTags[5] = matchTags[1]
				}
				r.Host = input[matchTags[4]:matchTags[5]]
			}
			if matchTags[6] >= 0 {
				if matchTags[7] < 0 {
					matchTags[7] = matchTags[1]
				}
				r.Port = input[matchTags[6]:matchTags[7]]
			}
			if matchTags[8] >= 0 {
				if matchTags[9] < 0 {
					matchTags[9] = matchTags[1]
				}
				r.Path = input[matchTags[8]:matchTags[9]]
			}
			return true
		}
	}
	return false
}
func (URLCapture) FindBytes(input []byte) (*URLCaptureBytesResult, bool) {
	return URLCapture{}.FindBytesReuse(input, nil)
}
func (URLCapture) FindAllStringAppend(input string, n int, s []*URLCaptureResult) []*URLCaptureResult {
	if n == 0 {
		return s
	}
	results := s
	offset := 0
	for offset < len(input) {
		result, ok := URLCapture{}.FindString(input[offset:])
		if !ok {
			break
		}
		results = append(results, result)
		if n > 0 && len(results) >= n {
			break
		}
		// Move past this match
		matchLen := len(result.Match)
		if matchLen > 0 {
			offset += matchLen
		} else {
			offset++
		}
	}
	return results
}
func (URLCapture) FindAllString(input string, n int) []*URLCaptureResult {
	return URLCapture{}.FindAllStringAppend(input, n, nil)
}
func (URLCapture) FindAllBytesAppend(input []byte, n int, s []*URLCaptureBytesResult) []*URLCaptureBytesResult {
	if n == 0 {
		return s
	}
	results := s
	offset := 0
	for offset < len(input) {
		result, ok := URLCapture{}.FindBytes(input[offset:])
		if !ok {
			break
		}
		results = append(results, result)
		if n > 0 && len(results) >= n {
			break
		}
		// Move past this match
		matchLen := len(result.Match)
		if matchLen > 0 {
			offset += matchLen
		} else {
			offset++
		}
	}
	return results
}
func (URLCapture) FindAllBytes(input []byte, n int) []*URLCaptureBytesResult {
	return URLCapture{}.FindAllBytesAppend(input, n, nil)
}

// DefaultMaxLeftover returns the recommended MaxLeftover value for streaming.
// For bounded patterns, this is 10 * MaxMatchLen.
// For unbounded patterns, this returns 1MB as a safety limit.
func (URLCapture) DefaultMaxLeftover() int {
	return 1048576
}

// FindReader streams matches from an io.Reader.
//
// The onMatch callback is called for each match found. Return false to stop
// processing early. The StreamMatch.Result points into an internal buffer
// and is only valid during the callback - copy if needed.
//
// Returns nil on success (including early termination via callback).
// Returns error on read failure.
func (URLCapture) FindReader(r io.Reader, cfg stream.Config, onMatch func(stream.Match[*URLCaptureBytesResult]) bool) error {
	if err := cfg.Validate(65536); err != nil {
		return err
	}
	cfg = cfg.ApplyDefaults(65536, 1048576)

	buf := make([]byte, cfg.BufferSize)
	leftover := 0
	streamOffset := int64(0)
	chunkIndex := 0

	reuseResult := &URLCaptureBytesResult{}

	for {
		n, err := r.Read(buf[leftover:])
		if n == 0 && err != nil {
			if err == io.EOF {
				// Process any remaining data in leftover
				if leftover > 0 {
					chunk := buf[:leftover]
					searchPos := 0
					for searchPos < len(chunk) {
						result, ok := URLCapture{}.FindBytesReuse(chunk[searchPos:], reuseResult)
						if !ok {
							break
						}
						matchIdx := bytes.Index(chunk[searchPos:], result.Match)
						if matchIdx < 0 {
							break
						}
						matchStart := searchPos + matchIdx

						m := stream.Match[*URLCaptureBytesResult]{
							ChunkIndex:   chunkIndex,
							Result:       result,
							StreamOffset: streamOffset + int64(matchStart),
						}
						if !onMatch(m) {
							return nil
						}
						if len(result.Match) > 0 {
							searchPos = matchStart + len(result.Match)
						} else {
							searchPos++
						}
					}
				}
				return nil
			}
			return err
		}

		dataLen := leftover + n
		chunk := buf[:dataLen]
		isFull := n == cfg.BufferSize-leftover

		searchPos := 0
		committed := 0
		for searchPos < len(chunk) {
			result, ok := URLCapture{}.FindBytesReuse(chunk[searchPos:], reuseResult)
			if !ok {
				break
			}
			matchIdx := bytes.Index(chunk[searchPos:], result.Match)
			if matchIdx < 0 {
				break
			}
			matchStart := searchPos + matchIdx
			matchEnd := matchStart + len(result.Match)

			if isFull && matchEnd > dataLen-cfg.MaxLeftover {
				// Match too close to boundary, defer to next chunk
				break
			}

			m := stream.Match[*URLCaptureBytesResult]{
				ChunkIndex:   chunkIndex,
				Result:       result,
				StreamOffset: streamOffset + int64(matchStart),
			}
			if !onMatch(m) {
				return nil
			}
			committed = matchEnd
			if len(result.Match) > 0 {
				searchPos = matchEnd
			} else {
				searchPos++
			}
		}

		// Prepare leftover for next iteration
		if isFull {
			// Buffer was full, need to keep leftover
			keepFrom := dataLen - cfg.MaxLeftover
			if keepFrom < committed {
				keepFrom = committed
			}
			leftover = dataLen - keepFrom
			streamOffset += int64(keepFrom)
			copy(buf[:leftover], buf[keepFrom:dataLen])
		} else {
			// Reached EOF or short read, no more data
			leftover = 0
		}
		chunkIndex++
		if err == io.EOF {
			return nil
		}
	}
}

// FindReaderCount counts matches without allocating result structs.
// More efficient when you only need the count.
func (URLCapture) FindReaderCount(r io.Reader, cfg stream.Config) (int64, error) {
	var count int64
	err := URLCapture{}.FindReader(r, cfg, func(_ stream.Match[*URLCaptureBytesResult]) bool {
		count++
		return true
	})
	return count, err
}

// FindReaderFirst returns the first match, or nil if none found.
// The returned result is a copy (safe to use after call returns).
func (URLCapture) FindReaderFirst(r io.Reader, cfg stream.Config) (*URLCaptureBytesResult, int64, error) {
	var result *URLCaptureBytesResult
	var offset int64
	err := URLCapture{}.FindReader(r, cfg, func(m stream.Match[*URLCaptureBytesResult]) bool {
		// Copy the result since buffer will be reused
		result = URLCapture{}.copyBytesResult(m.Result)
		offset = m.StreamOffset
		return false
	})
	return result, offset, err
}

// copyBytesResult creates a deep copy of a BytesResult.
// This is needed because the original slices point into the stream buffer.
func (URLCapture) copyBytesResult(src *URLCaptureBytesResult) *URLCaptureBytesResult {
	if src == nil {
		return nil
	}
	dst := &URLCaptureBytesResult{}
	// Copy Match slice
	dst.Match = append([]byte{}, src.Match...)
	if src.Protocol != nil {
		dst.Protocol = append([]byte{}, src.Protocol...)
	}
	if src.Host != nil {
		dst.Host = append([]byte{}, src.Host...)
	}
	if src.Port != nil {
		dst.Port = append([]byte{}, src.Port...)
	}
	if src.Path != nil {
		dst.Path = append([]byte{}, src.Path...)
	}
	return dst
}

// CaptureByIndex returns the capture group value by its 0-based index.
// Index 0 returns the full match, 1+ returns capture groups.
func (r *URLCaptureResult) CaptureByIndex(idx int) string {
	switch idx {
	case 0:
		return r.Match
	case 1:
		return r.Protocol
	case 2:
		return r.Host
	case 3:
		return r.Port
	case 4:
		return r.Path
	default:
		return ""
	}
}

// CaptureByIndex returns the capture group value by its 0-based index.
// Index 0 returns the full match, 1+ returns capture groups.
func (r *URLCaptureBytesResult) CaptureByIndex(idx int) []byte {
	switch idx {
	case 0:
		return r.Match
	case 1:
		return r.Protocol
	case 2:
		return r.Host
	case 3:
		return r.Port
	case 4:
		return r.Path
	default:
		return nil
	}
}

// ReplaceAllString replaces all matches in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (URLCapture) ReplaceAllString(input string, template string) string {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var result strings.Builder
	lastEnd := 0
	var r URLCaptureResult

	remaining := input
	offset := 0

	for {
		match, ok := URLCapture{}.FindStringReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := strings.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := offset + matchIdx
		matchEnd := matchStart + len(match.Match)

		result.WriteString(input[lastEnd:matchStart])

		for _, seg := range tmpl.Segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result.WriteString(seg.Literal)
			case replace.SegmentFullMatch:
				result.WriteString(match.Match)
			case replace.SegmentCaptureIndex:
				result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
			case replace.SegmentCaptureName:
				switch seg.CaptureName {
				case "protocol":
					result.WriteString(match.Protocol)
				case "host":
					result.WriteString(match.Host)
				case "port":
					result.WriteString(match.Port)
				case "path":
					result.WriteString(match.Path)
				}
			}
		}

		lastEnd = matchEnd
		if len(match.Match) > 0 {
			remaining = input[matchEnd:]
			offset = matchEnd
		} else {
			if matchEnd < len(input) {
				remaining = input[matchEnd+1:]
				offset = matchEnd + 1
			} else {
				break
			}
		}
	}

	result.WriteString(input[lastEnd:])
	return result.String()
}

// ReplaceAllBytes replaces all matches in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (URLCapture) ReplaceAllBytes(input []byte, template string) []byte {
	return URLCapture{}.ReplaceAllBytesAppend(input, template, nil)
}

// ReplaceAllBytesAppend replaces all matches and appends to buf.
// If buf has sufficient capacity, no allocation occurs.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (URLCapture) ReplaceAllBytesAppend(input []byte, template string, buf []byte) []byte {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	result := buf[:0]
	lastEnd := 0
	var r URLCaptureBytesResult

	remaining := input
	offset := 0

	for {
		match, ok := URLCapture{}.FindBytesReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := bytes.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := offset + matchIdx
		matchEnd := matchStart + len(match.Match)

		result = append(result, input[lastEnd:matchStart]...)

		for _, seg := range tmpl.Segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, match.Match...)
			case replace.SegmentCaptureIndex:
				result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
			case replace.SegmentCaptureName:
				switch seg.CaptureName {
				case "protocol":
					result = append(result, match.Protocol...)
				case "host":
					result = append(result, match.Host...)
				case "port":
					result = append(result, match.Port...)
				case "path":
					result = append(result, match.Path...)
				}
			}
		}

		lastEnd = matchEnd
		if len(match.Match) > 0 {
			remaining = input[matchEnd:]
			offset = matchEnd
		} else {
			if matchEnd < len(input) {
				remaining = input[matchEnd+1:]
				offset = matchEnd + 1
			} else {
				break
			}
		}
	}

	result = append(result, input[lastEnd:]...)
	return result
}

// ReplaceFirstString replaces only the first match in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (URLCapture) ReplaceFirstString(input string, template string) string {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var r URLCaptureResult
	match, ok := URLCapture{}.FindStringReuse(input, &r)
	if !ok {
		return input
	}

	matchIdx := strings.Index(input, match.Match)
	if matchIdx < 0 {
		return input
	}

	var result strings.Builder
	result.WriteString(input[:matchIdx])

	for _, seg := range tmpl.Segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result.WriteString(seg.Literal)
		case replace.SegmentFullMatch:
			result.WriteString(match.Match)
		case replace.SegmentCaptureIndex:
			result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
		case replace.SegmentCaptureName:
			switch seg.CaptureName {
			case "protocol":
				result.WriteString(match.Protocol)
			case "host":
				result.WriteString(match.Host)
			case "port":
				result.WriteString(match.Port)
			case "path":
				result.WriteString(match.Path)
			}
		}
	}

	result.WriteString(input[matchIdx+len(match.Match):])
	return result.String()
}

// ReplaceFirstBytes replaces only the first match in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (URLCapture) ReplaceFirstBytes(input []byte, template string) []byte {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var r URLCaptureBytesResult
	match, ok := URLCapture{}.FindBytesReuse(input, &r)
	if !ok {
		return append([]byte{}, input...)
	}

	matchIdx := bytes.Index(input, match.Match)
	if matchIdx < 0 {
		return append([]byte{}, input...)
	}

	var result []byte
	result = append(result, input[:matchIdx]...)

	for _, seg := range tmpl.Segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result = append(result, seg.Literal...)
		case replace.SegmentFullMatch:
			result = append(result, match.Match...)
		case replace.SegmentCaptureIndex:
			result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
		case replace.SegmentCaptureName:
			switch seg.CaptureName {
			case "protocol":
				result = append(result, match.Protocol...)
			case "host":
				result = append(result, match.Host...)
			case "port":
				result = append(result, match.Port...)
			case "path":
				result = append(result, match.Path...)
			}
		}
	}

	result = append(result, input[matchIdx+len(match.Match):]...)
	return result
}

// URLCaptureReplaceTemplate holds a pre-compiled replace template for the URLCapture pattern.
// Use CompileReplaceTemplate to create one, then call its Replace methods.
type URLCaptureReplaceTemplate struct {
	original string
	segments []replace.Segment
}

// CompileReplaceTemplate parses and validates a replace template.
// Returns an error if the template syntax is invalid or references non-existent captures.
// The compiled template can be reused for multiple replacements without re-parsing.
//
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (URLCapture) CompileReplaceTemplate(template string) (*URLCaptureReplaceTemplate, error) {
	tmpl, err := replace.Parse(template)
	if err != nil {
		return nil, err
	}

	captureNames := map[string]int{
		"host":     2,
		"path":     4,
		"port":     3,
		"protocol": 1,
	}

	resolved, err := tmpl.ValidateAndResolve(captureNames, 4)
	if err != nil {
		return nil, err
	}

	return &URLCaptureReplaceTemplate{
		original: template,
		segments: resolved,
	}, nil
}

// String returns the original template string.
func (t *URLCaptureReplaceTemplate) String() string {
	return t.original
}

// ReplaceAllString replaces all matches in input using this compiled template.
func (t *URLCaptureReplaceTemplate) ReplaceAllString(input string) string {
	var result strings.Builder
	lastEnd := 0
	var r URLCaptureResult

	remaining := input
	offset := 0

	for {
		match, ok := URLCapture{}.FindStringReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := strings.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		absMatchStart := offset + matchIdx
		absMatchEnd := absMatchStart + len(match.Match)

		result.WriteString(input[lastEnd:absMatchStart])

		for _, seg := range t.segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result.WriteString(seg.Literal)
			case replace.SegmentFullMatch:
				result.WriteString(match.Match)
			case replace.SegmentCaptureIndex:
				result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
			}
		}

		lastEnd = absMatchEnd
		remaining = input[absMatchEnd:]
		offset = absMatchEnd
	}

	result.WriteString(input[lastEnd:])
	return result.String()
}

// ReplaceAllBytes replaces all matches in input using this compiled template.
func (t *URLCaptureReplaceTemplate) ReplaceAllBytes(input []byte) []byte {
	return t.ReplaceAllBytesAppend(input, nil)
}

// ReplaceAllBytesAppend replaces all matches and appends to buf.
// If buf has sufficient capacity, no allocation occurs.
func (t *URLCaptureReplaceTemplate) ReplaceAllBytesAppend(input []byte, buf []byte) []byte {
	result := buf[:0]
	lastEnd := 0
	var r URLCaptureBytesResult

	remaining := input
	offset := 0

	for {
		match, ok := URLCapture{}.FindBytesReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := bytes.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		absMatchStart := offset + matchIdx
		absMatchEnd := absMatchStart + len(match.Match)

		result = append(result, input[lastEnd:absMatchStart]...)

		for _, seg := range t.segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, match.Match...)
			case replace.SegmentCaptureIndex:
				result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
			}
		}

		lastEnd = absMatchEnd
		remaining = input[absMatchEnd:]
		offset = absMatchEnd
	}

	result = append(result, input[lastEnd:]...)
	return result
}

// ReplaceFirstString replaces only the first match using this compiled template.
func (t *URLCaptureReplaceTemplate) ReplaceFirstString(input string) string {
	var r URLCaptureResult
	match, ok := URLCapture{}.FindStringReuse(input, &r)
	if !ok {
		return input
	}

	matchIdx := strings.Index(input, match.Match)
	if matchIdx < 0 {
		return input
	}

	var result strings.Builder
	result.WriteString(input[:matchIdx])

	for _, seg := range t.segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result.WriteString(seg.Literal)
		case replace.SegmentFullMatch:
			result.WriteString(match.Match)
		case replace.SegmentCaptureIndex:
			result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
		}
	}

	result.WriteString(input[matchIdx+len(match.Match):])
	return result.String()
}

// ReplaceFirstBytes replaces only the first match using this compiled template.
func (t *URLCaptureReplaceTemplate) ReplaceFirstBytes(input []byte) []byte {
	var r URLCaptureBytesResult
	match, ok := URLCapture{}.FindBytesReuse(input, &r)
	if !ok {
		return append([]byte{}, input...)
	}

	matchIdx := bytes.Index(input, match.Match)
	if matchIdx < 0 {
		return append([]byte{}, input...)
	}

	var result []byte
	result = append(result, input[:matchIdx]...)

	for _, seg := range t.segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result = append(result, seg.Literal...)
		case replace.SegmentFullMatch:
			result = append(result, match.Match...)
		case replace.SegmentCaptureIndex:
			result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
		}
	}

	result = append(result, input[matchIdx+len(match.Match):]...)
	return result
}

package curated

import (
	"bytes"
	"fmt"
	replace "github.com/KromDaniel/regengo/replace"
	stream "github.com/KromDaniel/regengo/stream"
	"io"
	"strings"
)

// Code generated by regengo for pattern: (?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})
// DO NOT EDIT.

type MultiDate struct{}

var CompiledMultiDate = MultiDate{}

// MinMatchLen is the minimum number of bytes any match can have.
const MultiDateMinMatchLen = 10

// MaxMatchLen is the maximum number of bytes any match can have.
// -1 means unbounded (pattern contains * or + quantifiers).
const MultiDateMaxMatchLen = 10

func (MultiDate) MatchLengthInfo() (minLen, maxLen int) {
	return MultiDateMinMatchLen, MultiDateMaxMatchLen
}

func (MultiDate) MatchString(input string) bool {
	l := len(input)
	offset := 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		nextInstruction = 1
		offset++
		goto StepSelect
	}
	return false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		goto Ins9
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		goto Ins12
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		goto Ins14
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		goto Ins17
	}
Ins17:
	{
		return true
	}
}
func (MultiDate) MatchBytes(input []byte) bool {
	l := len(input)
	offset := 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		nextInstruction = 1
		offset++
		goto StepSelect
	}
	return false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		goto Ins9
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		goto Ins12
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		goto Ins14
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		goto Ins17
	}
Ins17:
	{
		return true
	}
}

type MultiDateResult struct {
	Match string // Full match
	Year  string
	Month string
	Day   string
}

type MultiDateBytesResult struct {
	Match []byte // Full match
	Year  []byte
	Month []byte
	Day   []byte
}

func (MultiDate) FindStringReuse(input string, r *MultiDateResult) (*MultiDateResult, bool) {
	l := len(input)
	offset := 0
	var captures [8]int
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		offset++
		for i := range captures {
			captures[i] = 0
		}
		captures[0] = offset
		nextInstruction = 1
		goto StepSelect
	}
	return nil, false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[3] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		captures[4] = offset
		nextInstruction = 9
		goto StepSelect
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[5] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		captures[6] = offset
		nextInstruction = 14
		goto StepSelect
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		captures[7] = offset
		nextInstruction = 17
		goto StepSelect
	}
Ins17:
	{
		captures[1] = offset
		if r == nil {
			r = &MultiDateResult{}
		}
		r.Match = string(input[captures[0]:captures[1]])
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.Year = string(input[captures[2]:captures[3]])
		} else {
			r.Year = ""
		}
		if captures[4] <= captures[5] && captures[5] <= len(input) {
			r.Month = string(input[captures[4]:captures[5]])
		} else {
			r.Month = ""
		}
		if captures[6] <= captures[7] && captures[7] <= len(input) {
			r.Day = string(input[captures[6]:captures[7]])
		} else {
			r.Day = ""
		}
		return r, true
	}
}
func (recv MultiDate) FindString(input string) (*MultiDateResult, bool) {
	return recv.FindStringReuse(input, nil)
}
func (MultiDate) FindAllStringAppend(input string, n int, s []*MultiDateResult) []*MultiDateResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [8]int
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		searchStart++
		continue
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		case 16:
			goto Ins16
		case 17:
			goto Ins17
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins4
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captures[3] = offset
			nextInstruction = 7
			goto StepSelect
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			captures[4] = offset
			nextInstruction = 9
			goto StepSelect
		}
	Ins9:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins10
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			captures[5] = offset
			nextInstruction = 12
			goto StepSelect
		}
	Ins12:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins13
		}
	Ins13:
		{
			captures[6] = offset
			nextInstruction = 14
			goto StepSelect
		}
	Ins14:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins15
		}
	Ins15:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins16
		}
	Ins16:
		{
			captures[7] = offset
			nextInstruction = 17
			goto StepSelect
		}
	Ins17:
		{
			captures[1] = offset
			var item *MultiDateResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &MultiDateResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &MultiDateResult{}
				result = append(result, item)
			}
			item.Match = string(input[captures[0]:captures[1]])
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.Year = string(input[captures[2]:captures[3]])
			} else {
				item.Year = ""
			}
			if captures[4] <= captures[5] && captures[5] <= len(input) {
				item.Month = string(input[captures[4]:captures[5]])
			} else {
				item.Month = ""
			}
			if captures[6] <= captures[7] && captures[7] <= len(input) {
				item.Day = string(input[captures[6]:captures[7]])
			} else {
				item.Day = ""
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r MultiDate) FindAllString(input string, n int) []*MultiDateResult {
	return r.FindAllStringAppend(input, n, nil)
}
func (MultiDate) FindBytesReuse(input []byte, r *MultiDateBytesResult) (*MultiDateBytesResult, bool) {
	l := len(input)
	offset := 0
	var captures [8]int
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		offset++
		for i := range captures {
			captures[i] = 0
		}
		captures[0] = offset
		nextInstruction = 1
		goto StepSelect
	}
	return nil, false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[3] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		captures[4] = offset
		nextInstruction = 9
		goto StepSelect
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[5] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		captures[6] = offset
		nextInstruction = 14
		goto StepSelect
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		captures[7] = offset
		nextInstruction = 17
		goto StepSelect
	}
Ins17:
	{
		captures[1] = offset
		if r == nil {
			r = &MultiDateBytesResult{}
		}
		r.Match = input[captures[0]:captures[1]]
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.Year = input[captures[2]:captures[3]]
		} else {
			r.Year = nil
		}
		if captures[4] <= captures[5] && captures[5] <= len(input) {
			r.Month = input[captures[4]:captures[5]]
		} else {
			r.Month = nil
		}
		if captures[6] <= captures[7] && captures[7] <= len(input) {
			r.Day = input[captures[6]:captures[7]]
		} else {
			r.Day = nil
		}
		return r, true
	}
}
func (recv MultiDate) FindBytes(input []byte) (*MultiDateBytesResult, bool) {
	return recv.FindBytesReuse(input, nil)
}
func (MultiDate) FindAllBytesAppend(input []byte, n int, s []*MultiDateBytesResult) []*MultiDateBytesResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [8]int
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		searchStart++
		continue
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		case 16:
			goto Ins16
		case 17:
			goto Ins17
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins4
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captures[3] = offset
			nextInstruction = 7
			goto StepSelect
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			captures[4] = offset
			nextInstruction = 9
			goto StepSelect
		}
	Ins9:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins10
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			captures[5] = offset
			nextInstruction = 12
			goto StepSelect
		}
	Ins12:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins13
		}
	Ins13:
		{
			captures[6] = offset
			nextInstruction = 14
			goto StepSelect
		}
	Ins14:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins15
		}
	Ins15:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins16
		}
	Ins16:
		{
			captures[7] = offset
			nextInstruction = 17
			goto StepSelect
		}
	Ins17:
		{
			captures[1] = offset
			var item *MultiDateBytesResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &MultiDateBytesResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &MultiDateBytesResult{}
				result = append(result, item)
			}
			item.Match = input[captures[0]:captures[1]]
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.Year = input[captures[2]:captures[3]]
			} else {
				item.Year = nil
			}
			if captures[4] <= captures[5] && captures[5] <= len(input) {
				item.Month = input[captures[4]:captures[5]]
			} else {
				item.Month = nil
			}
			if captures[6] <= captures[7] && captures[7] <= len(input) {
				item.Day = input[captures[6]:captures[7]]
			} else {
				item.Day = nil
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r MultiDate) FindAllBytes(input []byte, n int) []*MultiDateBytesResult {
	return r.FindAllBytesAppend(input, n, nil)
}

// DefaultMaxLeftover returns the recommended MaxLeftover value for streaming.
// For bounded patterns, this is 10 * MaxMatchLen.
// For unbounded patterns, this returns 1MB as a safety limit.
func (MultiDate) DefaultMaxLeftover() int {
	return 1024
}

// FindReader streams matches from an io.Reader.
//
// The onMatch callback is called for each match found. Return false to stop
// processing early. The StreamMatch.Result points into an internal buffer
// and is only valid during the callback - copy if needed.
//
// Returns nil on success (including early termination via callback).
// Returns error on read failure.
func (MultiDate) FindReader(r io.Reader, cfg stream.Config, onMatch func(stream.Match[*MultiDateBytesResult]) bool) error {
	if err := cfg.Validate(65536); err != nil {
		return err
	}
	cfg = cfg.ApplyDefaults(65536, 1024)

	buf := make([]byte, cfg.BufferSize)
	leftover := 0
	streamOffset := int64(0)
	chunkIndex := 0

	reuseResult := &MultiDateBytesResult{}

	for {
		n, err := r.Read(buf[leftover:])
		if n == 0 && err != nil {
			if err == io.EOF {
				// Process any remaining data in leftover
				if leftover > 0 {
					chunk := buf[:leftover]
					searchPos := 0
					for searchPos < len(chunk) {
						result, ok := MultiDate{}.FindBytesReuse(chunk[searchPos:], reuseResult)
						if !ok {
							break
						}
						matchIdx := bytes.Index(chunk[searchPos:], result.Match)
						if matchIdx < 0 {
							break
						}
						matchStart := searchPos + matchIdx

						m := stream.Match[*MultiDateBytesResult]{
							ChunkIndex:   chunkIndex,
							Result:       result,
							StreamOffset: streamOffset + int64(matchStart),
						}
						if !onMatch(m) {
							return nil
						}
						if len(result.Match) > 0 {
							searchPos = matchStart + len(result.Match)
						} else {
							searchPos++
						}
					}
				}
				return nil
			}
			return err
		}

		dataLen := leftover + n
		chunk := buf[:dataLen]
		isFull := n == cfg.BufferSize-leftover

		searchPos := 0
		committed := 0
		for searchPos < len(chunk) {
			result, ok := MultiDate{}.FindBytesReuse(chunk[searchPos:], reuseResult)
			if !ok {
				break
			}
			matchIdx := bytes.Index(chunk[searchPos:], result.Match)
			if matchIdx < 0 {
				break
			}
			matchStart := searchPos + matchIdx
			matchEnd := matchStart + len(result.Match)

			if isFull && matchEnd > dataLen-cfg.MaxLeftover {
				// Match too close to boundary, defer to next chunk
				break
			}

			m := stream.Match[*MultiDateBytesResult]{
				ChunkIndex:   chunkIndex,
				Result:       result,
				StreamOffset: streamOffset + int64(matchStart),
			}
			if !onMatch(m) {
				return nil
			}
			committed = matchEnd
			if len(result.Match) > 0 {
				searchPos = matchEnd
			} else {
				searchPos++
			}
		}

		// Prepare leftover for next iteration
		if isFull {
			// Buffer was full, need to keep leftover
			keepFrom := dataLen - cfg.MaxLeftover
			if keepFrom < committed {
				keepFrom = committed
			}
			leftover = dataLen - keepFrom
			streamOffset += int64(keepFrom)
			copy(buf[:leftover], buf[keepFrom:dataLen])
		} else {
			// Reached EOF or short read, no more data
			leftover = 0
		}
		chunkIndex++
		if err == io.EOF {
			return nil
		}
	}
}

// FindReaderCount counts matches without allocating result structs.
// More efficient when you only need the count.
func (MultiDate) FindReaderCount(r io.Reader, cfg stream.Config) (int64, error) {
	var count int64
	err := MultiDate{}.FindReader(r, cfg, func(_ stream.Match[*MultiDateBytesResult]) bool {
		count++
		return true
	})
	return count, err
}

// FindReaderFirst returns the first match, or nil if none found.
// The returned result is a copy (safe to use after call returns).
func (MultiDate) FindReaderFirst(r io.Reader, cfg stream.Config) (*MultiDateBytesResult, int64, error) {
	var result *MultiDateBytesResult
	var offset int64
	err := MultiDate{}.FindReader(r, cfg, func(m stream.Match[*MultiDateBytesResult]) bool {
		// Copy the result since buffer will be reused
		result = MultiDate{}.copyBytesResult(m.Result)
		offset = m.StreamOffset
		return false
	})
	return result, offset, err
}

// copyBytesResult creates a deep copy of a BytesResult.
// This is needed because the original slices point into the stream buffer.
func (MultiDate) copyBytesResult(src *MultiDateBytesResult) *MultiDateBytesResult {
	if src == nil {
		return nil
	}
	dst := &MultiDateBytesResult{}
	// Copy Match slice
	dst.Match = append([]byte{}, src.Match...)
	if src.Year != nil {
		dst.Year = append([]byte{}, src.Year...)
	}
	if src.Month != nil {
		dst.Month = append([]byte{}, src.Month...)
	}
	if src.Day != nil {
		dst.Day = append([]byte{}, src.Day...)
	}
	return dst
}

// NewTransformReader returns an io.Reader that transforms matches in the input stream.
//
// The onMatch callback is called for each match. Use emit to output replacement bytes.
// If emit is not called, the match is dropped (filter behavior).
// Non-matching segments are automatically passed through to output.
//
// Example usage:
//
//	r := pattern.NewTransformReader(input, stream.DefaultTransformConfig(),
//	    func(m *PatternBytesResult, emit func([]byte)) {
//	        emit([]byte("REDACTED"))
//	    })
//	io.Copy(os.Stdout, r)
func (MultiDate) NewTransformReader(r io.Reader, cfg stream.TransformConfig, onMatch func(match *MultiDateBytesResult, emit func([]byte))) io.Reader {
	if cfg.BufferSize == 0 {
		cfg.BufferSize = 65536
	}
	if cfg.MaxLeftover == 0 {
		cfg.MaxLeftover = 1024
	}

	processor := func(data []byte, isEOF bool, _ stream.TransformFunc, emitOut func([]byte)) int {
		return MultiDate{}.processTransform(data, isEOF, onMatch, emitOut)
	}

	return stream.NewTransformer(r, cfg, processor, func(_ []byte, emit func([]byte)) {})
}

// processTransform processes data for transformation.
func (MultiDate) processTransform(data []byte, isEOF bool, onMatch func(match *MultiDateBytesResult, emit func([]byte)), emitOut func([]byte)) int {
	processed := 0
	reuseResult := &MultiDateBytesResult{}

	for {
		result, ok := MultiDate{}.FindBytesReuse(data[processed:], reuseResult)
		if !ok {
			// No more matches
			if isEOF {
				if processed < len(data) {
					emitOut(data[processed:])
				}
				return len(data)
			}
			// Keep potential partial match data
			safePoint := len(data) - 102
			if safePoint < processed {
				safePoint = processed
			}
			if safePoint > processed {
				emitOut(data[processed:safePoint])
			}
			return safePoint
		}

		matchIdx := bytes.Index(data[processed:], result.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := processed + matchIdx
		matchEnd := matchStart + len(result.Match)

		if matchStart > processed {
			emitOut(data[processed:matchStart])
		}

		onMatch(result, emitOut)

		if len(result.Match) > 0 {
			processed = matchEnd
		} else {
			processed++
		}
	}
	return processed
}

// ReplaceReader returns an io.Reader that replaces all matches with the template.
//
// Template syntax:
//
//	$0 or ${0}: full match
//	$1, $2, ...: capture group by index
//	$name or ${name}: capture group by name
//	$$: literal dollar sign
//
// Example:
//
//	r := pattern.ReplaceReader(input, "[$1]")
//	io.Copy(os.Stdout, r)
func (MultiDate) ReplaceReader(r io.Reader, template string) io.Reader {
	parsed, err := replace.Parse(template)
	if err != nil {
		return &multiDateTransformErrReader{err: err}
	}

	captureNames := map[string]int{"year": 1, "month": 2, "day": 3}
	resolved, err := parsed.ValidateAndResolve(captureNames, 3)
	if err != nil {
		return &multiDateTransformErrReader{err: err}
	}

	return MultiDate{}.NewTransformReader(r, stream.DefaultTransformConfig(), func(m *MultiDateBytesResult, emit func([]byte)) {
		result := make([]byte, 0, len(template)+64)
		for _, seg := range resolved {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, m.Match...)
			case replace.SegmentCaptureIndex:
				capture := (MultiDate{}).getCaptureByIndex(m, seg.CaptureIndex)
				if capture != nil {
					result = append(result, capture...)
				}
			}
		}
		emit(result)
	})
}

// multiDateTransformErrReader is a reader that always returns an error.
type multiDateTransformErrReader struct {
	err error
}

func (r *multiDateTransformErrReader) Read(p []byte) (int, error) {
	return 0, r.err
}

// getCaptureByIndex returns the capture group value by its index.
func (MultiDate) getCaptureByIndex(m *MultiDateBytesResult, index int) []byte {
	switch index {
	case 0:
		return m.Match
	case 1:
		return m.Year
	case 2:
		return m.Month
	case 3:
		return m.Day
	default:
		return nil
	}
}

// SelectReader returns an io.Reader that outputs only matches satisfying the predicate.
// Non-matching segments are dropped. Only matches where pred returns true are output.
//
// Example - extract all email addresses:
//
//	r := emailPattern.SelectReader(input, func(m *EmailBytesResult) bool {
//	    return true // Keep all matches
//	})
func (MultiDate) SelectReader(r io.Reader, pred func(*MultiDateBytesResult) bool) io.Reader {
	cfg := stream.DefaultTransformConfig()
	cfg.MaxLeftover = 1024

	processor := func(data []byte, isEOF bool, _ stream.TransformFunc, emitOut func([]byte)) int {
		return MultiDate{}.processSelect(data, isEOF, pred, emitOut)
	}

	return stream.NewTransformer(r, cfg, processor, func(_ []byte, emit func([]byte)) {})
}

// processSelect processes data for select filtering.
func (MultiDate) processSelect(data []byte, isEOF bool, pred func(*MultiDateBytesResult) bool, emitOut func([]byte)) int {
	processed := 0
	reuseResult := &MultiDateBytesResult{}

	for {
		result, ok := MultiDate{}.FindBytesReuse(data[processed:], reuseResult)
		if !ok {
			if isEOF {
				return len(data)
			}
			return processed
		}

		matchIdx := bytes.Index(data[processed:], result.Match)
		if matchIdx < 0 {
			break
		}

		matchEnd := processed + matchIdx + len(result.Match)

		if pred(result) {
			emitOut(result.Match)
		}

		if len(result.Match) > 0 {
			processed = matchEnd
		} else {
			processed++
		}
	}
	return processed
}

// RejectReader returns an io.Reader that removes matches satisfying the predicate.
// Non-matching segments pass through. Matches where pred returns true are dropped.
//
// Example - remove all sensitive data:
//
//	r := sensitivePattern.RejectReader(input, func(m *SensitiveBytesResult) bool {
//	    return true // Remove all matches
//	})
func (MultiDate) RejectReader(r io.Reader, pred func(*MultiDateBytesResult) bool) io.Reader {
	cfg := stream.DefaultTransformConfig()
	cfg.MaxLeftover = 1024

	processor := func(data []byte, isEOF bool, _ stream.TransformFunc, emitOut func([]byte)) int {
		return MultiDate{}.processReject(data, isEOF, pred, emitOut)
	}

	return stream.NewTransformer(r, cfg, processor, func(_ []byte, emit func([]byte)) {})
}

// processReject processes data for reject filtering.
func (MultiDate) processReject(data []byte, isEOF bool, pred func(*MultiDateBytesResult) bool, emitOut func([]byte)) int {
	processed := 0
	reuseResult := &MultiDateBytesResult{}

	for {
		result, ok := MultiDate{}.FindBytesReuse(data[processed:], reuseResult)
		if !ok {
			if isEOF {
				if processed < len(data) {
					emitOut(data[processed:])
				}
				return len(data)
			}
			safePoint := len(data) - 102
			if safePoint < processed {
				safePoint = processed
			}
			if safePoint > processed {
				emitOut(data[processed:safePoint])
			}
			return safePoint
		}

		matchIdx := bytes.Index(data[processed:], result.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := processed + matchIdx
		matchEnd := matchStart + len(result.Match)

		if matchStart > processed {
			emitOut(data[processed:matchStart])
		}

		if !pred(result) {
			emitOut(result.Match)
		}

		if len(result.Match) > 0 {
			processed = matchEnd
		} else {
			processed++
		}
	}
	return processed
}

// CaptureByIndex returns the capture group value by its 0-based index.
// Index 0 returns the full match, 1+ returns capture groups.
func (r *MultiDateResult) CaptureByIndex(idx int) string {
	switch idx {
	case 0:
		return r.Match
	case 1:
		return r.Year
	case 2:
		return r.Month
	case 3:
		return r.Day
	default:
		return ""
	}
}

// CaptureByIndex returns the capture group value by its 0-based index.
// Index 0 returns the full match, 1+ returns capture groups.
func (r *MultiDateBytesResult) CaptureByIndex(idx int) []byte {
	switch idx {
	case 0:
		return r.Match
	case 1:
		return r.Year
	case 2:
		return r.Month
	case 3:
		return r.Day
	default:
		return nil
	}
}

// ReplaceAllString replaces all matches in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (MultiDate) ReplaceAllString(input string, template string) string {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var result strings.Builder
	lastEnd := 0
	var r MultiDateResult

	remaining := input
	offset := 0

	for {
		match, ok := MultiDate{}.FindStringReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := strings.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := offset + matchIdx
		matchEnd := matchStart + len(match.Match)

		result.WriteString(input[lastEnd:matchStart])

		for _, seg := range tmpl.Segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result.WriteString(seg.Literal)
			case replace.SegmentFullMatch:
				result.WriteString(match.Match)
			case replace.SegmentCaptureIndex:
				result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
			case replace.SegmentCaptureName:
				switch seg.CaptureName {
				case "year":
					result.WriteString(match.Year)
				case "month":
					result.WriteString(match.Month)
				case "day":
					result.WriteString(match.Day)
				}
			}
		}

		lastEnd = matchEnd
		if len(match.Match) > 0 {
			remaining = input[matchEnd:]
			offset = matchEnd
		} else {
			if matchEnd < len(input) {
				remaining = input[matchEnd+1:]
				offset = matchEnd + 1
			} else {
				break
			}
		}
	}

	result.WriteString(input[lastEnd:])
	return result.String()
}

// ReplaceAllBytes replaces all matches in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (MultiDate) ReplaceAllBytes(input []byte, template string) []byte {
	return MultiDate{}.ReplaceAllBytesAppend(input, template, nil)
}

// ReplaceAllBytesAppend replaces all matches and appends to buf.
// If buf has sufficient capacity, no allocation occurs.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (MultiDate) ReplaceAllBytesAppend(input []byte, template string, buf []byte) []byte {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	result := buf[:0]
	lastEnd := 0
	var r MultiDateBytesResult

	remaining := input
	offset := 0

	for {
		match, ok := MultiDate{}.FindBytesReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := bytes.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		matchStart := offset + matchIdx
		matchEnd := matchStart + len(match.Match)

		result = append(result, input[lastEnd:matchStart]...)

		for _, seg := range tmpl.Segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, match.Match...)
			case replace.SegmentCaptureIndex:
				result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
			case replace.SegmentCaptureName:
				switch seg.CaptureName {
				case "year":
					result = append(result, match.Year...)
				case "month":
					result = append(result, match.Month...)
				case "day":
					result = append(result, match.Day...)
				}
			}
		}

		lastEnd = matchEnd
		if len(match.Match) > 0 {
			remaining = input[matchEnd:]
			offset = matchEnd
		} else {
			if matchEnd < len(input) {
				remaining = input[matchEnd+1:]
				offset = matchEnd + 1
			} else {
				break
			}
		}
	}

	result = append(result, input[lastEnd:]...)
	return result
}

// ReplaceFirstString replaces only the first match in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (MultiDate) ReplaceFirstString(input string, template string) string {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var r MultiDateResult
	match, ok := MultiDate{}.FindStringReuse(input, &r)
	if !ok {
		return input
	}

	matchIdx := strings.Index(input, match.Match)
	if matchIdx < 0 {
		return input
	}

	var result strings.Builder
	result.WriteString(input[:matchIdx])

	for _, seg := range tmpl.Segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result.WriteString(seg.Literal)
		case replace.SegmentFullMatch:
			result.WriteString(match.Match)
		case replace.SegmentCaptureIndex:
			result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
		case replace.SegmentCaptureName:
			switch seg.CaptureName {
			case "year":
				result.WriteString(match.Year)
			case "month":
				result.WriteString(match.Month)
			case "day":
				result.WriteString(match.Day)
			}
		}
	}

	result.WriteString(input[matchIdx+len(match.Match):])
	return result.String()
}

// ReplaceFirstBytes replaces only the first match in input with the template expansion.
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (MultiDate) ReplaceFirstBytes(input []byte, template string) []byte {
	tmpl, err := replace.Parse(template)
	if err != nil {
		panic(fmt.Sprintf("regengo: invalid replace template: %v", err))
	}

	var r MultiDateBytesResult
	match, ok := MultiDate{}.FindBytesReuse(input, &r)
	if !ok {
		return append([]byte{}, input...)
	}

	matchIdx := bytes.Index(input, match.Match)
	if matchIdx < 0 {
		return append([]byte{}, input...)
	}

	var result []byte
	result = append(result, input[:matchIdx]...)

	for _, seg := range tmpl.Segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result = append(result, seg.Literal...)
		case replace.SegmentFullMatch:
			result = append(result, match.Match...)
		case replace.SegmentCaptureIndex:
			result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
		case replace.SegmentCaptureName:
			switch seg.CaptureName {
			case "year":
				result = append(result, match.Year...)
			case "month":
				result = append(result, match.Month...)
			case "day":
				result = append(result, match.Day...)
			}
		}
	}

	result = append(result, input[matchIdx+len(match.Match):]...)
	return result
}

// MultiDateReplaceTemplate holds a pre-compiled replace template for the MultiDate pattern.
// Use CompileReplaceTemplate to create one, then call its Replace methods.
type MultiDateReplaceTemplate struct {
	original string
	segments []replace.Segment
}

// CompileReplaceTemplate parses and validates a replace template.
// Returns an error if the template syntax is invalid or references non-existent captures.
// The compiled template can be reused for multiple replacements without re-parsing.
//
// Template syntax: $0 (full match), $1/$2 (by index), $name (by name), $$ (literal $)
func (MultiDate) CompileReplaceTemplate(template string) (*MultiDateReplaceTemplate, error) {
	tmpl, err := replace.Parse(template)
	if err != nil {
		return nil, err
	}

	captureNames := map[string]int{
		"day":   3,
		"month": 2,
		"year":  1,
	}

	resolved, err := tmpl.ValidateAndResolve(captureNames, 3)
	if err != nil {
		return nil, err
	}

	return &MultiDateReplaceTemplate{
		original: template,
		segments: resolved,
	}, nil
}

// String returns the original template string.
func (t *MultiDateReplaceTemplate) String() string {
	return t.original
}

// ReplaceAllString replaces all matches in input using this compiled template.
func (t *MultiDateReplaceTemplate) ReplaceAllString(input string) string {
	var result strings.Builder
	lastEnd := 0
	var r MultiDateResult

	remaining := input
	offset := 0

	for {
		match, ok := MultiDate{}.FindStringReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := strings.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		absMatchStart := offset + matchIdx
		absMatchEnd := absMatchStart + len(match.Match)

		result.WriteString(input[lastEnd:absMatchStart])

		for _, seg := range t.segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result.WriteString(seg.Literal)
			case replace.SegmentFullMatch:
				result.WriteString(match.Match)
			case replace.SegmentCaptureIndex:
				result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
			}
		}

		lastEnd = absMatchEnd
		remaining = input[absMatchEnd:]
		offset = absMatchEnd
	}

	result.WriteString(input[lastEnd:])
	return result.String()
}

// ReplaceAllBytes replaces all matches in input using this compiled template.
func (t *MultiDateReplaceTemplate) ReplaceAllBytes(input []byte) []byte {
	return t.ReplaceAllBytesAppend(input, nil)
}

// ReplaceAllBytesAppend replaces all matches and appends to buf.
// If buf has sufficient capacity, no allocation occurs.
func (t *MultiDateReplaceTemplate) ReplaceAllBytesAppend(input []byte, buf []byte) []byte {
	result := buf[:0]
	lastEnd := 0
	var r MultiDateBytesResult

	remaining := input
	offset := 0

	for {
		match, ok := MultiDate{}.FindBytesReuse(remaining, &r)
		if !ok {
			break
		}

		matchIdx := bytes.Index(remaining, match.Match)
		if matchIdx < 0 {
			break
		}

		absMatchStart := offset + matchIdx
		absMatchEnd := absMatchStart + len(match.Match)

		result = append(result, input[lastEnd:absMatchStart]...)

		for _, seg := range t.segments {
			switch seg.Type {
			case replace.SegmentLiteral:
				result = append(result, seg.Literal...)
			case replace.SegmentFullMatch:
				result = append(result, match.Match...)
			case replace.SegmentCaptureIndex:
				result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
			}
		}

		lastEnd = absMatchEnd
		remaining = input[absMatchEnd:]
		offset = absMatchEnd
	}

	result = append(result, input[lastEnd:]...)
	return result
}

// ReplaceFirstString replaces only the first match using this compiled template.
func (t *MultiDateReplaceTemplate) ReplaceFirstString(input string) string {
	var r MultiDateResult
	match, ok := MultiDate{}.FindStringReuse(input, &r)
	if !ok {
		return input
	}

	matchIdx := strings.Index(input, match.Match)
	if matchIdx < 0 {
		return input
	}

	var result strings.Builder
	result.WriteString(input[:matchIdx])

	for _, seg := range t.segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result.WriteString(seg.Literal)
		case replace.SegmentFullMatch:
			result.WriteString(match.Match)
		case replace.SegmentCaptureIndex:
			result.WriteString(match.CaptureByIndex(seg.CaptureIndex))
		}
	}

	result.WriteString(input[matchIdx+len(match.Match):])
	return result.String()
}

// ReplaceFirstBytes replaces only the first match using this compiled template.
func (t *MultiDateReplaceTemplate) ReplaceFirstBytes(input []byte) []byte {
	var r MultiDateBytesResult
	match, ok := MultiDate{}.FindBytesReuse(input, &r)
	if !ok {
		return append([]byte{}, input...)
	}

	matchIdx := bytes.Index(input, match.Match)
	if matchIdx < 0 {
		return append([]byte{}, input...)
	}

	var result []byte
	result = append(result, input[:matchIdx]...)

	for _, seg := range t.segments {
		switch seg.Type {
		case replace.SegmentLiteral:
			result = append(result, seg.Literal...)
		case replace.SegmentFullMatch:
			result = append(result, match.Match...)
		case replace.SegmentCaptureIndex:
			result = append(result, match.CaptureByIndex(seg.CaptureIndex)...)
		}
	}

	result = append(result, input[matchIdx+len(match.Match):]...)
	return result
}

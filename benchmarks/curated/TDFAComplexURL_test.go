package curated

import (
	"fmt"
	stream "github.com/KromDaniel/regengo/stream"
	"regexp"
	"strings"
	"testing"
)

// Code generated by regengo
// Tests and benchmarks for pattern: (?P<scheme>https?)://(?P<auth>(?P<user>[\w.-]+)(?::(?P<pass>[\w.-]+))?@)?(?P<host>[\w.-]+)(?::(?P<port>\d+))?(?P<path>/[\w./-]*)?(?:\?(?P<query>[\w=&.-]+))?

var tDFAComplexURLRegexp = regexp.MustCompile("(?P<scheme>https?)://(?P<auth>(?P<user>[\\w.-]+)(?::(?P<pass>[\\w.-]+))?@)?(?P<host>[\\w.-]+)(?::(?P<port>\\d+))?(?P<path>/[\\w./-]*)?(?:\\?(?P<query>[\\w=&.-]+))?")

var tDFAComplexURLTestInputs = []string{"https://example.com", "http://user:pass@example.com:8080/path/to/resource?key=value&foo=bar", "https://api.github.com/repos/owner/repo"}

func TestTDFAComplexURLMatchString(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		expected := tDFAComplexURLRegexp.MatchString(input)
		got := TDFAComplexURL{}.MatchString(input)
		if got != expected {
			t.Errorf("MatchString(%q) = %v, want %v", input, got, expected)
		}
	}
}

func TestTDFAComplexURLMatchBytes(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		inputBytes := []byte(input)
		expected := tDFAComplexURLRegexp.Match(inputBytes)
		got := TDFAComplexURL{}.MatchBytes(inputBytes)
		if got != expected {
			t.Errorf("MatchBytes(%q) = %v, want %v", input, got, expected)
		}
	}
}

func TestTDFAComplexURLFindString(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		expectedMatches := tDFAComplexURLRegexp.FindStringSubmatch(input)
		result, ok := TDFAComplexURL{}.FindString(input)

		if len(expectedMatches) > 0 {
			if !ok {
				t.Errorf("FindString(%q) returned false, expected match", input)
				continue
			}
			if result.Match != expectedMatches[0] {
				t.Errorf("FindString(%q).Match = %q, want %q", input, result.Match, expectedMatches[0])
			}
			{
				if result.Scheme != expectedMatches[1] {
					t.Errorf("FindString(%q).Scheme = %q, want %q", input, result.Scheme, expectedMatches[1])
				}
				if result.Auth != expectedMatches[2] {
					t.Errorf("FindString(%q).Auth = %q, want %q", input, result.Auth, expectedMatches[2])
				}
				if result.User != expectedMatches[3] {
					t.Errorf("FindString(%q).User = %q, want %q", input, result.User, expectedMatches[3])
				}
				if result.Pass != expectedMatches[4] {
					t.Errorf("FindString(%q).Pass = %q, want %q", input, result.Pass, expectedMatches[4])
				}
				if result.Host != expectedMatches[5] {
					t.Errorf("FindString(%q).Host = %q, want %q", input, result.Host, expectedMatches[5])
				}
				if result.Port != expectedMatches[6] {
					t.Errorf("FindString(%q).Port = %q, want %q", input, result.Port, expectedMatches[6])
				}
				if result.Path != expectedMatches[7] {
					t.Errorf("FindString(%q).Path = %q, want %q", input, result.Path, expectedMatches[7])
				}
				if result.Query != expectedMatches[8] {
					t.Errorf("FindString(%q).Query = %q, want %q", input, result.Query, expectedMatches[8])
				}
			}
		} else {
			if ok {
				t.Errorf("FindString(%q) returned true, expected no match", input)
			}
		}
	}
}

func TestTDFAComplexURLFindAllString(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		expectedAll := tDFAComplexURLRegexp.FindAllStringSubmatch(input, -1)
		results := TDFAComplexURL{}.FindAllString(input, -1)

		if len(results) != len(expectedAll) {
			t.Errorf("FindAllString(%q, -1) returned %d results, want %d", input, len(results), len(expectedAll))
			continue
		}
		for i := range results {
			if results[i].Match != expectedAll[i][0] {
				t.Errorf("FindAllString(%q, -1)[%d].Match = %q, want %q", input, i, results[i].Match, expectedAll[i][0])
			}
			{
				if results[i].Scheme != expectedAll[i][1] {
					t.Errorf("FindAllString(%q, -1)[%d].Scheme = %q, want %q", input, i, results[i].Scheme, expectedAll[i][1])
				}
				if results[i].Auth != expectedAll[i][2] {
					t.Errorf("FindAllString(%q, -1)[%d].Auth = %q, want %q", input, i, results[i].Auth, expectedAll[i][2])
				}
				if results[i].User != expectedAll[i][3] {
					t.Errorf("FindAllString(%q, -1)[%d].User = %q, want %q", input, i, results[i].User, expectedAll[i][3])
				}
				if results[i].Pass != expectedAll[i][4] {
					t.Errorf("FindAllString(%q, -1)[%d].Pass = %q, want %q", input, i, results[i].Pass, expectedAll[i][4])
				}
				if results[i].Host != expectedAll[i][5] {
					t.Errorf("FindAllString(%q, -1)[%d].Host = %q, want %q", input, i, results[i].Host, expectedAll[i][5])
				}
				if results[i].Port != expectedAll[i][6] {
					t.Errorf("FindAllString(%q, -1)[%d].Port = %q, want %q", input, i, results[i].Port, expectedAll[i][6])
				}
				if results[i].Path != expectedAll[i][7] {
					t.Errorf("FindAllString(%q, -1)[%d].Path = %q, want %q", input, i, results[i].Path, expectedAll[i][7])
				}
				if results[i].Query != expectedAll[i][8] {
					t.Errorf("FindAllString(%q, -1)[%d].Query = %q, want %q", input, i, results[i].Query, expectedAll[i][8])
				}
			}
		}
	}
}

func BenchmarkTDFAComplexURL(b *testing.B) {
	inputs := tDFAComplexURLTestInputs

	b.Run("Match", func(b *testing.B) {
		for i, input := range inputs {
			input := input
			b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
				b.Run("stdlib", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = tDFAComplexURLRegexp.MatchString(input)
					}
				})
				b.Run("regengo", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = TDFAComplexURL{}.MatchString(input)
					}
				})
			})
		}
	})

	b.Run("FindFirst", func(b *testing.B) {
		for i, input := range inputs {
			input := input
			b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
				b.Run("stdlib", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = tDFAComplexURLRegexp.FindStringSubmatch(input)
					}
				})
				b.Run("regengo", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_, _ = TDFAComplexURL{}.FindString(input)
					}
				})
				b.Run("regengo_reuse", func(b *testing.B) {
					b.ReportAllocs()
					var result *TDFAComplexURLResult
					for b.Loop() {
						result, _ = TDFAComplexURL{}.FindStringReuse(input, result)
					}
				})
			})
		}
	})

	b.Run("FindAll", func(b *testing.B) {
		for i, input := range inputs {
			input := input
			b.Run(fmt.Sprintf("Input[%d]", i), func(b *testing.B) {
				b.Run("stdlib", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = tDFAComplexURLRegexp.FindAllStringSubmatch(input, -1)
					}
				})
				b.Run("regengo", func(b *testing.B) {
					b.ReportAllocs()
					for b.Loop() {
						_ = TDFAComplexURL{}.FindAllString(input, -1)
					}
				})
				b.Run("regengo_append", func(b *testing.B) {
					b.ReportAllocs()
					results := make([]*TDFAComplexURLResult, 0, 100)
					for b.Loop() {
						results = TDFAComplexURL{}.FindAllStringAppend(input, -1, results[:0])
					}
				})
			})
		}
	})

}

func TestTDFAComplexURLFindReader(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		// Get expected matches from stdlib
		expectedAll := tDFAComplexURLRegexp.FindAllString(input, -1)

		// Get matches from streaming API
		var streamMatches []string
		err := TDFAComplexURL{}.FindReader(strings.NewReader(input), stream.Config{}, func(m stream.Match[*TDFAComplexURLBytesResult]) bool {
			streamMatches = append(streamMatches, string(m.Result.Match))
			return true
		})
		if err != nil {
			t.Errorf("FindReader(%q) error: %v", input, err)
			continue
		}

		// Compare results
		if len(streamMatches) != len(expectedAll) {
			t.Errorf("FindReader(%q) got %d matches, want %d", input, len(streamMatches), len(expectedAll))
			continue
		}
		for i := range streamMatches {
			if streamMatches[i] != expectedAll[i] {
				t.Errorf("FindReader(%q)[%d] = %q, want %q", input, i, streamMatches[i], expectedAll[i])
			}
		}
	}
}

func TestTDFAComplexURLFindReaderCount(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		expectedAll := tDFAComplexURLRegexp.FindAllString(input, -1)
		expected := int64(len(expectedAll))

		count, err := TDFAComplexURL{}.FindReaderCount(strings.NewReader(input), stream.Config{})
		if err != nil {
			t.Errorf("FindReaderCount(%q) error: %v", input, err)
			continue
		}
		if count != expected {
			t.Errorf("FindReaderCount(%q) = %d, want %d", input, count, expected)
		}
	}
}

func TestTDFAComplexURLFindReaderFirst(t *testing.T) {
	for _, input := range tDFAComplexURLTestInputs {
		expected := tDFAComplexURLRegexp.FindString(input)

		result, _, err := TDFAComplexURL{}.FindReaderFirst(strings.NewReader(input), stream.Config{})
		if err != nil {
			t.Errorf("FindReaderFirst(%q) error: %v", input, err)
			continue
		}

		if expected == "" {
			if result != nil {
				t.Errorf("FindReaderFirst(%q) = %q, want no match", input, string(result.Match))
			}
		} else {
			if result == nil {
				t.Errorf("FindReaderFirst(%q) = nil, want %q", input, expected)
			} else if string(result.Match) != expected {
				t.Errorf("FindReaderFirst(%q) = %q, want %q", input, string(result.Match), expected)
			}
		}
	}
}

func TestTDFAComplexURLMatchLengthInfo(t *testing.T) {
	minLen, maxLen := TDFAComplexURL{}.MatchLengthInfo()
	// Just verify we get sensible values
	if minLen < 0 {
		t.Errorf("MinMatchLen = %d, expected >= 0", minLen)
	}
	if maxLen != -1 && maxLen < minLen {
		t.Errorf("MaxMatchLen = %d < MinMatchLen = %d", maxLen, minLen)
	}
}

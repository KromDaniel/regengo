package generated

import "sync"

// Code generated by regengo for pattern: (?P<user>[\w\.+-]+)@(?P<domain>[\w\.-]+)\.(?P<tld>[\w\.-]+)
// DO NOT EDIT.

var multiEmailStackPool = sync.Pool{New: func() interface{} {
	stack := make([][2]int, 0, 32)
	return &stack
}}

var multiEmailCaptureStackPool = sync.Pool{New: func() interface{} {
	stack := make([]int, 0, 128)
	return &stack
}}

type MultiEmail struct{}

var CompiledMultiEmail = MultiEmail{}

func (MultiEmail) MatchString(input string) bool {
	l := len(input)
	offset := 0
	stackPtr := multiEmailStackPool.Get().(*[][2]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [2]int{0, 0}
		}
		*stackPtr = stack[:0]
		multiEmailStackPool.Put(stackPtr)
	}()
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		stack = append(stack, [2]int{offset, 2})
		goto Ins4
	}
Ins4:
	{
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		stack = append(stack, [2]int{offset, 7})
		goto Ins9
	}
Ins9:
	{
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		goto Ins12
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		stack = append(stack, [2]int{offset, 12})
		goto Ins14
	}
Ins14:
	{
		goto Ins15
	}
Ins15:
	{
		return true
	}
}
func (MultiEmail) MatchBytes(input []byte) bool {
	l := len(input)
	offset := 0
	stackPtr := multiEmailStackPool.Get().(*[][2]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [2]int{0, 0}
		}
		*stackPtr = stack[:0]
		multiEmailStackPool.Put(stackPtr)
	}()
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		stack = append(stack, [2]int{offset, 2})
		goto Ins4
	}
Ins4:
	{
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		stack = append(stack, [2]int{offset, 7})
		goto Ins9
	}
Ins9:
	{
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		goto Ins12
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		stack = append(stack, [2]int{offset, 12})
		goto Ins14
	}
Ins14:
	{
		goto Ins15
	}
Ins15:
	{
		return true
	}
}

type MultiEmailResult struct {
	Match  string // Full match
	User   string
	Domain string
	Tld    string
}

type MultiEmailBytesResult struct {
	Match  []byte // Full match
	User   []byte
	Domain []byte
	Tld    []byte
}

func (MultiEmail) FindStringReuse(input string, r *MultiEmailResult) (*MultiEmailResult, bool) {
	l := len(input)
	offset := 0
	var captures [8]int
	captureStackPtr := multiEmailCaptureStackPool.Get().(*[]int)
	captureStack := (*captureStackPtr)[:0]
	defer func() {
		*captureStackPtr = captureStack[:0]
		multiEmailCaptureStackPool.Put(captureStackPtr)
	}()
	stackPtr := multiEmailStackPool.Get().(*[][2]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [2]int{0, 0}
		}
		*stackPtr = stack[:0]
		multiEmailStackPool.Put(stackPtr)
	}()
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		if len(captureStack) > 0 {
			n := len(captures)
			top := len(captureStack) - n
			copy(captures[:], captureStack[top:])
			captureStack = captureStack[:top]
		}
		goto StepSelect
	} else {
		if l > offset {
			offset++
			for i := range captures {
				captures[i] = 0
			}
			captureStack = captureStack[:0]
			captures[0] = offset
			nextInstruction = 1
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [2]int{offset, 4})
		goto Ins2
	}
Ins4:
	{
		captures[3] = offset
		nextInstruction = 5
		goto StepSelect
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[4] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [2]int{offset, 9})
		goto Ins7
	}
Ins9:
	{
		captures[5] = offset
		nextInstruction = 10
		goto StepSelect
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[6] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [2]int{offset, 14})
		goto Ins12
	}
Ins14:
	{
		captures[7] = offset
		nextInstruction = 15
		goto StepSelect
	}
Ins15:
	{
		captures[1] = offset
		if r == nil {
			r = &MultiEmailResult{}
		}
		r.Match = string(input[captures[0]:captures[1]])
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.User = string(input[captures[2]:captures[3]])
		} else {
			r.User = ""
		}
		if captures[4] <= captures[5] && captures[5] <= len(input) {
			r.Domain = string(input[captures[4]:captures[5]])
		} else {
			r.Domain = ""
		}
		if captures[6] <= captures[7] && captures[7] <= len(input) {
			r.Tld = string(input[captures[6]:captures[7]])
		} else {
			r.Tld = ""
		}
		return r, true
	}
}
func (recv MultiEmail) FindString(input string) (*MultiEmailResult, bool) {
	return recv.FindStringReuse(input, nil)
}
func (MultiEmail) FindAllStringAppend(input string, n int, s []*MultiEmailResult) []*MultiEmailResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [8]int
		captureStackPtr := multiEmailCaptureStackPool.Get().(*[]int)
		captureStack := (*captureStackPtr)[:0]
		defer func() {
			*captureStackPtr = captureStack[:0]
			multiEmailCaptureStackPool.Put(captureStackPtr)
		}()
		stackPtr := multiEmailStackPool.Get().(*[][2]int)
		stack := (*stackPtr)[:0]
		defer func() {
			for i := range stack {
				stack[i] = [2]int{0, 0}
			}
			*stackPtr = stack[:0]
			multiEmailStackPool.Put(stackPtr)
		}()
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		if len(stack) > 0 {
			last := stack[len(stack)-1]
			offset = last[0]
			nextInstruction = last[1]
			stack = stack[:len(stack)-1]
			goto StepSelect
		} else {
			searchStart++
			continue
		}
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [2]int{offset, 4})
			goto Ins2
		}
	Ins4:
		{
			captures[3] = offset
			nextInstruction = 5
			goto StepSelect
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x40) {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captures[4] = offset
			nextInstruction = 7
			goto StepSelect
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [2]int{offset, 9})
			goto Ins7
		}
	Ins9:
		{
			captures[5] = offset
			nextInstruction = 10
			goto StepSelect
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2e) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			captures[6] = offset
			nextInstruction = 12
			goto StepSelect
		}
	Ins12:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins13
		}
	Ins13:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [2]int{offset, 14})
			goto Ins12
		}
	Ins14:
		{
			captures[7] = offset
			nextInstruction = 15
			goto StepSelect
		}
	Ins15:
		{
			captures[1] = offset
			var item *MultiEmailResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &MultiEmailResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &MultiEmailResult{}
				result = append(result, item)
			}
			item.Match = string(input[captures[0]:captures[1]])
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.User = string(input[captures[2]:captures[3]])
			} else {
				item.User = ""
			}
			if captures[4] <= captures[5] && captures[5] <= len(input) {
				item.Domain = string(input[captures[4]:captures[5]])
			} else {
				item.Domain = ""
			}
			if captures[6] <= captures[7] && captures[7] <= len(input) {
				item.Tld = string(input[captures[6]:captures[7]])
			} else {
				item.Tld = ""
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r MultiEmail) FindAllString(input string, n int) []*MultiEmailResult {
	return r.FindAllStringAppend(input, n, nil)
}
func (MultiEmail) FindBytesReuse(input []byte, r *MultiEmailBytesResult) (*MultiEmailBytesResult, bool) {
	l := len(input)
	offset := 0
	var captures [8]int
	captureStackPtr := multiEmailCaptureStackPool.Get().(*[]int)
	captureStack := (*captureStackPtr)[:0]
	defer func() {
		*captureStackPtr = captureStack[:0]
		multiEmailCaptureStackPool.Put(captureStackPtr)
	}()
	stackPtr := multiEmailStackPool.Get().(*[][2]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [2]int{0, 0}
		}
		*stackPtr = stack[:0]
		multiEmailStackPool.Put(stackPtr)
	}()
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		if len(captureStack) > 0 {
			n := len(captures)
			top := len(captureStack) - n
			copy(captures[:], captureStack[top:])
			captureStack = captureStack[:top]
		}
		goto StepSelect
	} else {
		if l > offset {
			offset++
			for i := range captures {
				captures[i] = 0
			}
			captureStack = captureStack[:0]
			captures[0] = offset
			nextInstruction = 1
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [2]int{offset, 4})
		goto Ins2
	}
Ins4:
	{
		captures[3] = offset
		nextInstruction = 5
		goto StepSelect
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[4] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [2]int{offset, 9})
		goto Ins7
	}
Ins9:
	{
		captures[5] = offset
		nextInstruction = 10
		goto StepSelect
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[6] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [2]int{offset, 14})
		goto Ins12
	}
Ins14:
	{
		captures[7] = offset
		nextInstruction = 15
		goto StepSelect
	}
Ins15:
	{
		captures[1] = offset
		if r == nil {
			r = &MultiEmailBytesResult{}
		}
		r.Match = input[captures[0]:captures[1]]
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.User = input[captures[2]:captures[3]]
		} else {
			r.User = nil
		}
		if captures[4] <= captures[5] && captures[5] <= len(input) {
			r.Domain = input[captures[4]:captures[5]]
		} else {
			r.Domain = nil
		}
		if captures[6] <= captures[7] && captures[7] <= len(input) {
			r.Tld = input[captures[6]:captures[7]]
		} else {
			r.Tld = nil
		}
		return r, true
	}
}
func (recv MultiEmail) FindBytes(input []byte) (*MultiEmailBytesResult, bool) {
	return recv.FindBytesReuse(input, nil)
}
func (MultiEmail) FindAllBytesAppend(input []byte, n int, s []*MultiEmailBytesResult) []*MultiEmailBytesResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [8]int
		captureStackPtr := multiEmailCaptureStackPool.Get().(*[]int)
		captureStack := (*captureStackPtr)[:0]
		defer func() {
			*captureStackPtr = captureStack[:0]
			multiEmailCaptureStackPool.Put(captureStackPtr)
		}()
		stackPtr := multiEmailStackPool.Get().(*[][2]int)
		stack := (*stackPtr)[:0]
		defer func() {
			for i := range stack {
				stack[i] = [2]int{0, 0}
			}
			*stackPtr = stack[:0]
			multiEmailStackPool.Put(stackPtr)
		}()
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		if len(stack) > 0 {
			last := stack[len(stack)-1]
			offset = last[0]
			nextInstruction = last[1]
			stack = stack[:len(stack)-1]
			goto StepSelect
		} else {
			searchStart++
			continue
		}
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [2]int{offset, 4})
			goto Ins2
		}
	Ins4:
		{
			captures[3] = offset
			nextInstruction = 5
			goto StepSelect
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x40) {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captures[4] = offset
			nextInstruction = 7
			goto StepSelect
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [2]int{offset, 9})
			goto Ins7
		}
	Ins9:
		{
			captures[5] = offset
			nextInstruction = 10
			goto StepSelect
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2e) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			captures[6] = offset
			nextInstruction = 12
			goto StepSelect
		}
	Ins12:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins13
		}
	Ins13:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [2]int{offset, 14})
			goto Ins12
		}
	Ins14:
		{
			captures[7] = offset
			nextInstruction = 15
			goto StepSelect
		}
	Ins15:
		{
			captures[1] = offset
			var item *MultiEmailBytesResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &MultiEmailBytesResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &MultiEmailBytesResult{}
				result = append(result, item)
			}
			item.Match = input[captures[0]:captures[1]]
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.User = input[captures[2]:captures[3]]
			} else {
				item.User = nil
			}
			if captures[4] <= captures[5] && captures[5] <= len(input) {
				item.Domain = input[captures[4]:captures[5]]
			} else {
				item.Domain = nil
			}
			if captures[6] <= captures[7] && captures[7] <= len(input) {
				item.Tld = input[captures[6]:captures[7]]
			} else {
				item.Tld = nil
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r MultiEmail) FindAllBytes(input []byte, n int) []*MultiEmailBytesResult {
	return r.FindAllBytesAppend(input, n, nil)
}

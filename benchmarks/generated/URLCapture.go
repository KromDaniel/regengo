package generated

import "sync"

// Code generated by regengo for pattern: (?P<protocol>https?)://(?P<host>[\w\.-]+)(?::(?P<port>\d+))?(?P<path>/[\w\./]*)?
// DO NOT EDIT.

var uRLCaptureStackPool = sync.Pool{New: func() interface{} {
	stack := make([][2]int, 0, 32)
	return &stack
}}

type URLCapture struct{}

var CompiledURLCapture = URLCapture{}

func (URLCapture) MatchString(input string) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x10000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := map[int]uint64{2: uint64(uint64(0x8)), 3: uint64(uint64(0x10)), 4: uint64(uint64(0x20)), 5: uint64(uint64(0x3c0)), 6: uint64(uint64(0x300)), 9: uint64(uint64(0x400)), 10: uint64(uint64(0x800)), 11: uint64(uint64(0x3000)), 13: uint64(uint64(0x18e1e000)), 16: uint64(uint64(0x60000)), 18: uint64(uint64(0x18dc0000)), 23: uint64(uint64(0x17000000)), 24: uint64(uint64(0x17000000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x68) {
				next |= epsilonClosures[2]
			}
			// State 3
			if current&uint64(uint64(0x8)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[3]
			}
			// State 4
			if current&uint64(uint64(0x10)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[4]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x70) {
				next |= epsilonClosures[5]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x73) {
				next |= epsilonClosures[6]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[9]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[10]
			}
			// State 1
			if current&uint64(uint64(0x800)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[11]
			}
			// State 3
			if current&uint64(uint64(0x2000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[13]
			}
			// State 6
			if current&uint64(uint64(0x10000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[16]
			}
			// State 8
			if current&uint64(uint64(0x40000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[18]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[23]
			}
			// State 4
			if current&uint64(uint64(0x1000000)) != 0 && ((((c >= uint8(0x2e) && c <= uint8(0x39)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[24]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}
func (URLCapture) MatchBytes(input []byte) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x10000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := map[int]uint64{2: uint64(uint64(0x8)), 3: uint64(uint64(0x10)), 4: uint64(uint64(0x20)), 5: uint64(uint64(0x3c0)), 6: uint64(uint64(0x300)), 9: uint64(uint64(0x400)), 10: uint64(uint64(0x800)), 11: uint64(uint64(0x3000)), 13: uint64(uint64(0x18e1e000)), 16: uint64(uint64(0x60000)), 18: uint64(uint64(0x18dc0000)), 23: uint64(uint64(0x17000000)), 24: uint64(uint64(0x17000000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x68) {
				next |= epsilonClosures[2]
			}
			// State 3
			if current&uint64(uint64(0x8)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[3]
			}
			// State 4
			if current&uint64(uint64(0x10)) != 0 && c == uint8(0x74) {
				next |= epsilonClosures[4]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x70) {
				next |= epsilonClosures[5]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x73) {
				next |= epsilonClosures[6]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[9]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[10]
			}
			// State 1
			if current&uint64(uint64(0x800)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[11]
			}
			// State 3
			if current&uint64(uint64(0x2000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[13]
			}
			// State 6
			if current&uint64(uint64(0x10000)) != 0 && c == uint8(0x3a) {
				next |= epsilonClosures[16]
			}
			// State 8
			if current&uint64(uint64(0x40000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[18]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && c == uint8(0x2f) {
				next |= epsilonClosures[23]
			}
			// State 4
			if current&uint64(uint64(0x1000000)) != 0 && ((((c >= uint8(0x2e) && c <= uint8(0x39)) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[24]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty string when not matched.

type URLCaptureResult struct {
	Match    string // Full match
	Protocol string
	Host     string
	Port     string
	Path     string
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty slice when not matched.

type URLCaptureBytesResult struct {
	Match    []byte // Full match
	Protocol []byte
	Host     []byte
	Port     []byte
	Path     []byte
}

func (URLCapture) FindStringReuse(input string, r *URLCaptureResult) (*URLCaptureResult, bool) {
	result, ok := URLCapture{}.findStringInternal(input)
	if !ok {
		return nil, false
	}
	return &result, true
}
func (URLCapture) findStringInternal(input string) (URLCaptureResult, bool) {
	l := len(input)
	// TDFA transition table [state][char] -> next state (-1 = no transition)
	transitions := [13][128]int{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, 10, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}
	// Tag registers for capture positions
	tags := [10]int{}
	for i := range tags {
		tags[i] = -1
	}
	// Tag actions per transition
	tagActions := map[int]map[byte][]struct {
		Tag    int
		Offset int
	}{0: {104: {{
		Offset: 1,
		Tag:    2,
	}}}, 4: {58: {{
		Offset: 1,
		Tag:    3,
	}}}, 6: {58: {{
		Offset: 1,
		Tag:    3,
	}}}, 8: {79: {{
		Offset: 1,
		Tag:    4,
	}}, 46: {{
		Offset: 1,
		Tag:    4,
	}}, 71: {{
		Offset: 1,
		Tag:    4,
	}}, 76: {{
		Offset: 1,
		Tag:    4,
	}}, 78: {{
		Offset: 1,
		Tag:    4,
	}}, 110: {{
		Offset: 1,
		Tag:    4,
	}}, 119: {{
		Offset: 1,
		Tag:    4,
	}}, 121: {{
		Offset: 1,
		Tag:    4,
	}}, 81: {{
		Offset: 1,
		Tag:    4,
	}}, 95: {{
		Offset: 1,
		Tag:    4,
	}}, 105: {{
		Offset: 1,
		Tag:    4,
	}}, 48: {{
		Offset: 1,
		Tag:    4,
	}}, 49: {{
		Offset: 1,
		Tag:    4,
	}}, 55: {{
		Offset: 1,
		Tag:    4,
	}}, 80: {{
		Offset: 1,
		Tag:    4,
	}}, 97: {{
		Offset: 1,
		Tag:    4,
	}}, 109: {{
		Offset: 1,
		Tag:    4,
	}}, 88: {{
		Offset: 1,
		Tag:    4,
	}}, 52: {{
		Offset: 1,
		Tag:    4,
	}}, 53: {{
		Offset: 1,
		Tag:    4,
	}}, 66: {{
		Offset: 1,
		Tag:    4,
	}}, 102: {{
		Offset: 1,
		Tag:    4,
	}}, 111: {{
		Offset: 1,
		Tag:    4,
	}}, 50: {{
		Offset: 1,
		Tag:    4,
	}}, 77: {{
		Offset: 1,
		Tag:    4,
	}}, 86: {{
		Offset: 1,
		Tag:    4,
	}}, 112: {{
		Offset: 1,
		Tag:    4,
	}}, 54: {{
		Offset: 1,
		Tag:    4,
	}}, 89: {{
		Offset: 1,
		Tag:    4,
	}}, 98: {{
		Offset: 1,
		Tag:    4,
	}}, 101: {{
		Offset: 1,
		Tag:    4,
	}}, 117: {{
		Offset: 1,
		Tag:    4,
	}}, 69: {{
		Offset: 1,
		Tag:    4,
	}}, 75: {{
		Offset: 1,
		Tag:    4,
	}}, 67: {{
		Offset: 1,
		Tag:    4,
	}}, 70: {{
		Offset: 1,
		Tag:    4,
	}}, 82: {{
		Offset: 1,
		Tag:    4,
	}}, 73: {{
		Offset: 1,
		Tag:    4,
	}}, 84: {{
		Offset: 1,
		Tag:    4,
	}}, 90: {{
		Offset: 1,
		Tag:    4,
	}}, 103: {{
		Offset: 1,
		Tag:    4,
	}}, 108: {{
		Offset: 1,
		Tag:    4,
	}}, 115: {{
		Offset: 1,
		Tag:    4,
	}}, 116: {{
		Offset: 1,
		Tag:    4,
	}}, 45: {{
		Offset: 1,
		Tag:    4,
	}}, 65: {{
		Offset: 1,
		Tag:    4,
	}}, 83: {{
		Offset: 1,
		Tag:    4,
	}}, 99: {{
		Offset: 1,
		Tag:    4,
	}}, 114: {{
		Offset: 1,
		Tag:    4,
	}}, 72: {{
		Offset: 1,
		Tag:    4,
	}}, 74: {{
		Offset: 1,
		Tag:    4,
	}}, 87: {{
		Offset: 1,
		Tag:    4,
	}}, 104: {{
		Offset: 1,
		Tag:    4,
	}}, 106: {{
		Offset: 1,
		Tag:    4,
	}}, 51: {{
		Offset: 1,
		Tag:    4,
	}}, 56: {{
		Offset: 1,
		Tag:    4,
	}}, 85: {{
		Offset: 1,
		Tag:    4,
	}}, 107: {{
		Offset: 1,
		Tag:    4,
	}}, 113: {{
		Offset: 1,
		Tag:    4,
	}}, 120: {{
		Offset: 1,
		Tag:    4,
	}}, 122: {{
		Offset: 1,
		Tag:    4,
	}}, 68: {{
		Offset: 1,
		Tag:    4,
	}}, 100: {{
		Offset: 1,
		Tag:    4,
	}}, 118: {{
		Offset: 1,
		Tag:    4,
	}}, 57: {{
		Offset: 1,
		Tag:    4,
	}}}, 9: {47: {{
		Offset: 1,
		Tag:    5,
	}, {
		Offset: 1,
		Tag:    8,
	}}, 58: {{
		Offset: 1,
		Tag:    5,
	}}}, 11: {53: {{
		Offset: 1,
		Tag:    6,
	}}, 56: {{
		Offset: 1,
		Tag:    6,
	}}, 51: {{
		Offset: 1,
		Tag:    6,
	}}, 54: {{
		Offset: 1,
		Tag:    6,
	}}, 55: {{
		Offset: 1,
		Tag:    6,
	}}, 57: {{
		Offset: 1,
		Tag:    6,
	}}, 48: {{
		Offset: 1,
		Tag:    6,
	}}, 49: {{
		Offset: 1,
		Tag:    6,
	}}, 50: {{
		Offset: 1,
		Tag:    6,
	}}, 52: {{
		Offset: 1,
		Tag:    6,
	}}}, 12: {47: {{
		Offset: 1,
		Tag:    7,
	}, {
		Offset: 1,
		Tag:    8,
	}}}}
	// Accept states array
	acceptStates := [13]bool{false, false, false, false, false, false, false, false, false, true, true, false, true}
	// Accept states array (End of Text)
	acceptStatesEOT := [13]bool{false, false, false, false, false, false, false, false, false, true, true, false, true}
	// Accept actions - tag actions to apply when accepting at each state
	acceptActionsMap := map[int][]struct {
		Tag    int
		Offset int
	}{9: {{
		Offset: 0,
		Tag:    5,
	}}, 10: {{
		Offset: 0,
		Tag:    9,
	}}, 12: {{
		Offset: 0,
		Tag:    7,
	}}}
	state := 0
	matchEnd := -1
	matchTags := [10]int{}
	for i := range matchTags {
		matchTags[i] = -1
	}

	// Iterate over all possible start positions
	for start := 0; start <= l; start++ {
		// Reset tags for this attempt
		for i := range tags {
			tags[i] = -1
		}
		tags[0] = start

		// Choose start state based on position
		if start == 0 {
			state = 0
		} else {
			state = 0
		}

		// Check if start state is accepting (empty match)
		if acceptStates[state] {
			matchEnd = start
			matchTags = tags
		}
		// Check if start state is accepting at EOT
		if start == l && acceptStatesEOT[state] {
			matchEnd = start
			matchTags = tags
		}

		for i := start; i < l; i++ {
			c := input[i]
			if c >= 128 {
				break
			}

			// Look up transition (array-based for speed)
			nextState := transitions[state][c]
			if nextState < 0 {
				break
			}

			// Apply tag actions for this transition
			if stateActions, ok := tagActions[state]; ok {
				if charActions, ok := stateActions[c]; ok {
					for _, action := range charActions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
			}

			state = nextState
			if acceptStates[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
			if i == l-1 && acceptStatesEOT[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
		}

		// If we found a match, return it
		if matchEnd >= 0 {
			matchTags[1] = matchEnd
			var result URLCaptureResult
			if matchTags[0] >= 0 {
				result.Match = input[matchTags[0]:matchTags[1]]
			}
			if matchTags[2] >= 0 {
				if matchTags[3] < 0 {
					matchTags[3] = matchTags[1]
				}
				result.Protocol = input[matchTags[2]:matchTags[3]]
			}
			if matchTags[4] >= 0 {
				if matchTags[5] < 0 {
					matchTags[5] = matchTags[1]
				}
				result.Host = input[matchTags[4]:matchTags[5]]
			}
			if matchTags[6] >= 0 {
				if matchTags[7] < 0 {
					matchTags[7] = matchTags[1]
				}
				result.Port = input[matchTags[6]:matchTags[7]]
			}
			if matchTags[8] >= 0 {
				if matchTags[9] < 0 {
					matchTags[9] = matchTags[1]
				}
				result.Path = input[matchTags[8]:matchTags[9]]
			}
			return result, true
		}
	}
	return URLCaptureResult{}, false
}
func (URLCapture) FindString(input string) (*URLCaptureResult, bool) {
	return URLCapture{}.FindStringReuse(input, nil)
}
func (URLCapture) FindBytesReuse(input []byte, r *URLCaptureBytesResult) (*URLCaptureBytesResult, bool) {
	result, ok := URLCapture{}.findBytesInternal(input)
	if !ok {
		return nil, false
	}
	return &result, true
}
func (URLCapture) findBytesInternal(input []byte) (URLCaptureBytesResult, bool) {
	l := len(input)
	// TDFA transition table [state][char] -> next state (-1 = no transition)
	transitions := [13][128]int{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, 10, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, -1, -1, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, 10, -1, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}}
	// Tag registers for capture positions
	tags := [10]int{}
	for i := range tags {
		tags[i] = -1
	}
	// Tag actions per transition
	tagActions := map[int]map[byte][]struct {
		Tag    int
		Offset int
	}{0: {104: {{
		Offset: 1,
		Tag:    2,
	}}}, 4: {58: {{
		Offset: 1,
		Tag:    3,
	}}}, 6: {58: {{
		Offset: 1,
		Tag:    3,
	}}}, 8: {51: {{
		Offset: 1,
		Tag:    4,
	}}, 56: {{
		Offset: 1,
		Tag:    4,
	}}, 85: {{
		Offset: 1,
		Tag:    4,
	}}, 107: {{
		Offset: 1,
		Tag:    4,
	}}, 113: {{
		Offset: 1,
		Tag:    4,
	}}, 120: {{
		Offset: 1,
		Tag:    4,
	}}, 122: {{
		Offset: 1,
		Tag:    4,
	}}, 68: {{
		Offset: 1,
		Tag:    4,
	}}, 100: {{
		Offset: 1,
		Tag:    4,
	}}, 118: {{
		Offset: 1,
		Tag:    4,
	}}, 57: {{
		Offset: 1,
		Tag:    4,
	}}, 79: {{
		Offset: 1,
		Tag:    4,
	}}, 46: {{
		Offset: 1,
		Tag:    4,
	}}, 71: {{
		Offset: 1,
		Tag:    4,
	}}, 76: {{
		Offset: 1,
		Tag:    4,
	}}, 78: {{
		Offset: 1,
		Tag:    4,
	}}, 110: {{
		Offset: 1,
		Tag:    4,
	}}, 119: {{
		Offset: 1,
		Tag:    4,
	}}, 121: {{
		Offset: 1,
		Tag:    4,
	}}, 81: {{
		Offset: 1,
		Tag:    4,
	}}, 95: {{
		Offset: 1,
		Tag:    4,
	}}, 105: {{
		Offset: 1,
		Tag:    4,
	}}, 48: {{
		Offset: 1,
		Tag:    4,
	}}, 49: {{
		Offset: 1,
		Tag:    4,
	}}, 55: {{
		Offset: 1,
		Tag:    4,
	}}, 80: {{
		Offset: 1,
		Tag:    4,
	}}, 97: {{
		Offset: 1,
		Tag:    4,
	}}, 109: {{
		Offset: 1,
		Tag:    4,
	}}, 88: {{
		Offset: 1,
		Tag:    4,
	}}, 52: {{
		Offset: 1,
		Tag:    4,
	}}, 53: {{
		Offset: 1,
		Tag:    4,
	}}, 66: {{
		Offset: 1,
		Tag:    4,
	}}, 102: {{
		Offset: 1,
		Tag:    4,
	}}, 111: {{
		Offset: 1,
		Tag:    4,
	}}, 50: {{
		Offset: 1,
		Tag:    4,
	}}, 77: {{
		Offset: 1,
		Tag:    4,
	}}, 86: {{
		Offset: 1,
		Tag:    4,
	}}, 112: {{
		Offset: 1,
		Tag:    4,
	}}, 54: {{
		Offset: 1,
		Tag:    4,
	}}, 89: {{
		Offset: 1,
		Tag:    4,
	}}, 98: {{
		Offset: 1,
		Tag:    4,
	}}, 101: {{
		Offset: 1,
		Tag:    4,
	}}, 117: {{
		Offset: 1,
		Tag:    4,
	}}, 69: {{
		Offset: 1,
		Tag:    4,
	}}, 75: {{
		Offset: 1,
		Tag:    4,
	}}, 67: {{
		Offset: 1,
		Tag:    4,
	}}, 70: {{
		Offset: 1,
		Tag:    4,
	}}, 82: {{
		Offset: 1,
		Tag:    4,
	}}, 73: {{
		Offset: 1,
		Tag:    4,
	}}, 84: {{
		Offset: 1,
		Tag:    4,
	}}, 90: {{
		Offset: 1,
		Tag:    4,
	}}, 103: {{
		Offset: 1,
		Tag:    4,
	}}, 108: {{
		Offset: 1,
		Tag:    4,
	}}, 115: {{
		Offset: 1,
		Tag:    4,
	}}, 116: {{
		Offset: 1,
		Tag:    4,
	}}, 45: {{
		Offset: 1,
		Tag:    4,
	}}, 65: {{
		Offset: 1,
		Tag:    4,
	}}, 83: {{
		Offset: 1,
		Tag:    4,
	}}, 99: {{
		Offset: 1,
		Tag:    4,
	}}, 114: {{
		Offset: 1,
		Tag:    4,
	}}, 72: {{
		Offset: 1,
		Tag:    4,
	}}, 74: {{
		Offset: 1,
		Tag:    4,
	}}, 87: {{
		Offset: 1,
		Tag:    4,
	}}, 104: {{
		Offset: 1,
		Tag:    4,
	}}, 106: {{
		Offset: 1,
		Tag:    4,
	}}}, 9: {47: {{
		Offset: 1,
		Tag:    5,
	}, {
		Offset: 1,
		Tag:    8,
	}}, 58: {{
		Offset: 1,
		Tag:    5,
	}}}, 11: {52: {{
		Offset: 1,
		Tag:    6,
	}}, 53: {{
		Offset: 1,
		Tag:    6,
	}}, 56: {{
		Offset: 1,
		Tag:    6,
	}}, 51: {{
		Offset: 1,
		Tag:    6,
	}}, 54: {{
		Offset: 1,
		Tag:    6,
	}}, 55: {{
		Offset: 1,
		Tag:    6,
	}}, 57: {{
		Offset: 1,
		Tag:    6,
	}}, 48: {{
		Offset: 1,
		Tag:    6,
	}}, 49: {{
		Offset: 1,
		Tag:    6,
	}}, 50: {{
		Offset: 1,
		Tag:    6,
	}}}, 12: {47: {{
		Offset: 1,
		Tag:    7,
	}, {
		Offset: 1,
		Tag:    8,
	}}}}
	// Accept states array
	acceptStates := [13]bool{false, false, false, false, false, false, false, false, false, true, true, false, true}
	// Accept states array (End of Text)
	acceptStatesEOT := [13]bool{false, false, false, false, false, false, false, false, false, true, true, false, true}
	// Accept actions - tag actions to apply when accepting at each state
	acceptActionsMap := map[int][]struct {
		Tag    int
		Offset int
	}{12: {{
		Offset: 0,
		Tag:    7,
	}}, 9: {{
		Offset: 0,
		Tag:    5,
	}}, 10: {{
		Offset: 0,
		Tag:    9,
	}}}
	state := 0
	matchEnd := -1
	matchTags := [10]int{}
	for i := range matchTags {
		matchTags[i] = -1
	}

	// Iterate over all possible start positions
	for start := 0; start <= l; start++ {
		// Reset tags for this attempt
		for i := range tags {
			tags[i] = -1
		}
		tags[0] = start

		// Choose start state based on position
		if start == 0 {
			state = 0
		} else {
			state = 0
		}

		// Check if start state is accepting (empty match)
		if acceptStates[state] {
			matchEnd = start
			matchTags = tags
		}
		// Check if start state is accepting at EOT
		if start == l && acceptStatesEOT[state] {
			matchEnd = start
			matchTags = tags
		}

		for i := start; i < l; i++ {
			c := input[i]
			if c >= 128 {
				break
			}

			// Look up transition (array-based for speed)
			nextState := transitions[state][c]
			if nextState < 0 {
				break
			}

			// Apply tag actions for this transition
			if stateActions, ok := tagActions[state]; ok {
				if charActions, ok := stateActions[c]; ok {
					for _, action := range charActions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
			}

			state = nextState
			if acceptStates[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
			if i == l-1 && acceptStatesEOT[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
		}

		// If we found a match, return it
		if matchEnd >= 0 {
			matchTags[1] = matchEnd
			var result URLCaptureBytesResult
			if matchTags[0] >= 0 {
				result.Match = input[matchTags[0]:matchTags[1]]
			}
			if matchTags[2] >= 0 {
				if matchTags[3] < 0 {
					matchTags[3] = matchTags[1]
				}
				result.Protocol = input[matchTags[2]:matchTags[3]]
			}
			if matchTags[4] >= 0 {
				if matchTags[5] < 0 {
					matchTags[5] = matchTags[1]
				}
				result.Host = input[matchTags[4]:matchTags[5]]
			}
			if matchTags[6] >= 0 {
				if matchTags[7] < 0 {
					matchTags[7] = matchTags[1]
				}
				result.Port = input[matchTags[6]:matchTags[7]]
			}
			if matchTags[8] >= 0 {
				if matchTags[9] < 0 {
					matchTags[9] = matchTags[1]
				}
				result.Path = input[matchTags[8]:matchTags[9]]
			}
			return result, true
		}
	}
	return URLCaptureBytesResult{}, false
}
func (URLCapture) FindBytes(input []byte) (*URLCaptureBytesResult, bool) {
	return URLCapture{}.FindBytesReuse(input, nil)
}
func (URLCapture) FindAllString(input string, n int) []*URLCaptureResult {
	if n == 0 {
		return nil
	}
	var results []*URLCaptureResult
	offset := 0
	for offset < len(input) {
		result, ok := URLCapture{}.FindString(input[offset:])
		if !ok {
			break
		}
		results = append(results, result)
		if n > 0 && len(results) >= n {
			break
		}
		// Move past this match
		matchLen := len(result.Match)
		if matchLen > 0 {
			offset += matchLen
		} else {
			offset++
		}
	}
	return results
}
func (URLCapture) FindAllBytes(input []byte, n int) []*URLCaptureBytesResult {
	if n == 0 {
		return nil
	}
	var results []*URLCaptureBytesResult
	offset := 0
	for offset < len(input) {
		result, ok := URLCapture{}.FindBytes(input[offset:])
		if !ok {
			break
		}
		results = append(results, result)
		if n > 0 && len(results) >= n {
			break
		}
		// Move past this match
		matchLen := len(result.Match)
		if matchLen > 0 {
			offset += matchLen
		} else {
			offset++
		}
	}
	return results
}

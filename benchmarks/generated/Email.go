package generated

import "sync"

// Code generated by regengo for pattern: [\w\.+-]+@[\w\.-]+\.[\w\.-]+
// DO NOT EDIT.

var emailStackPool = sync.Pool{New: func() interface{} {
	stack := make([][2]int, 0, 32)
	return &stack
}}

func EmailMatchString(input string) bool {
	l := len(input)
	offset := 0
	stackPtr := emailStackPool.Get().(*[][2]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [2]int{0, 0}
		}
		*stackPtr = stack[:0]
		emailStackPool.Put(stackPtr)
	}()
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2b) && (input[offset] < uint8(0x2d) || input[offset] > uint8(0x2e)) && (input[offset] < uint8(0x30) || input[offset] > uint8(0x39)) && (input[offset] < uint8(0x41) || input[offset] > uint8(0x5a)) && input[offset] != uint8(0x5f) && (input[offset] < uint8(0x61) || input[offset] > uint8(0x7a)) {
			goto TryFallback
		}
		offset++
		goto Ins2
	}
Ins2:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 3
		} else {
			stack = append(stack, [2]int{offset, 3})
		}
		goto Ins1
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < uint8(0x2d) || input[offset] > uint8(0x2e)) && (input[offset] < uint8(0x30) || input[offset] > uint8(0x39)) && (input[offset] < uint8(0x41) || input[offset] > uint8(0x5a)) && input[offset] != uint8(0x5f) && (input[offset] < uint8(0x61) || input[offset] > uint8(0x7a)) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 6
		} else {
			stack = append(stack, [2]int{offset, 6})
		}
		goto Ins4
	}
Ins6:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < uint8(0x2d) || input[offset] > uint8(0x2e)) && (input[offset] < uint8(0x30) || input[offset] > uint8(0x39)) && (input[offset] < uint8(0x41) || input[offset] > uint8(0x5a)) && input[offset] != uint8(0x5f) && (input[offset] < uint8(0x61) || input[offset] > uint8(0x7a)) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 9
		} else {
			stack = append(stack, [2]int{offset, 9})
		}
		goto Ins7
	}
Ins9:
	{
		return true
	}
}
func EmailMatchBytes(input []byte) bool {
	l := len(input)
	offset := 0
	stackPtr := emailStackPool.Get().(*[][2]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [2]int{0, 0}
		}
		*stackPtr = stack[:0]
		emailStackPool.Put(stackPtr)
	}()
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2b) && (input[offset] < uint8(0x2d) || input[offset] > uint8(0x2e)) && (input[offset] < uint8(0x30) || input[offset] > uint8(0x39)) && (input[offset] < uint8(0x41) || input[offset] > uint8(0x5a)) && input[offset] != uint8(0x5f) && (input[offset] < uint8(0x61) || input[offset] > uint8(0x7a)) {
			goto TryFallback
		}
		offset++
		goto Ins2
	}
Ins2:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 3
		} else {
			stack = append(stack, [2]int{offset, 3})
		}
		goto Ins1
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < uint8(0x2d) || input[offset] > uint8(0x2e)) && (input[offset] < uint8(0x30) || input[offset] > uint8(0x39)) && (input[offset] < uint8(0x41) || input[offset] > uint8(0x5a)) && input[offset] != uint8(0x5f) && (input[offset] < uint8(0x61) || input[offset] > uint8(0x7a)) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 6
		} else {
			stack = append(stack, [2]int{offset, 6})
		}
		goto Ins4
	}
Ins6:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < uint8(0x2d) || input[offset] > uint8(0x2e)) && (input[offset] < uint8(0x30) || input[offset] > uint8(0x39)) && (input[offset] < uint8(0x41) || input[offset] > uint8(0x5a)) && input[offset] != uint8(0x5f) && (input[offset] < uint8(0x61) || input[offset] > uint8(0x7a)) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 9
		} else {
			stack = append(stack, [2]int{offset, 9})
		}
		goto Ins7
	}
Ins9:
	{
		return true
	}
}

package generated

// Code generated by regengo for pattern: (?P<year>\d{4})-(?P<month>\d{2})-(?P<day>\d{2})
// DO NOT EDIT.

type DateCapture struct{}

var CompiledDateCapture = DateCapture{}

func (DateCapture) MatchString(input string) bool {
	l := len(input)
	offset := 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		nextInstruction = 1
		offset++
		goto StepSelect
	}
	return false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		goto Ins9
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		goto Ins12
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		goto Ins14
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		goto Ins17
	}
Ins17:
	{
		return true
	}
}
func (DateCapture) MatchBytes(input []byte) bool {
	l := len(input)
	offset := 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		nextInstruction = 1
		offset++
		goto StepSelect
	}
	return false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		goto Ins9
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		goto Ins12
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		goto Ins14
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		goto Ins17
	}
Ins17:
	{
		return true
	}
}

type DateCaptureResult struct {
	Match string // Full match
	Year  string
	Month string
	Day   string
}

type DateCaptureBytesResult struct {
	Match []byte // Full match
	Year  []byte
	Month []byte
	Day   []byte
}

func (DateCapture) FindString(input string) (*DateCaptureResult, bool) {
	l := len(input)
	offset := 0
	captures := make([]int, 8)
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		offset++
		for i := range captures {
			captures[i] = 0
		}
		captures[0] = offset
		nextInstruction = 1
		goto StepSelect
	}
	return nil, false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[3] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		captures[4] = offset
		nextInstruction = 9
		goto StepSelect
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[5] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		captures[6] = offset
		nextInstruction = 14
		goto StepSelect
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		captures[7] = offset
		nextInstruction = 17
		goto StepSelect
	}
Ins17:
	{
		captures[1] = offset
		return &DateCaptureResult{
			Day: func() string {
				if captures[6] <= captures[7] && captures[7] <= len(input) {
					return string(input[captures[6]:captures[7]])
				}
				return ""
			}(),
			Match: string(input[captures[0]:captures[1]]),
			Month: func() string {
				if captures[4] <= captures[5] && captures[5] <= len(input) {
					return string(input[captures[4]:captures[5]])
				}
				return ""
			}(),
			Year: func() string {
				if captures[2] <= captures[3] && captures[3] <= len(input) {
					return string(input[captures[2]:captures[3]])
				}
				return ""
			}(),
		}, true
	}
}
func (DateCapture) FindAllString(input string, n int) []*DateCaptureResult {
	if n == 0 {
		return nil
	}
	var result []*DateCaptureResult
	l := len(input)
	searchStart := 0
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		captures := make([]int, 8)
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		searchStart++
		continue
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		case 16:
			goto Ins16
		case 17:
			goto Ins17
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins4
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captures[3] = offset
			nextInstruction = 7
			goto StepSelect
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			captures[4] = offset
			nextInstruction = 9
			goto StepSelect
		}
	Ins9:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins10
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			captures[5] = offset
			nextInstruction = 12
			goto StepSelect
		}
	Ins12:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins13
		}
	Ins13:
		{
			captures[6] = offset
			nextInstruction = 14
			goto StepSelect
		}
	Ins14:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins15
		}
	Ins15:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins16
		}
	Ins16:
		{
			captures[7] = offset
			nextInstruction = 17
			goto StepSelect
		}
	Ins17:
		{
			captures[1] = offset
			result = append(result, &DateCaptureResult{
				Day: func() string {
					if captures[6] <= captures[7] && captures[7] <= len(input) {
						return string(input[captures[6]:captures[7]])
					}
					return ""
				}(),
				Match: string(input[captures[0]:captures[1]]),
				Month: func() string {
					if captures[4] <= captures[5] && captures[5] <= len(input) {
						return string(input[captures[4]:captures[5]])
					}
					return ""
				}(),
				Year: func() string {
					if captures[2] <= captures[3] && captures[3] <= len(input) {
						return string(input[captures[2]:captures[3]])
					}
					return ""
				}(),
			})
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (DateCapture) FindBytes(input []byte) (*DateCaptureBytesResult, bool) {
	l := len(input)
	offset := 0
	captures := make([]int, 8)
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if l > offset {
		offset++
		for i := range captures {
			captures[i] = 0
		}
		captures[0] = offset
		nextInstruction = 1
		goto StepSelect
	}
	return nil, false
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	case 16:
		goto Ins16
	case 17:
		goto Ins17
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[3] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		captures[4] = offset
		nextInstruction = 9
		goto StepSelect
	}
Ins9:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins10
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[5] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2d) {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		captures[6] = offset
		nextInstruction = 14
		goto StepSelect
	}
Ins14:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins15
	}
Ins15:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
			goto TryFallback
		}
		offset++
		goto Ins16
	}
Ins16:
	{
		captures[7] = offset
		nextInstruction = 17
		goto StepSelect
	}
Ins17:
	{
		captures[1] = offset
		return &DateCaptureBytesResult{
			Day: func() []byte {
				if captures[6] <= captures[7] && captures[7] <= len(input) {
					return input[captures[6]:captures[7]]
				}
				return nil
			}(),
			Match: input[captures[0]:captures[1]],
			Month: func() []byte {
				if captures[4] <= captures[5] && captures[5] <= len(input) {
					return input[captures[4]:captures[5]]
				}
				return nil
			}(),
			Year: func() []byte {
				if captures[2] <= captures[3] && captures[3] <= len(input) {
					return input[captures[2]:captures[3]]
				}
				return nil
			}(),
		}, true
	}
}
func (DateCapture) FindAllBytes(input []byte, n int) []*DateCaptureBytesResult {
	if n == 0 {
		return nil
	}
	var result []*DateCaptureBytesResult
	l := len(input)
	searchStart := 0
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		captures := make([]int, 8)
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		searchStart++
		continue
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		case 12:
			goto Ins12
		case 13:
			goto Ins13
		case 14:
			goto Ins14
		case 15:
			goto Ins15
		case 16:
			goto Ins16
		case 17:
			goto Ins17
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins4
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captures[3] = offset
			nextInstruction = 7
			goto StepSelect
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			captures[4] = offset
			nextInstruction = 9
			goto StepSelect
		}
	Ins9:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins10
		}
	Ins10:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins11
		}
	Ins11:
		{
			captures[5] = offset
			nextInstruction = 12
			goto StepSelect
		}
	Ins12:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2d) {
				goto TryFallback
			}
			offset++
			goto Ins13
		}
	Ins13:
		{
			captures[6] = offset
			nextInstruction = 14
			goto StepSelect
		}
	Ins14:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins15
		}
	Ins15:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || input[offset] > uint8(0x39) {
				goto TryFallback
			}
			offset++
			goto Ins16
		}
	Ins16:
		{
			captures[7] = offset
			nextInstruction = 17
			goto StepSelect
		}
	Ins17:
		{
			captures[1] = offset
			result = append(result, &DateCaptureBytesResult{
				Day: func() []byte {
					if captures[6] <= captures[7] && captures[7] <= len(input) {
						return input[captures[6]:captures[7]]
					}
					return nil
				}(),
				Match: input[captures[0]:captures[1]],
				Month: func() []byte {
					if captures[4] <= captures[5] && captures[5] <= len(input) {
						return input[captures[4]:captures[5]]
					}
					return nil
				}(),
				Year: func() []byte {
					if captures[2] <= captures[3] && captures[3] <= len(input) {
						return input[captures[2]:captures[3]]
					}
					return nil
				}(),
			})
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}

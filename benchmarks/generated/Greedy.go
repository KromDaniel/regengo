package generated

// Code generated by regengo for pattern: (?:(?:a|b)|(?:k)+)*abcd
// DO NOT EDIT.

type Greedy struct{}

var CompiledGreedy = Greedy{}

func (Greedy) MatchString(input string) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x76))
	acceptMask := uint64(uint64(0x400))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := [11]uint64{1: uint64(uint64(0x76)), 2: uint64(uint64(0x7e)), 6: uint64(uint64(0x80)), 7: uint64(uint64(0x100)), 8: uint64(uint64(0x200)), 9: uint64(uint64(0x400))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 1
			if current&uint64(uint64(0x2)) != 0 && (c >= uint8(0x61) && c <= uint8(0x62)) {
				next |= epsilonClosures[1]
			}
			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x6b) {
				next |= epsilonClosures[2]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x61) {
				next |= epsilonClosures[6]
			}
			// State 7
			if current&uint64(uint64(0x80)) != 0 && c == uint8(0x62) {
				next |= epsilonClosures[7]
			}
			// State 8
			if current&uint64(uint64(0x100)) != 0 && c == uint8(0x63) {
				next |= epsilonClosures[8]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x64) {
				next |= epsilonClosures[9]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}
func (Greedy) MatchBytes(input []byte) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x76))
	acceptMask := uint64(uint64(0x400))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := [11]uint64{1: uint64(uint64(0x76)), 2: uint64(uint64(0x7e)), 6: uint64(uint64(0x80)), 7: uint64(uint64(0x100)), 8: uint64(uint64(0x200)), 9: uint64(uint64(0x400))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 1
			if current&uint64(uint64(0x2)) != 0 && (c >= uint8(0x61) && c <= uint8(0x62)) {
				next |= epsilonClosures[1]
			}
			// State 2
			if current&uint64(uint64(0x4)) != 0 && c == uint8(0x6b) {
				next |= epsilonClosures[2]
			}
			// State 6
			if current&uint64(uint64(0x40)) != 0 && c == uint8(0x61) {
				next |= epsilonClosures[6]
			}
			// State 7
			if current&uint64(uint64(0x80)) != 0 && c == uint8(0x62) {
				next |= epsilonClosures[7]
			}
			// State 8
			if current&uint64(uint64(0x100)) != 0 && c == uint8(0x63) {
				next |= epsilonClosures[8]
			}
			// State 9
			if current&uint64(uint64(0x200)) != 0 && c == uint8(0x64) {
				next |= epsilonClosures[9]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}

package generated

import "sync"

// Code generated by regengo for pattern: (?P<major>\d+)\.(?P<minor>\d+)\.(?P<patch>\d+)(?:-(?P<prerelease>[\w.-]+))?(?:\+(?P<build>[\w.-]+))?
// DO NOT EDIT.

var tDFASemVerStackPool = sync.Pool{New: func() interface{} {
	stack := make([][2]int, 0, 32)
	return &stack
}}

type TDFASemVer struct{}

var CompiledTDFASemVer = TDFASemVer{}

func (TDFASemVer) MatchString(input string) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x8000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := map[int]uint64{2: uint64(uint64(0x3c)), 5: uint64(uint64(0xc0)), 7: uint64(uint64(0x780)), 10: uint64(uint64(0x1800)), 12: uint64(uint64(0xc30f000)), 15: uint64(uint64(0x30000)), 17: uint64(uint64(0xc2e0000)), 21: uint64(uint64(0xc00000)), 23: uint64(uint64(0xb800000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[2]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x2e) {
				next |= epsilonClosures[5]
			}
			// State 7
			if current&uint64(uint64(0x80)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[7]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2e) {
				next |= epsilonClosures[10]
			}
			// State 2
			if current&uint64(uint64(0x1000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[12]
			}
			// State 5
			if current&uint64(uint64(0x8000)) != 0 && c == uint8(0x2d) {
				next |= epsilonClosures[15]
			}
			// State 7
			if current&uint64(uint64(0x20000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[17]
			}
			// State 1
			if current&uint64(uint64(0x200000)) != 0 && c == uint8(0x2b) {
				next |= epsilonClosures[21]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[23]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}
func (TDFASemVer) MatchBytes(input []byte) bool {
	l := len(input)
	// Thompson NFA state sets (bitset representation)
	var current uint64
	var next uint64

	// Precomputed constants
	startClosure := uint64(uint64(0x6))
	acceptMask := uint64(uint64(0x8000000))

	// Epsilon closure lookup for next states after character transitions
	epsilonClosures := map[int]uint64{2: uint64(uint64(0x3c)), 5: uint64(uint64(0xc0)), 7: uint64(uint64(0x780)), 10: uint64(uint64(0x1800)), 12: uint64(uint64(0xc30f000)), 15: uint64(uint64(0x30000)), 17: uint64(uint64(0xc2e0000)), 21: uint64(uint64(0xc00000)), 23: uint64(uint64(0xb800000))}

	// Unanchored pattern - try from each starting position
	for searchStart := 0; searchStart <= l; searchStart++ {
		current = startClosure

		// Check immediate match (empty pattern or already at accept)
		if current&acceptMask != 0 {
			return true
		}

		for offset := searchStart; offset < l; offset++ {
			c := input[offset]
			next = 0

			// State 2
			if current&uint64(uint64(0x4)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[2]
			}
			// State 5
			if current&uint64(uint64(0x20)) != 0 && c == uint8(0x2e) {
				next |= epsilonClosures[5]
			}
			// State 7
			if current&uint64(uint64(0x80)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[7]
			}
			// State 0
			if current&uint64(uint64(0x400)) != 0 && c == uint8(0x2e) {
				next |= epsilonClosures[10]
			}
			// State 2
			if current&uint64(uint64(0x1000)) != 0 && (c >= uint8(0x30) && c <= uint8(0x39)) {
				next |= epsilonClosures[12]
			}
			// State 5
			if current&uint64(uint64(0x8000)) != 0 && c == uint8(0x2d) {
				next |= epsilonClosures[15]
			}
			// State 7
			if current&uint64(uint64(0x20000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[17]
			}
			// State 1
			if current&uint64(uint64(0x200000)) != 0 && c == uint8(0x2b) {
				next |= epsilonClosures[21]
			}
			// State 3
			if current&uint64(uint64(0x800000)) != 0 && (((((c >= uint8(0x2d) && c <= uint8(0x2e)) || (c >= uint8(0x30) && c <= uint8(0x39))) || (c >= uint8(0x41) && c <= uint8(0x5a))) || c == uint8(0x5f)) || (c >= uint8(0x61) && c <= uint8(0x7a))) {
				next |= epsilonClosures[23]
			}

			// Update current state set
			current = next

			// Check for dead end
			if current == 0 {
				break
			}

			// Check for match
			if current&acceptMask != 0 {
				return true
			}
		}
	}

	return false
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty string when not matched.

type TDFASemVerResult struct {
	Match      string // Full match
	Major      string
	Minor      string
	Patch      string
	Prerelease string
	Build      string
}

// Note: This pattern contains capture groups in repeating/optional context.
// Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).
// For example: (\w)+ matching 'abc' captures 'c', not ['a','b','c'].
// Optional groups (?) return empty slice when not matched.

type TDFASemVerBytesResult struct {
	Match      []byte // Full match
	Major      []byte
	Minor      []byte
	Patch      []byte
	Prerelease []byte
	Build      []byte
}

func (TDFASemVer) FindStringReuse(input string, r *TDFASemVerResult) (*TDFASemVerResult, bool) {
	result, ok := TDFASemVer{}.findStringInternal(input)
	if !ok {
		return nil, false
	}
	return &result, true
}
func (TDFASemVer) findStringInternal(input string) (TDFASemVerResult, bool) {
	l := len(input)
	// TDFA transition table [state][char] -> next state (-1 = no transition)
	transitions := [10][128]int{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, 7, -1, -1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}}
	// Tag registers for capture positions
	tags := [12]int{}
	for i := range tags {
		tags[i] = -1
	}
	// Tag actions per transition
	tagActions := map[int]map[byte][]struct {
		Tag    int
		Offset int
	}{0: {49: {{
		Offset: 1,
		Tag:    2,
	}}, 50: {{
		Offset: 1,
		Tag:    2,
	}}, 51: {{
		Offset: 1,
		Tag:    2,
	}}, 53: {{
		Offset: 1,
		Tag:    2,
	}}, 56: {{
		Offset: 1,
		Tag:    2,
	}}, 48: {{
		Offset: 1,
		Tag:    2,
	}}, 52: {{
		Offset: 1,
		Tag:    2,
	}}, 54: {{
		Offset: 1,
		Tag:    2,
	}}, 55: {{
		Offset: 1,
		Tag:    2,
	}}, 57: {{
		Offset: 1,
		Tag:    2,
	}}}, 1: {46: {{
		Offset: 1,
		Tag:    3,
	}}}, 2: {49: {{
		Offset: 1,
		Tag:    4,
	}}, 50: {{
		Offset: 1,
		Tag:    4,
	}}, 51: {{
		Offset: 1,
		Tag:    4,
	}}, 52: {{
		Offset: 1,
		Tag:    4,
	}}, 53: {{
		Offset: 1,
		Tag:    4,
	}}, 54: {{
		Offset: 1,
		Tag:    4,
	}}, 55: {{
		Offset: 1,
		Tag:    4,
	}}, 57: {{
		Offset: 1,
		Tag:    4,
	}}, 48: {{
		Offset: 1,
		Tag:    4,
	}}, 56: {{
		Offset: 1,
		Tag:    4,
	}}}, 3: {46: {{
		Offset: 1,
		Tag:    5,
	}}}, 4: {54: {{
		Offset: 1,
		Tag:    6,
	}}, 55: {{
		Offset: 1,
		Tag:    6,
	}}, 56: {{
		Offset: 1,
		Tag:    6,
	}}, 57: {{
		Offset: 1,
		Tag:    6,
	}}, 48: {{
		Offset: 1,
		Tag:    6,
	}}, 51: {{
		Offset: 1,
		Tag:    6,
	}}, 53: {{
		Offset: 1,
		Tag:    6,
	}}, 49: {{
		Offset: 1,
		Tag:    6,
	}}, 50: {{
		Offset: 1,
		Tag:    6,
	}}, 52: {{
		Offset: 1,
		Tag:    6,
	}}}, 5: {43: {{
		Offset: 1,
		Tag:    7,
	}}, 45: {{
		Offset: 1,
		Tag:    7,
	}}}, 6: {51: {{
		Offset: 1,
		Tag:    10,
	}}, 88: {{
		Offset: 1,
		Tag:    10,
	}}, 90: {{
		Offset: 1,
		Tag:    10,
	}}, 98: {{
		Offset: 1,
		Tag:    10,
	}}, 57: {{
		Offset: 1,
		Tag:    10,
	}}, 69: {{
		Offset: 1,
		Tag:    10,
	}}, 102: {{
		Offset: 1,
		Tag:    10,
	}}, 111: {{
		Offset: 1,
		Tag:    10,
	}}, 81: {{
		Offset: 1,
		Tag:    10,
	}}, 84: {{
		Offset: 1,
		Tag:    10,
	}}, 104: {{
		Offset: 1,
		Tag:    10,
	}}, 106: {{
		Offset: 1,
		Tag:    10,
	}}, 107: {{
		Offset: 1,
		Tag:    10,
	}}, 77: {{
		Offset: 1,
		Tag:    10,
	}}, 105: {{
		Offset: 1,
		Tag:    10,
	}}, 113: {{
		Offset: 1,
		Tag:    10,
	}}, 50: {{
		Offset: 1,
		Tag:    10,
	}}, 52: {{
		Offset: 1,
		Tag:    10,
	}}, 56: {{
		Offset: 1,
		Tag:    10,
	}}, 99: {{
		Offset: 1,
		Tag:    10,
	}}, 112: {{
		Offset: 1,
		Tag:    10,
	}}, 86: {{
		Offset: 1,
		Tag:    10,
	}}, 119: {{
		Offset: 1,
		Tag:    10,
	}}, 109: {{
		Offset: 1,
		Tag:    10,
	}}, 54: {{
		Offset: 1,
		Tag:    10,
	}}, 76: {{
		Offset: 1,
		Tag:    10,
	}}, 82: {{
		Offset: 1,
		Tag:    10,
	}}, 118: {{
		Offset: 1,
		Tag:    10,
	}}, 49: {{
		Offset: 1,
		Tag:    10,
	}}, 65: {{
		Offset: 1,
		Tag:    10,
	}}, 75: {{
		Offset: 1,
		Tag:    10,
	}}, 80: {{
		Offset: 1,
		Tag:    10,
	}}, 87: {{
		Offset: 1,
		Tag:    10,
	}}, 114: {{
		Offset: 1,
		Tag:    10,
	}}, 117: {{
		Offset: 1,
		Tag:    10,
	}}, 71: {{
		Offset: 1,
		Tag:    10,
	}}, 78: {{
		Offset: 1,
		Tag:    10,
	}}, 85: {{
		Offset: 1,
		Tag:    10,
	}}, 95: {{
		Offset: 1,
		Tag:    10,
	}}, 97: {{
		Offset: 1,
		Tag:    10,
	}}, 101: {{
		Offset: 1,
		Tag:    10,
	}}, 45: {{
		Offset: 1,
		Tag:    10,
	}}, 55: {{
		Offset: 1,
		Tag:    10,
	}}, 68: {{
		Offset: 1,
		Tag:    10,
	}}, 100: {{
		Offset: 1,
		Tag:    10,
	}}, 66: {{
		Offset: 1,
		Tag:    10,
	}}, 67: {{
		Offset: 1,
		Tag:    10,
	}}, 83: {{
		Offset: 1,
		Tag:    10,
	}}, 110: {{
		Offset: 1,
		Tag:    10,
	}}, 116: {{
		Offset: 1,
		Tag:    10,
	}}, 70: {{
		Offset: 1,
		Tag:    10,
	}}, 79: {{
		Offset: 1,
		Tag:    10,
	}}, 121: {{
		Offset: 1,
		Tag:    10,
	}}, 53: {{
		Offset: 1,
		Tag:    10,
	}}, 72: {{
		Offset: 1,
		Tag:    10,
	}}, 73: {{
		Offset: 1,
		Tag:    10,
	}}, 115: {{
		Offset: 1,
		Tag:    10,
	}}, 46: {{
		Offset: 1,
		Tag:    10,
	}}, 74: {{
		Offset: 1,
		Tag:    10,
	}}, 89: {{
		Offset: 1,
		Tag:    10,
	}}, 103: {{
		Offset: 1,
		Tag:    10,
	}}, 108: {{
		Offset: 1,
		Tag:    10,
	}}, 120: {{
		Offset: 1,
		Tag:    10,
	}}, 48: {{
		Offset: 1,
		Tag:    10,
	}}, 122: {{
		Offset: 1,
		Tag:    10,
	}}}, 7: {49: {{
		Offset: 1,
		Tag:    8,
	}}, 65: {{
		Offset: 1,
		Tag:    8,
	}}, 72: {{
		Offset: 1,
		Tag:    8,
	}}, 74: {{
		Offset: 1,
		Tag:    8,
	}}, 117: {{
		Offset: 1,
		Tag:    8,
	}}, 116: {{
		Offset: 1,
		Tag:    8,
	}}, 51: {{
		Offset: 1,
		Tag:    8,
	}}, 52: {{
		Offset: 1,
		Tag:    8,
	}}, 70: {{
		Offset: 1,
		Tag:    8,
	}}, 73: {{
		Offset: 1,
		Tag:    8,
	}}, 88: {{
		Offset: 1,
		Tag:    8,
	}}, 95: {{
		Offset: 1,
		Tag:    8,
	}}, 115: {{
		Offset: 1,
		Tag:    8,
	}}, 71: {{
		Offset: 1,
		Tag:    8,
	}}, 78: {{
		Offset: 1,
		Tag:    8,
	}}, 102: {{
		Offset: 1,
		Tag:    8,
	}}, 106: {{
		Offset: 1,
		Tag:    8,
	}}, 112: {{
		Offset: 1,
		Tag:    8,
	}}, 113: {{
		Offset: 1,
		Tag:    8,
	}}, 48: {{
		Offset: 1,
		Tag:    8,
	}}, 110: {{
		Offset: 1,
		Tag:    8,
	}}, 57: {{
		Offset: 1,
		Tag:    8,
	}}, 76: {{
		Offset: 1,
		Tag:    8,
	}}, 84: {{
		Offset: 1,
		Tag:    8,
	}}, 105: {{
		Offset: 1,
		Tag:    8,
	}}, 108: {{
		Offset: 1,
		Tag:    8,
	}}, 68: {{
		Offset: 1,
		Tag:    8,
	}}, 81: {{
		Offset: 1,
		Tag:    8,
	}}, 82: {{
		Offset: 1,
		Tag:    8,
	}}, 90: {{
		Offset: 1,
		Tag:    8,
	}}, 46: {{
		Offset: 1,
		Tag:    8,
	}}, 103: {{
		Offset: 1,
		Tag:    8,
	}}, 109: {{
		Offset: 1,
		Tag:    8,
	}}, 119: {{
		Offset: 1,
		Tag:    8,
	}}, 45: {{
		Offset: 1,
		Tag:    8,
	}}, 101: {{
		Offset: 1,
		Tag:    8,
	}}, 55: {{
		Offset: 1,
		Tag:    8,
	}}, 75: {{
		Offset: 1,
		Tag:    8,
	}}, 77: {{
		Offset: 1,
		Tag:    8,
	}}, 80: {{
		Offset: 1,
		Tag:    8,
	}}, 86: {{
		Offset: 1,
		Tag:    8,
	}}, 97: {{
		Offset: 1,
		Tag:    8,
	}}, 122: {{
		Offset: 1,
		Tag:    8,
	}}, 69: {{
		Offset: 1,
		Tag:    8,
	}}, 89: {{
		Offset: 1,
		Tag:    8,
	}}, 87: {{
		Offset: 1,
		Tag:    8,
	}}, 118: {{
		Offset: 1,
		Tag:    8,
	}}, 67: {{
		Offset: 1,
		Tag:    8,
	}}, 99: {{
		Offset: 1,
		Tag:    8,
	}}, 100: {{
		Offset: 1,
		Tag:    8,
	}}, 107: {{
		Offset: 1,
		Tag:    8,
	}}, 111: {{
		Offset: 1,
		Tag:    8,
	}}, 50: {{
		Offset: 1,
		Tag:    8,
	}}, 53: {{
		Offset: 1,
		Tag:    8,
	}}, 66: {{
		Offset: 1,
		Tag:    8,
	}}, 114: {{
		Offset: 1,
		Tag:    8,
	}}, 56: {{
		Offset: 1,
		Tag:    8,
	}}, 83: {{
		Offset: 1,
		Tag:    8,
	}}, 85: {{
		Offset: 1,
		Tag:    8,
	}}, 121: {{
		Offset: 1,
		Tag:    8,
	}}, 54: {{
		Offset: 1,
		Tag:    8,
	}}, 79: {{
		Offset: 1,
		Tag:    8,
	}}, 98: {{
		Offset: 1,
		Tag:    8,
	}}, 104: {{
		Offset: 1,
		Tag:    8,
	}}, 120: {{
		Offset: 1,
		Tag:    8,
	}}}, 9: {43: {{
		Offset: 1,
		Tag:    9,
	}}}}
	// Accept states array
	acceptStates := [10]bool{false, false, false, false, false, true, false, false, true, true}
	// Accept states array (End of Text)
	acceptStatesEOT := [10]bool{false, false, false, false, false, true, false, false, true, true}
	// Accept actions - tag actions to apply when accepting at each state
	acceptActionsMap := map[int][]struct {
		Tag    int
		Offset int
	}{5: {{
		Offset: 0,
		Tag:    7,
	}}, 8: {{
		Offset: 0,
		Tag:    11,
	}}, 9: {{
		Offset: 0,
		Tag:    9,
	}}}
	state := 0
	matchEnd := -1
	matchTags := [12]int{}
	for i := range matchTags {
		matchTags[i] = -1
	}

	// Iterate over all possible start positions
	for start := 0; start <= l; start++ {
		// Reset tags for this attempt
		for i := range tags {
			tags[i] = -1
		}
		tags[0] = start

		// Choose start state based on position
		if start == 0 {
			state = 0
		} else {
			state = 0
		}

		// Check if start state is accepting (empty match)
		if acceptStates[state] {
			matchEnd = start
			matchTags = tags
		}
		// Check if start state is accepting at EOT
		if start == l && acceptStatesEOT[state] {
			matchEnd = start
			matchTags = tags
		}

		for i := start; i < l; i++ {
			c := input[i]
			if c >= 128 {
				break
			}

			// Look up transition (array-based for speed)
			nextState := transitions[state][c]
			if nextState < 0 {
				break
			}

			// Apply tag actions for this transition
			if stateActions, ok := tagActions[state]; ok {
				if charActions, ok := stateActions[c]; ok {
					for _, action := range charActions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
			}

			state = nextState
			if acceptStates[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
			if i == l-1 && acceptStatesEOT[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
		}

		// If we found a match, return it
		if matchEnd >= 0 {
			matchTags[1] = matchEnd
			var result TDFASemVerResult
			if matchTags[0] >= 0 {
				result.Match = input[matchTags[0]:matchTags[1]]
			}
			if matchTags[2] >= 0 {
				if matchTags[3] < 0 {
					matchTags[3] = matchTags[1]
				}
				result.Major = input[matchTags[2]:matchTags[3]]
			}
			if matchTags[4] >= 0 {
				if matchTags[5] < 0 {
					matchTags[5] = matchTags[1]
				}
				result.Minor = input[matchTags[4]:matchTags[5]]
			}
			if matchTags[6] >= 0 {
				if matchTags[7] < 0 {
					matchTags[7] = matchTags[1]
				}
				result.Patch = input[matchTags[6]:matchTags[7]]
			}
			if matchTags[8] >= 0 {
				if matchTags[9] < 0 {
					matchTags[9] = matchTags[1]
				}
				result.Prerelease = input[matchTags[8]:matchTags[9]]
			}
			if matchTags[10] >= 0 {
				if matchTags[11] < 0 {
					matchTags[11] = matchTags[1]
				}
				result.Build = input[matchTags[10]:matchTags[11]]
			}
			return result, true
		}
	}
	return TDFASemVerResult{}, false
}
func (TDFASemVer) FindString(input string) (*TDFASemVerResult, bool) {
	return TDFASemVer{}.FindStringReuse(input, nil)
}
func (TDFASemVer) FindBytesReuse(input []byte, r *TDFASemVerBytesResult) (*TDFASemVerBytesResult, bool) {
	result, ok := TDFASemVer{}.findBytesInternal(input)
	if !ok {
		return nil, false
	}
	return &result, true
}
func (TDFASemVer) findBytesInternal(input []byte) (TDFASemVerBytesResult, bool) {
	l := len(input)
	// TDFA transition table [state][char] -> next state (-1 = no transition)
	transitions := [10][128]int{{-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, 7, -1, -1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1, -1, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, 8, -1, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, -1, -1, -1, -1, -1}, {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 6, -1, 9, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1, -1, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, 9, -1, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, -1, -1, -1, -1, -1}}
	// Tag registers for capture positions
	tags := [12]int{}
	for i := range tags {
		tags[i] = -1
	}
	// Tag actions per transition
	tagActions := map[int]map[byte][]struct {
		Tag    int
		Offset int
	}{0: {51: {{
		Offset: 1,
		Tag:    2,
	}}, 53: {{
		Offset: 1,
		Tag:    2,
	}}, 56: {{
		Offset: 1,
		Tag:    2,
	}}, 48: {{
		Offset: 1,
		Tag:    2,
	}}, 52: {{
		Offset: 1,
		Tag:    2,
	}}, 54: {{
		Offset: 1,
		Tag:    2,
	}}, 55: {{
		Offset: 1,
		Tag:    2,
	}}, 57: {{
		Offset: 1,
		Tag:    2,
	}}, 49: {{
		Offset: 1,
		Tag:    2,
	}}, 50: {{
		Offset: 1,
		Tag:    2,
	}}}, 1: {46: {{
		Offset: 1,
		Tag:    3,
	}}}, 2: {48: {{
		Offset: 1,
		Tag:    4,
	}}, 56: {{
		Offset: 1,
		Tag:    4,
	}}, 49: {{
		Offset: 1,
		Tag:    4,
	}}, 50: {{
		Offset: 1,
		Tag:    4,
	}}, 51: {{
		Offset: 1,
		Tag:    4,
	}}, 52: {{
		Offset: 1,
		Tag:    4,
	}}, 53: {{
		Offset: 1,
		Tag:    4,
	}}, 54: {{
		Offset: 1,
		Tag:    4,
	}}, 55: {{
		Offset: 1,
		Tag:    4,
	}}, 57: {{
		Offset: 1,
		Tag:    4,
	}}}, 3: {46: {{
		Offset: 1,
		Tag:    5,
	}}}, 4: {49: {{
		Offset: 1,
		Tag:    6,
	}}, 50: {{
		Offset: 1,
		Tag:    6,
	}}, 52: {{
		Offset: 1,
		Tag:    6,
	}}, 54: {{
		Offset: 1,
		Tag:    6,
	}}, 55: {{
		Offset: 1,
		Tag:    6,
	}}, 56: {{
		Offset: 1,
		Tag:    6,
	}}, 57: {{
		Offset: 1,
		Tag:    6,
	}}, 48: {{
		Offset: 1,
		Tag:    6,
	}}, 51: {{
		Offset: 1,
		Tag:    6,
	}}, 53: {{
		Offset: 1,
		Tag:    6,
	}}}, 5: {43: {{
		Offset: 1,
		Tag:    7,
	}}, 45: {{
		Offset: 1,
		Tag:    7,
	}}}, 6: {85: {{
		Offset: 1,
		Tag:    10,
	}}, 95: {{
		Offset: 1,
		Tag:    10,
	}}, 97: {{
		Offset: 1,
		Tag:    10,
	}}, 101: {{
		Offset: 1,
		Tag:    10,
	}}, 45: {{
		Offset: 1,
		Tag:    10,
	}}, 55: {{
		Offset: 1,
		Tag:    10,
	}}, 68: {{
		Offset: 1,
		Tag:    10,
	}}, 100: {{
		Offset: 1,
		Tag:    10,
	}}, 66: {{
		Offset: 1,
		Tag:    10,
	}}, 67: {{
		Offset: 1,
		Tag:    10,
	}}, 83: {{
		Offset: 1,
		Tag:    10,
	}}, 110: {{
		Offset: 1,
		Tag:    10,
	}}, 116: {{
		Offset: 1,
		Tag:    10,
	}}, 70: {{
		Offset: 1,
		Tag:    10,
	}}, 79: {{
		Offset: 1,
		Tag:    10,
	}}, 121: {{
		Offset: 1,
		Tag:    10,
	}}, 53: {{
		Offset: 1,
		Tag:    10,
	}}, 72: {{
		Offset: 1,
		Tag:    10,
	}}, 73: {{
		Offset: 1,
		Tag:    10,
	}}, 115: {{
		Offset: 1,
		Tag:    10,
	}}, 46: {{
		Offset: 1,
		Tag:    10,
	}}, 74: {{
		Offset: 1,
		Tag:    10,
	}}, 89: {{
		Offset: 1,
		Tag:    10,
	}}, 103: {{
		Offset: 1,
		Tag:    10,
	}}, 108: {{
		Offset: 1,
		Tag:    10,
	}}, 120: {{
		Offset: 1,
		Tag:    10,
	}}, 48: {{
		Offset: 1,
		Tag:    10,
	}}, 122: {{
		Offset: 1,
		Tag:    10,
	}}, 51: {{
		Offset: 1,
		Tag:    10,
	}}, 88: {{
		Offset: 1,
		Tag:    10,
	}}, 90: {{
		Offset: 1,
		Tag:    10,
	}}, 98: {{
		Offset: 1,
		Tag:    10,
	}}, 57: {{
		Offset: 1,
		Tag:    10,
	}}, 69: {{
		Offset: 1,
		Tag:    10,
	}}, 102: {{
		Offset: 1,
		Tag:    10,
	}}, 111: {{
		Offset: 1,
		Tag:    10,
	}}, 81: {{
		Offset: 1,
		Tag:    10,
	}}, 84: {{
		Offset: 1,
		Tag:    10,
	}}, 104: {{
		Offset: 1,
		Tag:    10,
	}}, 106: {{
		Offset: 1,
		Tag:    10,
	}}, 107: {{
		Offset: 1,
		Tag:    10,
	}}, 77: {{
		Offset: 1,
		Tag:    10,
	}}, 105: {{
		Offset: 1,
		Tag:    10,
	}}, 113: {{
		Offset: 1,
		Tag:    10,
	}}, 50: {{
		Offset: 1,
		Tag:    10,
	}}, 52: {{
		Offset: 1,
		Tag:    10,
	}}, 56: {{
		Offset: 1,
		Tag:    10,
	}}, 99: {{
		Offset: 1,
		Tag:    10,
	}}, 112: {{
		Offset: 1,
		Tag:    10,
	}}, 86: {{
		Offset: 1,
		Tag:    10,
	}}, 119: {{
		Offset: 1,
		Tag:    10,
	}}, 109: {{
		Offset: 1,
		Tag:    10,
	}}, 54: {{
		Offset: 1,
		Tag:    10,
	}}, 76: {{
		Offset: 1,
		Tag:    10,
	}}, 82: {{
		Offset: 1,
		Tag:    10,
	}}, 118: {{
		Offset: 1,
		Tag:    10,
	}}, 49: {{
		Offset: 1,
		Tag:    10,
	}}, 65: {{
		Offset: 1,
		Tag:    10,
	}}, 75: {{
		Offset: 1,
		Tag:    10,
	}}, 80: {{
		Offset: 1,
		Tag:    10,
	}}, 87: {{
		Offset: 1,
		Tag:    10,
	}}, 114: {{
		Offset: 1,
		Tag:    10,
	}}, 117: {{
		Offset: 1,
		Tag:    10,
	}}, 71: {{
		Offset: 1,
		Tag:    10,
	}}, 78: {{
		Offset: 1,
		Tag:    10,
	}}}, 7: {71: {{
		Offset: 1,
		Tag:    8,
	}}, 78: {{
		Offset: 1,
		Tag:    8,
	}}, 102: {{
		Offset: 1,
		Tag:    8,
	}}, 106: {{
		Offset: 1,
		Tag:    8,
	}}, 112: {{
		Offset: 1,
		Tag:    8,
	}}, 113: {{
		Offset: 1,
		Tag:    8,
	}}, 48: {{
		Offset: 1,
		Tag:    8,
	}}, 110: {{
		Offset: 1,
		Tag:    8,
	}}, 57: {{
		Offset: 1,
		Tag:    8,
	}}, 76: {{
		Offset: 1,
		Tag:    8,
	}}, 84: {{
		Offset: 1,
		Tag:    8,
	}}, 105: {{
		Offset: 1,
		Tag:    8,
	}}, 108: {{
		Offset: 1,
		Tag:    8,
	}}, 68: {{
		Offset: 1,
		Tag:    8,
	}}, 81: {{
		Offset: 1,
		Tag:    8,
	}}, 82: {{
		Offset: 1,
		Tag:    8,
	}}, 90: {{
		Offset: 1,
		Tag:    8,
	}}, 46: {{
		Offset: 1,
		Tag:    8,
	}}, 103: {{
		Offset: 1,
		Tag:    8,
	}}, 109: {{
		Offset: 1,
		Tag:    8,
	}}, 119: {{
		Offset: 1,
		Tag:    8,
	}}, 45: {{
		Offset: 1,
		Tag:    8,
	}}, 101: {{
		Offset: 1,
		Tag:    8,
	}}, 55: {{
		Offset: 1,
		Tag:    8,
	}}, 75: {{
		Offset: 1,
		Tag:    8,
	}}, 77: {{
		Offset: 1,
		Tag:    8,
	}}, 80: {{
		Offset: 1,
		Tag:    8,
	}}, 86: {{
		Offset: 1,
		Tag:    8,
	}}, 97: {{
		Offset: 1,
		Tag:    8,
	}}, 122: {{
		Offset: 1,
		Tag:    8,
	}}, 69: {{
		Offset: 1,
		Tag:    8,
	}}, 89: {{
		Offset: 1,
		Tag:    8,
	}}, 87: {{
		Offset: 1,
		Tag:    8,
	}}, 118: {{
		Offset: 1,
		Tag:    8,
	}}, 67: {{
		Offset: 1,
		Tag:    8,
	}}, 99: {{
		Offset: 1,
		Tag:    8,
	}}, 100: {{
		Offset: 1,
		Tag:    8,
	}}, 107: {{
		Offset: 1,
		Tag:    8,
	}}, 111: {{
		Offset: 1,
		Tag:    8,
	}}, 50: {{
		Offset: 1,
		Tag:    8,
	}}, 53: {{
		Offset: 1,
		Tag:    8,
	}}, 66: {{
		Offset: 1,
		Tag:    8,
	}}, 114: {{
		Offset: 1,
		Tag:    8,
	}}, 56: {{
		Offset: 1,
		Tag:    8,
	}}, 83: {{
		Offset: 1,
		Tag:    8,
	}}, 85: {{
		Offset: 1,
		Tag:    8,
	}}, 121: {{
		Offset: 1,
		Tag:    8,
	}}, 54: {{
		Offset: 1,
		Tag:    8,
	}}, 79: {{
		Offset: 1,
		Tag:    8,
	}}, 98: {{
		Offset: 1,
		Tag:    8,
	}}, 104: {{
		Offset: 1,
		Tag:    8,
	}}, 120: {{
		Offset: 1,
		Tag:    8,
	}}, 49: {{
		Offset: 1,
		Tag:    8,
	}}, 65: {{
		Offset: 1,
		Tag:    8,
	}}, 72: {{
		Offset: 1,
		Tag:    8,
	}}, 74: {{
		Offset: 1,
		Tag:    8,
	}}, 117: {{
		Offset: 1,
		Tag:    8,
	}}, 116: {{
		Offset: 1,
		Tag:    8,
	}}, 51: {{
		Offset: 1,
		Tag:    8,
	}}, 52: {{
		Offset: 1,
		Tag:    8,
	}}, 70: {{
		Offset: 1,
		Tag:    8,
	}}, 73: {{
		Offset: 1,
		Tag:    8,
	}}, 88: {{
		Offset: 1,
		Tag:    8,
	}}, 95: {{
		Offset: 1,
		Tag:    8,
	}}, 115: {{
		Offset: 1,
		Tag:    8,
	}}}, 9: {43: {{
		Offset: 1,
		Tag:    9,
	}}}}
	// Accept states array
	acceptStates := [10]bool{false, false, false, false, false, true, false, false, true, true}
	// Accept states array (End of Text)
	acceptStatesEOT := [10]bool{false, false, false, false, false, true, false, false, true, true}
	// Accept actions - tag actions to apply when accepting at each state
	acceptActionsMap := map[int][]struct {
		Tag    int
		Offset int
	}{5: {{
		Offset: 0,
		Tag:    7,
	}}, 8: {{
		Offset: 0,
		Tag:    11,
	}}, 9: {{
		Offset: 0,
		Tag:    9,
	}}}
	state := 0
	matchEnd := -1
	matchTags := [12]int{}
	for i := range matchTags {
		matchTags[i] = -1
	}

	// Iterate over all possible start positions
	for start := 0; start <= l; start++ {
		// Reset tags for this attempt
		for i := range tags {
			tags[i] = -1
		}
		tags[0] = start

		// Choose start state based on position
		if start == 0 {
			state = 0
		} else {
			state = 0
		}

		// Check if start state is accepting (empty match)
		if acceptStates[state] {
			matchEnd = start
			matchTags = tags
		}
		// Check if start state is accepting at EOT
		if start == l && acceptStatesEOT[state] {
			matchEnd = start
			matchTags = tags
		}

		for i := start; i < l; i++ {
			c := input[i]
			if c >= 128 {
				break
			}

			// Look up transition (array-based for speed)
			nextState := transitions[state][c]
			if nextState < 0 {
				break
			}

			// Apply tag actions for this transition
			if stateActions, ok := tagActions[state]; ok {
				if charActions, ok := stateActions[c]; ok {
					for _, action := range charActions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
			}

			state = nextState
			if acceptStates[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
			if i == l-1 && acceptStatesEOT[state] {
				if actions, ok := acceptActionsMap[state]; ok {
					for _, action := range actions {
						tags[action.Tag] = i + 1 - action.Offset
					}
				}
				matchEnd = i + 1
				matchTags = tags
			}
		}

		// If we found a match, return it
		if matchEnd >= 0 {
			matchTags[1] = matchEnd
			var result TDFASemVerBytesResult
			if matchTags[0] >= 0 {
				result.Match = input[matchTags[0]:matchTags[1]]
			}
			if matchTags[2] >= 0 {
				if matchTags[3] < 0 {
					matchTags[3] = matchTags[1]
				}
				result.Major = input[matchTags[2]:matchTags[3]]
			}
			if matchTags[4] >= 0 {
				if matchTags[5] < 0 {
					matchTags[5] = matchTags[1]
				}
				result.Minor = input[matchTags[4]:matchTags[5]]
			}
			if matchTags[6] >= 0 {
				if matchTags[7] < 0 {
					matchTags[7] = matchTags[1]
				}
				result.Patch = input[matchTags[6]:matchTags[7]]
			}
			if matchTags[8] >= 0 {
				if matchTags[9] < 0 {
					matchTags[9] = matchTags[1]
				}
				result.Prerelease = input[matchTags[8]:matchTags[9]]
			}
			if matchTags[10] >= 0 {
				if matchTags[11] < 0 {
					matchTags[11] = matchTags[1]
				}
				result.Build = input[matchTags[10]:matchTags[11]]
			}
			return result, true
		}
	}
	return TDFASemVerBytesResult{}, false
}
func (TDFASemVer) FindBytes(input []byte) (*TDFASemVerBytesResult, bool) {
	return TDFASemVer{}.FindBytesReuse(input, nil)
}
func (TDFASemVer) FindAllString(input string, n int) []*TDFASemVerResult {
	if n == 0 {
		return nil
	}
	var results []*TDFASemVerResult
	offset := 0
	for offset < len(input) {
		result, ok := TDFASemVer{}.FindString(input[offset:])
		if !ok {
			break
		}
		results = append(results, result)
		if n > 0 && len(results) >= n {
			break
		}
		// Move past this match
		matchLen := len(result.Match)
		if matchLen > 0 {
			offset += matchLen
		} else {
			offset++
		}
	}
	return results
}
func (TDFASemVer) FindAllBytes(input []byte, n int) []*TDFASemVerBytesResult {
	if n == 0 {
		return nil
	}
	var results []*TDFASemVerBytesResult
	offset := 0
	for offset < len(input) {
		result, ok := TDFASemVer{}.FindBytes(input[offset:])
		if !ok {
			break
		}
		results = append(results, result)
		if n > 0 && len(results) >= n {
			break
		}
		// Move past this match
		matchLen := len(result.Match)
		if matchLen > 0 {
			offset += matchLen
		} else {
			offset++
		}
	}
	return results
}

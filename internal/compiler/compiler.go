// Package compiler implements the core regex compilation logic.
package compiler

import (
	"fmt"
	"go/format"
	"os"
	"regexp/syntax"

	"github.com/KromDaniel/regengo/internal/codegen"
	"github.com/dave/jennifer/jen"
)

// Config holds the configuration for code generation.
type Config struct {
	Pattern          string
	Name             string
	OutputFile       string
	Package          string
	Program          *syntax.Prog
	RegexAST         *syntax.Regexp // For extracting capture group names
	UsePool          bool           // Enable sync.Pool for stack reuse
	WithCaptures     bool           // Generate capture group functions
	GenerateTestFile bool           // Generate test file with tests and benchmarks
	TestFileInputs   []string       // Test inputs for generated test file
}

// Compiler generates optimized Go code from regex patterns.
type Compiler struct {
	config               Config
	file                 *jen.File
	captureNames         []string // Capture group names (empty string for unnamed groups)
	hasRepeatingCaptures bool     // True if any capture groups are in repeating context
	needsBacktracking    bool     // True if the program contains alternation instructions
	generatingCaptures   bool     // True when generating Find* functions (needs capture checkpoints)
	isAnchored           bool     // True if the pattern is anchored to the start of text
	generatingBytes      bool     // True when generating Bytes functions (affects type generation)
	useMemoization       bool     // True if complexity analysis suggests using memoization
}

// New creates a new compiler instance.
func New(config Config) *Compiler {
	compiler := &Compiler{
		config: config,
		file:   jen.NewFile(config.Package),
	}

	// Extract capture group names if WithCaptures is enabled
	if config.WithCaptures && config.RegexAST != nil {
		compiler.captureNames = extractCaptureNames(config.RegexAST)
		compiler.hasRepeatingCaptures = hasRepeatingCaptures(config.RegexAST)
	}

	// Check if the program needs backtracking
	if config.Program != nil {
		compiler.needsBacktracking = needsBacktracking(config.Program)
		compiler.isAnchored = isAnchored(config.Program)
		compiler.useMemoization = detectComplexity(config.Program)
	}

	return compiler
}

// NewCompiler is an alias for New for backward compatibility.
func NewCompiler(config Config) *Compiler {
	return New(config)
}

// SetOutputFile sets the output file path.
func (c *Compiler) SetOutputFile(path string) {
	c.config.OutputFile = path
}

// method returns a jen.Statement for declaring a method on the generated struct.
func (c *Compiler) method(name string) *jen.Statement {
	return c.file.Func().
		Params(jen.Id(c.config.Name)).
		Id(name)
}

// Generate generates the Go code and writes it to the output file.
func (c *Compiler) Generate() error {
	c.file.Comment(fmt.Sprintf("Code generated by regengo for pattern: %s", c.config.Pattern))
	c.file.Comment("DO NOT EDIT.")
	c.file.Line()

	// Add sync.Pool if enabled and backtracking is needed
	if c.config.UsePool && c.needsBacktracking {
		c.generateStackPool()
		if c.config.WithCaptures {
			c.generateCaptureStackPool()
		}
	}

	// Generate the main struct type
	c.file.Type().Id(c.config.Name).Struct()
	c.file.Line()

	// Generate convenience variable for direct usage
	c.file.Var().Id(fmt.Sprintf("Compiled%s", c.config.Name)).Op("=").Id(c.config.Name).Values()
	c.file.Line()

	// Always generate Match functions
	matchStringCode, err := c.generateMatchFunction(false)
	if err != nil {
		return fmt.Errorf("failed to generate match string function: %w", err)
	}

	// Add MatchString method
	c.method("MatchString").
		Params(jen.Id(codegen.InputName).String()).
		Params(jen.Bool()).
		Block(matchStringCode...)

	matchBytesCode, err := c.generateMatchFunction(true)
	if err != nil {
		return fmt.Errorf("failed to generate match bytes function: %w", err)
	}

	// Add MatchBytes method
	c.method("MatchBytes").
		Params(jen.Id(codegen.InputName).Index().Byte()).
		Params(jen.Bool()).
		Block(matchBytesCode...)

	// Generate capture group functions if pattern has captures
	if c.config.WithCaptures {
		if err := c.generateCaptureFunctions(); err != nil {
			return fmt.Errorf("failed to generate capture functions: %w", err)
		}
	}

	// Save to file
	if err := c.file.Save(c.config.OutputFile); err != nil {
		return fmt.Errorf("failed to save file: %w", err)
	}

	// Format the generated file
	if err := formatFile(c.config.OutputFile); err != nil {
		return fmt.Errorf("failed to format file: %w", err)
	}

	// Generate test file if requested
	if c.config.GenerateTestFile {
		if err := c.generateTestFile(); err != nil {
			return fmt.Errorf("failed to generate test file: %w", err)
		}
	}

	return nil
}

// formatFile reads a file, formats it with go/format, and writes it back.
func formatFile(path string) error {
	src, err := os.ReadFile(path)
	if err != nil {
		return err
	}

	formatted, err := format.Source(src)
	if err != nil {
		return err
	}

	return os.WriteFile(path, formatted, 0644)
}

// findRequiredPrefix scans the program to find a required starting byte.
// Returns the byte and true if found, 0 and false otherwise.
func (c *Compiler) findRequiredPrefix() (byte, bool) {
	pc := c.config.Program.Start
	for {
		inst := c.config.Program.Inst[pc]
		switch inst.Op {
		case syntax.InstNop, syntax.InstCapture:
			pc = int(inst.Out)
			continue
		case syntax.InstRune1:
			// Found a single rune literal
			if len(inst.Rune) == 1 && inst.Rune[0] < 128 {
				return byte(inst.Rune[0]), true
			}
			return 0, false
		default:
			return 0, false
		}
	}
}

// generateMatchFunction generates the main matching logic.
func (c *Compiler) generateMatchFunction(isBytes bool) ([]jen.Code, error) {
	// Set the generatingBytes flag for instruction generation
	c.generatingBytes = isBytes

	prefix, hasPrefix := c.findRequiredPrefix()

	code := []jen.Code{
		// Initialize length
		jen.Id(codegen.InputLenName).Op(":=").Len(jen.Id(codegen.InputName)),
	}

	if hasPrefix && !c.isAnchored {
		var indexCall *jen.Statement
		if isBytes {
			indexCall = jen.Qual("bytes", "IndexByte").Call(jen.Id(codegen.InputName), jen.Lit(byte(prefix)))
		} else {
			indexCall = jen.Qual("strings", "IndexByte").Call(jen.Id(codegen.InputName), jen.Lit(byte(prefix)))
		}

		code = append(code,
			// Fast forward to first occurrence
			jen.Id("idx").Op(":=").Add(indexCall),
			jen.If(jen.Id("idx").Op("==").Lit(-1)).Block(jen.Return(jen.False())),
			jen.Id(codegen.OffsetName).Op(":=").Id("idx"),
		)
	} else {
		code = append(code,
			// Initialize offset
			jen.Id(codegen.OffsetName).Op(":=").Lit(0),
		)
	}

	// Only add stack initialization if backtracking is needed
	if c.needsBacktracking {
		// Add stack initialization (pooled or regular)
		if c.config.UsePool {
			code = append(code, c.generatePooledStackInit()...)
		} else {
			code = append(code,
				jen.Id(codegen.StackName).Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
			)
		}
	}

	// Initialize memoization map if needed (Optimization: Avoid exponential backtracking)
	if c.useMemoization {
		code = append(code,
			jen.Id("visited").Op(":=").Make(jen.Map(jen.Uint64()).Struct()),
		)
	}

	code = append(code,
		// Initialize next instruction
		jen.Id(codegen.NextInstructionName).Op(":=").Lit(int(c.config.Program.Start)),
		// Jump to step selector
		jen.Goto().Id(codegen.StepSelectName),
	)

	// Only add backtracking logic if needed
	if c.needsBacktracking {
		code = append(code, c.generateBacktracking(prefix, hasPrefix, isBytes)...)
	} else {
		// For patterns without backtracking:
		fallback := []jen.Code{jen.Id(codegen.TryFallbackName).Op(":")}

		// If not anchored, we must retry at next offset
		if !c.isAnchored {
			if hasPrefix {
				var indexCall *jen.Statement
				if isBytes {
					indexCall = jen.Qual("bytes", "IndexByte").Call(
						jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName).Op(":")),
						jen.Lit(byte(prefix)),
					)
				} else {
					indexCall = jen.Qual("strings", "IndexByte").Call(
						jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName).Op(":")),
						jen.Lit(byte(prefix)),
					)
				}

				fallback = append(fallback,
					jen.Id(codegen.OffsetName).Op("++"),
					jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
						jen.Id("idx").Op(":=").Add(indexCall),
						jen.If(jen.Id("idx").Op("==").Lit(-1)).Block(jen.Return(jen.False())),
						jen.Id(codegen.OffsetName).Op("+=").Id("idx"),
						jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
						jen.Goto().Id(codegen.StepSelectName),
					),
				)
			} else {
				fallback = append(fallback,
					jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
						jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
						jen.Id(codegen.OffsetName).Op("++"),
						jen.Goto().Id(codegen.StepSelectName),
					),
				)
			}
		}

		fallback = append(fallback, jen.Return(jen.False()))
		code = append(code, fallback...)
	}

	// Add step selector
	code = append(code, c.generateStepSelector()...)

	// Generate instructions
	instructions, err := c.generateInstructions()
	if err != nil {
		return nil, err
	}
	code = append(code, instructions...)

	return code, nil
}

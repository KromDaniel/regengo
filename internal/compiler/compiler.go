// Package compiler implements the core regex compilation logic.
package compiler

import (
	"fmt"
	"regexp/syntax"

	"github.com/KromDaniel/regengo/internal/codegen"
	"github.com/dave/jennifer/jen"
)

// Config holds the configuration for code generation.
type Config struct {
	Pattern          string
	Name             string
	OutputFile       string
	Package          string
	Program          *syntax.Prog
	RegexAST         *syntax.Regexp // For extracting capture group names
	UsePool          bool           // Enable sync.Pool for stack reuse
	WithCaptures     bool           // Generate capture group functions
	BytesView        bool           // Generate separate []byte struct for FindBytes (zero-copy)
	GenerateTestFile bool           // Generate test file with tests and benchmarks
	TestFileInputs   []string       // Test inputs for generated test file
}

// Compiler generates optimized Go code from regex patterns.
type Compiler struct {
	config               Config
	file                 *jen.File
	captureNames         []string // Capture group names (empty string for unnamed groups)
	hasRepeatingCaptures bool     // True if any capture groups are in repeating context
	needsBacktracking    bool     // True if the program contains alternation instructions
	generatingCaptures   bool     // True when generating Find* functions (needs capture checkpoints)
	isAnchored           bool     // True if the pattern is anchored to the start of text
}

// New creates a new compiler instance.
func New(config Config) *Compiler {
	compiler := &Compiler{
		config: config,
		file:   jen.NewFile(config.Package),
	}

	// Extract capture group names if WithCaptures is enabled
	if config.WithCaptures && config.RegexAST != nil {
		compiler.captureNames = extractCaptureNames(config.RegexAST)
		compiler.hasRepeatingCaptures = hasRepeatingCaptures(config.RegexAST)
	}

	// Check if the program needs backtracking
	if config.Program != nil {
		compiler.needsBacktracking = needsBacktracking(config.Program)
		compiler.isAnchored = isAnchored(config.Program)
	}

	return compiler
}

// NewCompiler is an alias for New for backward compatibility.
func NewCompiler(config Config) *Compiler {
	return New(config)
}

// SetOutputFile sets the output file path.
func (c *Compiler) SetOutputFile(path string) {
	c.config.OutputFile = path
}

// Generate generates the Go code and writes it to the output file.
func (c *Compiler) Generate() error {
	c.file.Comment(fmt.Sprintf("Code generated by regengo for pattern: %s", c.config.Pattern))
	c.file.Comment("DO NOT EDIT.")
	c.file.Line()

	// Add sync.Pool if enabled and backtracking is needed
	if c.config.UsePool && c.needsBacktracking {
		c.generateStackPool()
		if c.config.WithCaptures {
			c.generateCaptureStackPool()
		}
	}

	// Always generate Match functions
	matchStringCode, err := c.generateMatchFunction()
	if err != nil {
		return fmt.Errorf("failed to generate match function: %w", err)
	}

	// Add MatchString function
	c.file.Func().
		Id(fmt.Sprintf("%sMatchString", c.config.Name)).
		Params(jen.Id(codegen.InputName).String()).
		Params(jen.Bool()).
		Block(matchStringCode...)

	// Add MatchBytes function
	c.file.Func().
		Id(fmt.Sprintf("%sMatchBytes", c.config.Name)).
		Params(jen.Id(codegen.InputName).Index().Byte()).
		Params(jen.Bool()).
		Block(matchStringCode...)

	// Generate capture group functions if pattern has captures
	if c.config.WithCaptures {
		if err := c.generateCaptureFunctions(); err != nil {
			return fmt.Errorf("failed to generate capture functions: %w", err)
		}
	}

	// Save to file
	if err := c.file.Save(c.config.OutputFile); err != nil {
		return fmt.Errorf("failed to save file: %w", err)
	}

	// Generate test file if requested
	if c.config.GenerateTestFile {
		if err := c.generateTestFile(); err != nil {
			return fmt.Errorf("failed to generate test file: %w", err)
		}
	}

	return nil
}

// generateMatchFunction generates the main matching logic.
func (c *Compiler) generateMatchFunction() ([]jen.Code, error) {
	code := []jen.Code{
		// Initialize length
		jen.Id(codegen.InputLenName).Op(":=").Len(jen.Id(codegen.InputName)),
		// Initialize offset
		jen.Id(codegen.OffsetName).Op(":=").Lit(0),
	}

	// Only add stack initialization if backtracking is needed
	if c.needsBacktracking {
		// Add stack initialization (pooled or regular)
		if c.config.UsePool {
			code = append(code, c.generatePooledStackInit()...)
		} else {
			code = append(code,
				jen.Id(codegen.StackName).Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
			)
		}
	}

	code = append(code,
		// Initialize next instruction
		jen.Id(codegen.NextInstructionName).Op(":=").Lit(int(c.config.Program.Start)),
		// Jump to step selector
		jen.Goto().Id(codegen.StepSelectName),
	)

	// Only add backtracking logic if needed
	if c.needsBacktracking {
		code = append(code, c.generateBacktracking()...)
	} else {
		// For patterns without backtracking:
		fallback := []jen.Code{jen.Id(codegen.TryFallbackName).Op(":")}

		// If not anchored, we must retry at next offset
		if !c.isAnchored {
			fallback = append(fallback,
				jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
					jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
					jen.Id(codegen.OffsetName).Op("++"),
					jen.Goto().Id(codegen.StepSelectName),
				),
			)
		}

		fallback = append(fallback, jen.Return(jen.False()))
		code = append(code, fallback...)
	}

	// Add step selector
	code = append(code, c.generateStepSelector()...)

	// Generate instructions
	instructions, err := c.generateInstructions()
	if err != nil {
		return nil, err
	}
	code = append(code, instructions...)

	return code, nil
}

// generateBacktracking generates the backtracking logic.
func (c *Compiler) generateBacktracking() []jen.Code {
	retryBlock := []jen.Code{}
	// Optimization: If anchored, we don't retry at next offset
	if !c.isAnchored {
		retryBlock = append(retryBlock,
			jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
				jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
				jen.Id(codegen.OffsetName).Op("++"),
				jen.Goto().Id(codegen.StepSelectName),
			),
		)
	}
	retryBlock = append(retryBlock, jen.Return(jen.False()))

	return []jen.Code{
		jen.Id(codegen.TryFallbackName).Op(":"),
		jen.If(jen.Len(jen.Id(codegen.StackName)).Op(">").Lit(0)).Block(
			jen.Id("last").Op(":=").Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Id(codegen.OffsetName).Op("=").Id("last").Index(jen.Lit(0)),
			jen.Id(codegen.NextInstructionName).Op("=").Id("last").Index(jen.Lit(1)),
			jen.Id(codegen.StackName).Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Goto().Id(codegen.StepSelectName),
		).Else().Block(retryBlock...),
	}
}

// generateBacktrackingWithCaptures generates the backtracking logic for capture functions.
// Uses capture checkpointing to avoid resetting all captures on every backtrack.
func (c *Compiler) generateBacktrackingWithCaptures() []jen.Code {
	retryBlock := []jen.Code{}
	// Optimization: If anchored, we don't retry at next offset
	if !c.isAnchored {
		retryBlock = append(retryBlock,
			jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
				jen.Id(codegen.OffsetName).Op("++"),
				// Reset captures array for new match attempt
				jen.For(jen.Id("i").Op(":=").Range().Id(codegen.CapturesName)).Block(
					jen.Id(codegen.CapturesName).Index(jen.Id("i")).Op("=").Lit(0),
				),
				// Clear capture checkpoint stack
				jen.Id("captureStack").Op("=").Id("captureStack").Index(jen.Empty(), jen.Lit(0)),
				// Set capture[0] to mark start of match attempt (after incrementing offset)
				jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op("=").Id(codegen.OffsetName),
				jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
				jen.Goto().Id(codegen.StepSelectName),
			),
		)
	}
	retryBlock = append(retryBlock, jen.Return(jen.Nil(), jen.False()))

	return []jen.Code{
		jen.Id(codegen.TryFallbackName).Op(":"),
		jen.If(jen.Len(jen.Id(codegen.StackName)).Op(">").Lit(0)).Block(
			jen.Id("last").Op(":=").Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Id(codegen.OffsetName).Op("=").Id("last").Index(jen.Lit(0)),
			jen.Id(codegen.NextInstructionName).Op("=").Id("last").Index(jen.Lit(1)),
			jen.Id(codegen.StackName).Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			// Restore capture state from checkpoint stack
			jen.If(jen.Len(jen.Id("captureStack")).Op(">").Lit(0)).Block(
				jen.Id("n").Op(":=").Len(jen.Id(codegen.CapturesName)),
				jen.Id("top").Op(":=").Len(jen.Id("captureStack")).Op("-").Id("n"),
				jen.Copy(jen.Id(codegen.CapturesName), jen.Id("captureStack").Index(jen.Id("top"), jen.Empty())),
				jen.Id("captureStack").Op("=").Id("captureStack").Index(jen.Empty(), jen.Id("top")),
			),
			jen.Goto().Id(codegen.StepSelectName),
		).Else().Block(retryBlock...),
	}
}

// generateStepSelector generates the instruction dispatch switch.
func (c *Compiler) generateStepSelector() []jen.Code {
	cases := []jen.Code{}
	for i := range c.config.Program.Inst {
		cases = append(cases,
			jen.Case(jen.Lit(i)).Block(jen.Goto().Id(codegen.InstructionName(uint32(i)))),
		)
	}

	return []jen.Code{
		jen.Id(codegen.StepSelectName).Op(":"),
		jen.Switch(jen.Id(codegen.NextInstructionName)).Block(cases...),
	}
}

// generateInstructions generates code for all instructions.
func (c *Compiler) generateInstructions() ([]jen.Code, error) {
	var code []jen.Code

	for i, inst := range c.config.Program.Inst {
		instCode, err := c.generateInstruction(uint32(i), &inst)
		if err != nil {
			return nil, fmt.Errorf("failed to generate instruction %d: %w", i, err)
		}
		code = append(code, instCode...)
	}

	return code, nil
}

// generateInstruction generates code for a single instruction.
func (c *Compiler) generateInstruction(id uint32, inst *syntax.Inst) ([]jen.Code, error) {
	label := jen.Id(codegen.InstructionName(id)).Op(":")

	switch inst.Op {
	case syntax.InstMatch:
		return []jen.Code{
			label,
			jen.Block(jen.Return(jen.True())),
		}, nil

	case syntax.InstFail:
		return []jen.Code{
			label,
			jen.Block(jen.Return(jen.False())),
		}, nil

	case syntax.InstCapture:
		// For Match functions without captures, just skip capture instructions
		return []jen.Code{
			label,
			jen.Block(
				jen.Goto().Id(codegen.InstructionName(inst.Out)),
			),
		}, nil

	case syntax.InstRune:
		return c.generateRuneInst(label, inst)

	case syntax.InstRune1:
		return c.generateRune1Inst(label, inst)

	case syntax.InstRuneAny:
		return c.generateRuneAnyInst(label, inst)

	case syntax.InstRuneAnyNotNL:
		return c.generateRuneAnyNotNLInst(label, inst)

	case syntax.InstAlt:
		return c.generateAltInst(label, inst, id)

	case syntax.InstAltMatch:
		return c.generateAltMatchInst(label, inst)

	case syntax.InstEmptyWidth:
		return c.generateEmptyWidthInst(label, inst)

	case syntax.InstNop:
		return c.generateNopInst(label, inst)

	default:
		return nil, fmt.Errorf("unsupported instruction type: %v", inst.Op)
	}
}

// generateRune1Inst generates code for InstRune1 (single rune match).
func (c *Compiler) generateRune1Inst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").Lit(byte(inst.Rune[0]))).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateRuneInst generates code for InstRune (character class match).
func (c *Compiler) generateRuneInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(c.generateRuneCheck(inst.Rune)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateRuneCheck generates the condition for checking if a rune matches.
func (c *Compiler) generateRuneCheck(runes []rune) *jen.Statement {
	if len(runes) == 0 {
		return jen.True()
	}

	// Check for common character classes and use optimized checks
	if charClass := detectCharacterClass(runes); charClass != "" {
		return c.generateOptimizedCharClassCheck(charClass)
	}

	// For small sets (3 or fewer distinct values), use switch-like OR conditions
	if len(runes) <= 6 && allSingleChars(runes) {
		return c.generateSmallSetCheck(runes)
	}

	// For larger character classes with many ranges, use a more optimized approach
	if len(runes) > 10 {
		return c.generateLargeCharClassCheck(runes)
	}

	// Build condition for character class
	// We need to check if the byte does NOT match any of the ranges
	var stmt *jen.Statement
	for i := 0; i < len(runes); i += 2 {
		lo, hi := runes[i], runes[i+1]
		var condition *jen.Statement
		if lo == hi {
			condition = jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").Lit(byte(lo))
		} else {
			condition = jen.Parens(
				jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("<").Lit(byte(lo)).
					Op("||").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op(">").Lit(byte(hi)),
			)
		}

		if stmt == nil {
			stmt = condition
		} else {
			stmt = stmt.Op("&&").Add(condition)
		}
	}

	return stmt
}

// detectCharacterClass checks if runes match a common character class pattern.
func detectCharacterClass(runes []rune) string {
	// \w: [0-9A-Za-z_]
	if len(runes) == 8 &&
		runes[0] == '0' && runes[1] == '9' &&
		runes[2] == 'A' && runes[3] == 'Z' &&
		runes[4] == '_' && runes[5] == '_' &&
		runes[6] == 'a' && runes[7] == 'z' {
		return "word"
	}

	// \d: [0-9]
	if len(runes) == 2 && runes[0] == '0' && runes[1] == '9' {
		return "digit"
	}

	// \s: [ \t\n\r\f\v]
	if len(runes) == 12 &&
		runes[0] == '\t' && runes[1] == '\n' &&
		runes[2] == '\f' && runes[3] == '\r' &&
		runes[4] == ' ' && runes[5] == ' ' {
		return "space"
	}

	// [a-z]
	if len(runes) == 2 && runes[0] == 'a' && runes[1] == 'z' {
		return "lowercase"
	}

	// [A-Z]
	if len(runes) == 2 && runes[0] == 'A' && runes[1] == 'Z' {
		return "uppercase"
	}

	// [a-zA-Z]
	if len(runes) == 4 &&
		runes[0] == 'A' && runes[1] == 'Z' &&
		runes[2] == 'a' && runes[3] == 'z' {
		return "alpha"
	}

	return ""
}

// generateOptimizedCharClassCheck generates optimized code for common character classes.
func (c *Compiler) generateOptimizedCharClassCheck(charClass string) *jen.Statement {
	// Helper to create input[offset] expression
	inputAt := func() *jen.Statement {
		return jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName))
	}

	switch charClass {
	case "word":
		// \w: [0-9A-Za-z_] - NOT (< '0' || (> '9' && < 'A') || (> 'Z' && < '_') || (> '_' && < 'a') || > 'z')
		part1 := inputAt().Op("<").Lit(byte('0'))
		part2 := jen.Parens(inputAt().Op(">").Lit(byte('9')).Op("&&").Add(inputAt()).Op("<").Lit(byte('A')))
		part3 := jen.Parens(inputAt().Op(">").Lit(byte('Z')).Op("&&").Add(inputAt()).Op("<").Lit(byte('_')))
		part4 := jen.Parens(inputAt().Op(">").Lit(byte('_')).Op("&&").Add(inputAt()).Op("<").Lit(byte('a')))
		part5 := inputAt().Op(">").Lit(byte('z'))
		return jen.Parens(part1.Op("||").Add(part2).Op("||").Add(part3).Op("||").Add(part4).Op("||").Add(part5))

	case "digit":
		// \d: [0-9] - NOT (< '0' || > '9')
		return jen.Parens(inputAt().Op("<").Lit(byte('0')).Op("||").Add(inputAt()).Op(">").Lit(byte('9')))

	case "space":
		// \s: whitespace - NOT (== ' ' || == '\t' || ... )
		// Using != for all since we want "not in set"
		part1 := inputAt().Op("!=").Lit(byte(' '))
		part2 := inputAt().Op("!=").Lit(byte('\t'))
		part3 := inputAt().Op("!=").Lit(byte('\n'))
		part4 := inputAt().Op("!=").Lit(byte('\r'))
		part5 := inputAt().Op("!=").Lit(byte('\f'))
		return jen.Parens(part1.Op("&&").Add(part2).Op("&&").Add(part3).Op("&&").Add(part4).Op("&&").Add(part5))

	case "lowercase":
		// [a-z] - NOT (< 'a' || > 'z')
		return jen.Parens(inputAt().Op("<").Lit(byte('a')).Op("||").Add(inputAt()).Op(">").Lit(byte('z')))

	case "uppercase":
		// [A-Z] - NOT (< 'A' || > 'Z')
		return jen.Parens(inputAt().Op("<").Lit(byte('A')).Op("||").Add(inputAt()).Op(">").Lit(byte('Z')))

	case "alpha":
		// [a-zA-Z] - NOT ((< 'A' || > 'Z') && (< 'a' || > 'z'))
		upper := jen.Parens(inputAt().Op("<").Lit(byte('A')).Op("||").Add(inputAt()).Op(">").Lit(byte('Z')))
		lower := jen.Parens(inputAt().Op("<").Lit(byte('a')).Op("||").Add(inputAt()).Op(">").Lit(byte('z')))
		return jen.Parens(upper.Op("&&").Add(lower))
	}

	return jen.True()
}

// allSingleChars checks if all ranges are single characters.
func allSingleChars(runes []rune) bool {
	for i := 0; i < len(runes); i += 2 {
		if runes[i] != runes[i+1] {
			return false
		}
	}
	return true
}

// generateSmallSetCheck generates optimized code for small character sets using OR conditions.
func (c *Compiler) generateSmallSetCheck(runes []rune) *jen.Statement {
	ch := jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName))

	var stmt *jen.Statement
	for i := 0; i < len(runes); i += 2 {
		condition := ch.Clone().Op("!=").Lit(byte(runes[i]))
		if stmt == nil {
			stmt = condition
		} else {
			stmt = stmt.Op("&&").Add(condition)
		}
	}

	return stmt
}

// generateLargeCharClassCheck generates optimized code for large character classes.
// Uses grouped range checks to reduce condition length.
func (c *Compiler) generateLargeCharClassCheck(runes []rune) *jen.Statement {
	// Helper to create input[offset] expression
	inputAt := func() *jen.Statement {
		return jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName))
	}

	// Group consecutive ranges
	type rangeGroup struct {
		start, end byte
	}

	var groups []rangeGroup
	for i := 0; i < len(runes); i += 2 {
		lo, hi := byte(runes[i]), byte(runes[i+1])
		groups = append(groups, rangeGroup{lo, hi})
	}

	// Generate condition: not in any range
	var stmt *jen.Statement
	for _, g := range groups {
		var condition *jen.Statement
		if g.start == g.end {
			condition = inputAt().Op("!=").Lit(g.start)
		} else {
			condition = jen.Parens(inputAt().Op("<").Lit(g.start).Op("||").Add(inputAt()).Op(">").Lit(g.end))
		}

		if stmt == nil {
			stmt = condition
		} else {
			stmt = stmt.Op("&&").Add(condition)
		}
	}

	return stmt
}

// generateRuneAnyInst generates code for InstRuneAny (match any character).
func (c *Compiler) generateRuneAnyInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateRuneAnyNotNLInst generates code for InstRuneAnyNotNL (match any character except newline).
func (c *Compiler) generateRuneAnyNotNLInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(
				jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName).Op("||").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("==").Lit('\n'),
			).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateAltInst generates code for InstAlt (alternation with backtracking).
func (c *Compiler) generateAltInst(label *jen.Statement, inst *syntax.Inst, id uint32) ([]jen.Code, error) {
	// Detect greedy loop: inst.Out points backward (to earlier instruction)
	// This indicates patterns like +, *, {n,} quantifiers
	isGreedyLoop := inst.Out < id

	// Optimization #1: When generating Find* functions with captures, save capture checkpoint
	if c.generatingCaptures {
		return []jen.Code{
			label,
			jen.Block(
				// Save current capture state as checkpoint (flattened)
				jen.Id("captureStack").Op("=").Append(jen.Id("captureStack"), jen.Id(codegen.CapturesName).Op("...")),
				// Push to backtracking stack
				jen.Id(codegen.StackName).Op("=").Append(
					jen.Id(codegen.StackName),
					jen.Index(jen.Lit(2)).Int().Values(jen.Id(codegen.OffsetName), jen.Lit(int(inst.Arg))),
				),
				jen.Goto().Id(codegen.InstructionName(inst.Out)),
			),
		}, nil
	}

	// Optimization #2: Greedy loop optimization (auto-detected)
	// Only optimize simple greedy loops where the target is a character-matching instruction
	// Avoid optimizing nested alternations (like in complex patterns) to prevent regressions
	if isGreedyLoop && c.isSimpleGreedyLoop(inst) {
		return []jen.Code{
			label,
			jen.Block(
				// For greedy loops, push to stack with the loop start (for backtracking)
				// Then try the continuation instruction first
				jen.Id(codegen.StackName).Op("=").Append(
					jen.Id(codegen.StackName),
					jen.Index(jen.Lit(2)).Int().Values(jen.Id(codegen.OffsetName), jen.Lit(int(inst.Out))),
				),
				// Try continuation first (greedy behavior: we've matched, now try what comes next)
				jen.Goto().Id(codegen.InstructionName(inst.Arg)),
			),
		}, nil
	}

	// Standard alternation: Just use append - Go's runtime handles capacity efficiently
	return []jen.Code{
		label,
		jen.Block(
			jen.Id(codegen.StackName).Op("=").Append(
				jen.Id(codegen.StackName),
				jen.Index(jen.Lit(2)).Int().Values(jen.Id(codegen.OffsetName), jen.Lit(int(inst.Arg))),
			),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// isSimpleGreedyLoop checks if a greedy loop is safe to optimize.
// Returns true for simple character-matching loops (like [\w]+ or a+)
// Returns false for complex nested alternations to avoid regressions.
func (c *Compiler) isSimpleGreedyLoop(inst *syntax.Inst) bool {
	// Check what instruction the loop jumps back to
	loopTarget := c.config.Program.Inst[inst.Out]

	// Optimize only if the loop target is a simple character-matching instruction
	// Don't optimize if it's another alternation (nested structure)
	switch loopTarget.Op {
	case syntax.InstRune, syntax.InstRune1, syntax.InstRuneAny, syntax.InstRuneAnyNotNL:
		// Simple character matching - safe to optimize
		return true
	case syntax.InstAlt:
		// Nested alternation - not safe to optimize (causes regression in complex patterns)
		return false
	default:
		// Other instruction types - conservatively don't optimize
		return false
	}
}

// generateAltMatchInst generates code for InstAltMatch (alternation without backtracking).
func (c *Compiler) generateAltMatchInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateEmptyWidthInst generates code for InstEmptyWidth (position assertions).
func (c *Compiler) generateEmptyWidthInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	emptyOp := syntax.EmptyOp(inst.Arg)

	var checks []jen.Code

	// Check for beginning of text (^)
	if emptyOp&syntax.EmptyBeginText != 0 {
		// offset must be 0
		checks = append(checks,
			jen.If(jen.Id(codegen.OffsetName).Op("!=").Lit(0)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		)
	}

	// Check for end of text ($)
	if emptyOp&syntax.EmptyEndText != 0 {
		// offset must equal length
		checks = append(checks,
			jen.If(jen.Id(codegen.OffsetName).Op("!=").Id(codegen.InputLenName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		)
	}

	// Check for beginning of line
	if emptyOp&syntax.EmptyBeginLine != 0 {
		// offset must be 0 OR previous character must be newline
		checks = append(checks,
			jen.If(
				jen.Id(codegen.OffsetName).Op("!=").Lit(0).Op("&&").
					Parens(
						jen.Id(codegen.OffsetName).Op("==").Lit(0).Op("||").
							Id(codegen.InputName).Index(jen.Id(codegen.OffsetName).Op("-").Lit(1)).Op("!=").LitRune('\n'),
					),
			).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		)
	}

	// Check for end of line
	if emptyOp&syntax.EmptyEndLine != 0 {
		// offset must equal length OR current character must be newline
		checks = append(checks,
			jen.If(
				jen.Id(codegen.OffsetName).Op("!=").Id(codegen.InputLenName).Op("&&").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").LitRune('\n'),
			).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		)
	}

	// Word boundary checks would go here if needed
	// For now, we'll leave them unimplemented
	if emptyOp&(syntax.EmptyWordBoundary|syntax.EmptyNoWordBoundary) != 0 {
		return nil, fmt.Errorf("word boundary assertions (\\b, \\B) are not yet implemented")
	}

	// Add the checks and continue to next instruction
	code := []jen.Code{label}
	if len(checks) > 0 {
		code = append(code, jen.Block(append(checks,
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		)...))
	} else {
		code = append(code, jen.Block(
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		))
	}

	return code, nil
}

// generateNopInst generates code for InstNop (no operation).
func (c *Compiler) generateNopInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateStackPool generates a sync.Pool for stack reuse.
func (c *Compiler) generateStackPool() {
	poolName := fmt.Sprintf("%sStackPool", codegen.LowerFirst(c.config.Name))

	c.file.Var().Id(poolName).Op("=").Qual("sync", "Pool").Values(jen.Dict{
		jen.Id("New"): jen.Func().Params().Interface().Block(
			jen.Id("stack").Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
			jen.Return(jen.Op("&").Id("stack")),
		),
	})
	c.file.Line()
}

// generateCaptureStackPool generates the sync.Pool for capture stacks.
func (c *Compiler) generateCaptureStackPool() {
	poolName := fmt.Sprintf("%sCaptureStackPool", codegen.LowerFirst(c.config.Name))

	c.file.Var().Id(poolName).Op("=").Qual("sync", "Pool").Values(jen.Dict{
		jen.Id("New"): jen.Func().Params().Interface().Block(
			// Initial capacity: 16 checkpoints * numCaptures
			jen.Id("stack").Op(":=").Make(jen.Index().Int(), jen.Lit(0), jen.Lit(16*c.config.Program.NumCap)),
			jen.Return(jen.Op("&").Id("stack")),
		),
	})
	c.file.Line()
}

// generatePooledStackInit generates code to get a stack from the pool.
func (c *Compiler) generatePooledStackInit() []jen.Code {
	poolName := fmt.Sprintf("%sStackPool", codegen.LowerFirst(c.config.Name))

	return []jen.Code{
		// Get stack from pool
		jen.Id("stackPtr").Op(":=").Id(poolName).Dot("Get").Call().Assert(jen.Op("*").Index().Index(jen.Lit(2)).Int()),
		jen.Id(codegen.StackName).Op(":=").Parens(jen.Op("*").Id("stackPtr")).Index(jen.Empty(), jen.Lit(0)),
		// Defer return to pool
		jen.Defer().Func().Params().Block(
			// Clear references to prevent memory leaks
			jen.For(jen.Id("i").Op(":=").Range().Id(codegen.StackName)).Block(
				jen.Id(codegen.StackName).Index(jen.Id("i")).Op("=").Index(jen.Lit(2)).Int().Values(jen.Lit(0), jen.Lit(0)),
			),
			jen.Op("*").Id("stackPtr").Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Lit(0)),
			jen.Id(poolName).Dot("Put").Call(jen.Id("stackPtr")),
		).Call(),
	}
}

// generatePooledCaptureStackInit generates code to get a capture stack from the pool.
func (c *Compiler) generatePooledCaptureStackInit() []jen.Code {
	poolName := fmt.Sprintf("%sCaptureStackPool", codegen.LowerFirst(c.config.Name))

	return []jen.Code{
		// Get stack from pool
		jen.Id("captureStackPtr").Op(":=").Id(poolName).Dot("Get").Call().Assert(jen.Op("*").Index().Int()),
		jen.Id("captureStack").Op(":=").Parens(jen.Op("*").Id("captureStackPtr")).Index(jen.Empty(), jen.Lit(0)),
		// Defer return to pool
		jen.Defer().Func().Params().Block(
			// Clear references to prevent memory leaks (not strictly needed for []int but good practice if we change types later)
			// For []int we just need to reset length
			jen.Op("*").Id("captureStackPtr").Op("=").Id("captureStack").Index(jen.Empty(), jen.Lit(0)),
			jen.Id(poolName).Dot("Put").Call(jen.Id("captureStackPtr")),
		).Call(),
	}
}

// extractCaptureNames extracts capture group names from the regex AST.
func extractCaptureNames(re *syntax.Regexp) []string {
	var names []string
	names = append(names, "") // Group 0 is always the full match (unnamed)

	var walk func(*syntax.Regexp)
	walk = func(r *syntax.Regexp) {
		if r.Op == syntax.OpCapture {
			names = append(names, r.Name)
		}
		for _, sub := range r.Sub {
			walk(sub)
		}
	}

	walk(re)
	return names
}

// hasRepeatingCaptures checks if the regex has any capture groups in repeating context.
// Repeating contexts include *, +, ?, and {n,m} quantifiers.
// Note: Standard regex behavior (including Go's stdlib) captures only the LAST match
// from repeating groups. For example, (\w)+ matching "abc" will capture "c", not ["a","b","c"].
func hasRepeatingCaptures(re *syntax.Regexp) bool {
	return walkCheckRepeating(re, false)
}

// needsBacktracking checks if the compiled program requires backtracking.
// Returns true if the program contains InstAlt instructions (alternations).
func needsBacktracking(prog *syntax.Prog) bool {
	if prog == nil {
		return false
	}

	for i := range prog.Inst {
		if prog.Inst[i].Op == syntax.InstAlt {
			return true
		}
	}

	return false
}

// walkCheckRepeating recursively walks the AST to detect captures in repeating context.
func walkCheckRepeating(re *syntax.Regexp, inRepeat bool) bool {
	// If this is a capture and we're in a repeating context
	if re.Op == syntax.OpCapture && inRepeat {
		return true
	}

	// Check if this node introduces repetition
	isRepeating := false
	switch re.Op {
	case syntax.OpStar, syntax.OpPlus, syntax.OpQuest, syntax.OpRepeat:
		isRepeating = true
	}

	// Recursively check children
	for _, sub := range re.Sub {
		if walkCheckRepeating(sub, inRepeat || isRepeating) {
			return true
		}
	}

	return false
}

// generateCaptureFunctions generates Find and FindAll functions with capture groups.
func (c *Compiler) generateCaptureFunctions() error {
	// Generate capture struct
	structName := fmt.Sprintf("%sMatch", c.config.Name)
	c.generateCaptureStruct(structName)

	// Generate FindString function
	if err := c.generateFindStringFunction(structName); err != nil {
		return fmt.Errorf("failed to generate FindString: %w", err)
	}

	// Generate FindAllString function
	if err := c.generateFindAllStringFunction(structName); err != nil {
		return fmt.Errorf("failed to generate FindAllString: %w", err)
	}

	// Generate FindBytes function
	if c.config.BytesView {
		bytesStructName := fmt.Sprintf("%sMatchBytes", c.config.Name)
		c.generateCaptureStructBytes(bytesStructName)
		if err := c.generateFindBytesFunction(bytesStructName); err != nil {
			return fmt.Errorf("failed to generate FindBytes: %w", err)
		}
		if err := c.generateFindAllBytesFunction(bytesStructName); err != nil {
			return fmt.Errorf("failed to generate FindAllBytes: %w", err)
		}
	} else {
		// Use same struct, convert []byte to string
		if err := c.generateFindBytesFunction(structName); err != nil {
			return fmt.Errorf("failed to generate FindBytes: %w", err)
		}
		if err := c.generateFindAllBytesFunction(structName); err != nil {
			return fmt.Errorf("failed to generate FindAllBytes: %w", err)
		}
	}

	return nil
}

// generateCaptureStruct generates the Match struct with string fields.
func (c *Compiler) generateCaptureStruct(structName string) {
	// Add warning comment if there are repeating captures
	if c.hasRepeatingCaptures {
		c.file.Comment("Note: This pattern contains capture groups in repeating/optional context.")
		c.file.Comment("Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).")
		c.file.Comment("For example: (\\w)+ matching 'abc' captures 'c', not ['a','b','c'].")
		c.file.Comment("Optional groups (?) return empty string when not matched.")
		c.file.Line()
	}

	fields := []jen.Code{
		jen.Id("Match").String().Comment("Full match"),
	}

	// Add fields for each capture group (skip group 0 which is the full match)
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}
		fields = append(fields, jen.Id(fieldName).String())
	}

	c.file.Type().Id(structName).Struct(fields...)
	c.file.Line()
}

// generateCaptureStructBytes generates the Match struct with []byte fields for BytesView.
func (c *Compiler) generateCaptureStructBytes(structName string) {
	// Add warning comment if there are repeating captures
	if c.hasRepeatingCaptures {
		c.file.Comment("Note: This pattern contains capture groups in repeating/optional context.")
		c.file.Comment("Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).")
		c.file.Comment("For example: (\\w)+ matching 'abc' captures 'c', not ['a','b','c'].")
		c.file.Comment("Optional groups (?) return empty slice when not matched.")
		c.file.Line()
	}

	fields := []jen.Code{
		jen.Id("Match").Index().Byte().Comment("Full match"),
	}

	// Add fields for each capture group (skip group 0 which is the full match)
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}
		fields = append(fields, jen.Id(fieldName).Index().Byte())
	}

	c.file.Type().Id(structName).Struct(fields...)
	c.file.Line()
}

// generateFindStringFunction generates the FindString function with captures.
func (c *Compiler) generateFindStringFunction(structName string) error {
	code, err := c.generateFindFunction(structName, false)
	if err != nil {
		return err
	}

	c.file.Func().
		Id(fmt.Sprintf("%sFindString", c.config.Name)).
		Params(jen.Id(codegen.InputName).String()).
		Params(jen.Op("*").Id(structName), jen.Bool()).
		Block(code...)

	return nil
}

// generateFindBytesFunction generates the FindBytes function with captures.
func (c *Compiler) generateFindBytesFunction(structName string) error {
	code, err := c.generateFindFunction(structName, c.config.BytesView)
	if err != nil {
		return err
	}

	c.file.Func().
		Id(fmt.Sprintf("%sFindBytes", c.config.Name)).
		Params(jen.Id(codegen.InputName).Index().Byte()).
		Params(jen.Op("*").Id(structName), jen.Bool()).
		Block(code...)

	return nil
}

// generateFindAllStringFunction generates the FindAllString function with captures.
func (c *Compiler) generateFindAllStringFunction(structName string) error {
	code, err := c.generateFindAllFunction(structName, false)
	if err != nil {
		return err
	}

	c.file.Func().
		Id(fmt.Sprintf("%sFindAllString", c.config.Name)).
		Params(jen.Id(codegen.InputName).String(), jen.Id("n").Int()).
		Params(jen.Index().Op("*").Id(structName)).
		Block(code...)

	return nil
}

// generateFindAllBytesFunction generates the FindAllBytes function with captures.
func (c *Compiler) generateFindAllBytesFunction(structName string) error {
	code, err := c.generateFindAllFunction(structName, c.config.BytesView)
	if err != nil {
		return err
	}

	c.file.Func().
		Id(fmt.Sprintf("%sFindAllBytes", c.config.Name)).
		Params(jen.Id(codegen.InputName).Index().Byte(), jen.Id("n").Int()).
		Params(jen.Index().Op("*").Id(structName)).
		Block(code...)

	return nil
}

// generateFindAllFunction generates the main FindAll logic with captures.
// Parameter n specifies the maximum number of matches to return (-1 for all matches).
func (c *Compiler) generateFindAllFunction(structName string, isBytes bool) ([]jen.Code, error) {
	numCaptures := c.config.Program.NumCap

	// Enable capture checkpoint optimization
	c.generatingCaptures = true
	defer func() { c.generatingCaptures = false }()

	code := []jen.Code{
		// Handle n parameter
		jen.If(jen.Id("n").Op("==").Lit(0)).Block(
			jen.Return(jen.Nil()),
		),
		// Initialize result slice
		jen.Var().Id("result").Index().Op("*").Id(structName),
		// Initialize length
		jen.Id(codegen.InputLenName).Op(":=").Len(jen.Id(codegen.InputName)),
		// Initialize search start position
		jen.Id("searchStart").Op(":=").Lit(0),
	}

	// Build the loop body statements
	loopBody := []jen.Code{
		// Check if we've found enough matches
		jen.If(jen.Id("n").Op(">").Lit(0).Op("&&").Len(jen.Id("result")).Op(">=").Id("n")).Block(
			jen.Break(),
		),
	}

	// Optimization: If anchored, we only run once at offset 0
	if c.isAnchored {
		loopBody = append(loopBody,
			jen.If(jen.Id("searchStart").Op(">").Lit(0)).Block(
				jen.Break(),
			),
		)
	}

	loopBody = append(loopBody,
		// Check if we've reached end of input
		jen.If(jen.Id("searchStart").Op(">=").Id(codegen.InputLenName)).Block(
			jen.Break(),
		),
		// Initialize offset
		jen.Id(codegen.OffsetName).Op(":=").Id("searchStart"),
		// Initialize captures array
		jen.Id(codegen.CapturesName).Op(":=").Make(jen.Index().Int(), jen.Lit(numCaptures)),
	)

	// Initialize capture checkpoint stack only if we have alternations (Optimization #1)
	if c.needsBacktracking {
		if c.config.UsePool {
			loopBody = append(loopBody, c.generatePooledCaptureStackInit()...)
		} else {
			loopBody = append(loopBody, jen.Id("captureStack").Op(":=").Make(jen.Index().Int(), jen.Lit(0), jen.Lit(16*numCaptures)))
		}
	}

	// Only add stack initialization if backtracking is needed
	if c.needsBacktracking {
		// Add stack initialization
		if c.config.UsePool {
			poolName := fmt.Sprintf("%sStackPool", codegen.LowerFirst(c.config.Name))
			loopBody = append(loopBody,
				jen.Id("stackPtr").Op(":=").Id(poolName).Dot("Get").Call().Assert(jen.Op("*").Index().Index(jen.Lit(2)).Int()),
				jen.Id(codegen.StackName).Op(":=").Parens(jen.Op("*").Id("stackPtr")).Index(jen.Empty(), jen.Lit(0)),
				jen.Defer().Func().Params().Block(
					jen.For(jen.Id("i").Op(":=").Range().Id(codegen.StackName)).Block(
						jen.Id(codegen.StackName).Index(jen.Id("i")).Op("=").Index(jen.Lit(2)).Int().Values(jen.Lit(0), jen.Lit(0)),
					),
					jen.Op("*").Id("stackPtr").Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Lit(0)),
					jen.Id(poolName).Dot("Put").Call(jen.Id("stackPtr")),
				).Call(),
			)
		} else {
			loopBody = append(loopBody,
				jen.Id(codegen.StackName).Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
			)
		}
	}

	// Continue with matching logic
	loopBody = append(loopBody,
		// Set captures[0] to mark start of match attempt
		jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op("=").Id("searchStart"),
		// Initialize next instruction
		jen.Id(codegen.NextInstructionName).Op(":=").Lit(int(c.config.Program.Start)),
		jen.Goto().Id(codegen.StepSelectName),
	)

	// Add backtracking logic that continues to next position on failure
	// Only if backtracking is needed
	if c.needsBacktracking {
		loopBody = append(loopBody,
			jen.Id(codegen.TryFallbackName).Op(":"),
			jen.If(jen.Len(jen.Id(codegen.StackName)).Op(">").Lit(0)).Block(
				jen.Id("last").Op(":=").Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
				jen.Id(codegen.OffsetName).Op("=").Id("last").Index(jen.Lit(0)),
				jen.Id(codegen.NextInstructionName).Op("=").Id("last").Index(jen.Lit(1)),
				jen.Id(codegen.StackName).Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
				jen.Goto().Id(codegen.StepSelectName),
			).Else().Block(
				// No match at this position, try next
				jen.Id("searchStart").Op("++"),
				jen.Continue(),
			),
		)
	} else {
		// For patterns without backtracking, just move to next position on failure
		loopBody = append(loopBody,
			jen.Id(codegen.TryFallbackName).Op(":"),
			jen.Id("searchStart").Op("++"),
			jen.Continue(),
		)
	}

	// Add step selector
	loopBody = append(loopBody, c.generateStepSelector()...)

	// Generate instructions with captures - but modified to continue loop instead of returning
	instructions, err := c.generateInstructionsForFindAll(structName, isBytes)
	if err != nil {
		return nil, err
	}
	loopBody = append(loopBody, instructions...)

	// Add the loop
	code = append(code,
		jen.For(jen.True()).Block(loopBody...),
		jen.Return(jen.Id("result")),
	)

	return code, nil
}

// generateInstructionsForFindAll generates instructions where Match adds to result and continues.
func (c *Compiler) generateInstructionsForFindAll(structName string, isBytes bool) ([]jen.Code, error) {
	var code []jen.Code

	for i, inst := range c.config.Program.Inst {
		var instCode []jen.Code
		var err error

		if inst.Op == syntax.InstMatch {
			// Special handling for Match instruction in FindAll
			instCode, err = c.generateMatchInstForFindAll(uint32(i), structName, isBytes)
		} else if inst.Op == syntax.InstFail {
			// Special handling for Fail instruction in FindAll - goto fallback instead of return
			label := jen.Id(codegen.InstructionName(uint32(i))).Op(":")
			instCode = []jen.Code{
				label,
				jen.Block(jen.Goto().Id(codegen.TryFallbackName)),
			}
		} else {
			// Use regular instruction generation for other instructions
			instCode, err = c.generateInstructionWithCaptures(uint32(i), &inst, structName, isBytes)
		}

		if err != nil {
			return nil, fmt.Errorf("failed to generate instruction %d: %w", i, err)
		}
		code = append(code, instCode...)
	}

	return code, nil
}

// generateMatchInstForFindAll generates Match instruction that adds to result and continues loop.
func (c *Compiler) generateMatchInstForFindAll(id uint32, structName string, isBytes bool) ([]jen.Code, error) {
	label := jen.Id(codegen.InstructionName(id)).Op(":")

	// Build struct fields from captures array
	structFields := jen.Dict{}

	if isBytes {
		structFields[jen.Id("Match")] = jen.Id(codegen.InputName).Index(
			jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(1)),
		)
	} else {
		structFields[jen.Id("Match")] = jen.String().Call(
			jen.Id(codegen.InputName).Index(
				jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(1)),
			),
		)
	}

	// Add capture group fields
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}

		captureStart := i * 2
		captureEnd := i*2 + 1

		if isBytes {
			structFields[jen.Id(fieldName)] = jen.Func().Params().Index().Byte().Block(
				jen.If(
					jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op("<=").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).
						Op("&&").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).Op("<=").Len(jen.Id(codegen.InputName)),
				).Block(
					jen.Return(jen.Id(codegen.InputName).Index(
						jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)),
					)),
				),
				jen.Return(jen.Nil()),
			).Call()
		} else {
			structFields[jen.Id(fieldName)] = jen.Func().Params().String().Block(
				jen.If(
					jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op("<=").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).
						Op("&&").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).Op("<=").Len(jen.Id(codegen.InputName)),
				).Block(
					jen.Return(jen.String().Call(jen.Id(codegen.InputName).Index(
						jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)),
					))),
				),
				jen.Return(jen.Lit("")),
			).Call()
		}
	}

	return []jen.Code{
		label,
		jen.Block(
			// Set captures[1] to mark end of match
			jen.Id(codegen.CapturesName).Index(jen.Lit(1)).Op("=").Id(codegen.OffsetName),
			// Add match to results
			jen.Id("result").Op("=").Append(
				jen.Id("result"),
				jen.Op("&").Id(structName).Values(structFields),
			),
			// Move search position past this match
			jen.If(jen.Id(codegen.CapturesName).Index(jen.Lit(1)).Op(">").Id("searchStart")).Block(
				jen.Id("searchStart").Op("=").Id(codegen.CapturesName).Index(jen.Lit(1)),
			).Else().Block(
				// Prevent infinite loop on zero-width matches
				jen.Id("searchStart").Op("++"),
			),
			// Continue searching
			jen.Continue(),
		),
	}, nil
}

// generateFindFunction generates the main Find logic with captures.
func (c *Compiler) generateFindFunction(structName string, isBytes bool) ([]jen.Code, error) {
	numCaptures := c.config.Program.NumCap

	// Enable capture checkpoint optimization
	c.generatingCaptures = true
	defer func() { c.generatingCaptures = false }()

	code := []jen.Code{
		// Initialize length
		jen.Id(codegen.InputLenName).Op(":=").Len(jen.Id(codegen.InputName)),
		// Initialize offset
		jen.Id(codegen.OffsetName).Op(":=").Lit(0),
		// Initialize captures array
		jen.Id(codegen.CapturesName).Op(":=").Make(jen.Index().Int(), jen.Lit(numCaptures)),
	}

	// Initialize capture checkpoint stack only if we have alternations (Optimization #1)
	if c.needsBacktracking {
		if c.config.UsePool {
			code = append(code, c.generatePooledCaptureStackInit()...)
		} else {
			// Initial capacity: 16 checkpoints * numCaptures
			code = append(code, jen.Id("captureStack").Op(":=").Make(jen.Index().Int(), jen.Lit(0), jen.Lit(16*numCaptures)))
		}
	}

	// Only add stack initialization if backtracking is needed
	if c.needsBacktracking {
		// Add stack initialization (pooled or regular)
		if c.config.UsePool {
			code = append(code, c.generatePooledStackInit()...)
		} else {
			code = append(code,
				jen.Id(codegen.StackName).Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
			)
		}
	}

	code = append(code,
		// Set captures[0] to mark start of first match attempt
		jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op("=").Lit(0),
		// Initialize next instruction
		jen.Id(codegen.NextInstructionName).Op(":=").Lit(int(c.config.Program.Start)),
		// Jump to step selector
		jen.Goto().Id(codegen.StepSelectName),
	)

	// Add backtracking logic (with nil return for captures)
	// Only if backtracking is needed
	if c.needsBacktracking {
		code = append(code, c.generateBacktrackingWithCaptures()...)
	} else {
		// For patterns without backtracking:
		fallback := []jen.Code{jen.Id(codegen.TryFallbackName).Op(":")}

		// If not anchored, we must retry at next offset
		if !c.isAnchored {
			fallback = append(fallback,
				jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
					jen.Id(codegen.OffsetName).Op("++"),
					// Reset captures array for new match attempt
					jen.For(jen.Id("i").Op(":=").Range().Id(codegen.CapturesName)).Block(
						jen.Id(codegen.CapturesName).Index(jen.Id("i")).Op("=").Lit(0),
					),
					// Set capture[0] to mark start of match attempt
					jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op("=").Id(codegen.OffsetName),
					jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
					jen.Goto().Id(codegen.StepSelectName),
				),
			)
		}

		fallback = append(fallback, jen.Return(jen.Nil(), jen.False()))
		code = append(code, fallback...)
	}

	// Add step selector
	code = append(code, c.generateStepSelector()...)

	// Generate instructions with captures
	instructions, err := c.generateInstructionsWithCaptures(structName, isBytes)
	if err != nil {
		return nil, err
	}
	code = append(code, instructions...)

	return code, nil
}

// generateInstructionsWithCaptures generates code for all instructions with capture support.
func (c *Compiler) generateInstructionsWithCaptures(structName string, isBytes bool) ([]jen.Code, error) {
	var code []jen.Code

	for i, inst := range c.config.Program.Inst {
		instCode, err := c.generateInstructionWithCaptures(uint32(i), &inst, structName, isBytes)
		if err != nil {
			return nil, fmt.Errorf("failed to generate instruction %d: %w", i, err)
		}
		code = append(code, instCode...)
	}

	return code, nil
}

// generateInstructionWithCaptures generates code for a single instruction with capture support.
func (c *Compiler) generateInstructionWithCaptures(id uint32, inst *syntax.Inst, structName string, isBytes bool) ([]jen.Code, error) {
	label := jen.Id(codegen.InstructionName(id)).Op(":")

	switch inst.Op {
	case syntax.InstMatch:
		return c.generateMatchInstWithCaptures(label, structName, isBytes)

	case syntax.InstCapture:
		return c.generateCaptureInst(label, inst)

	case syntax.InstFail:
		return []jen.Code{
			label,
			jen.Block(jen.Return(jen.Nil(), jen.False())),
		}, nil

	case syntax.InstRune:
		return c.generateRuneInstWithCaptures(label, inst)

	case syntax.InstRune1:
		return c.generateRune1InstWithCaptures(label, inst)

	case syntax.InstRuneAny:
		return c.generateRuneAnyInstWithCaptures(label, inst)

	case syntax.InstRuneAnyNotNL:
		return c.generateRuneAnyNotNLInstWithCaptures(label, inst)

	case syntax.InstAlt:
		return c.generateAltInst(label, inst, id)

	case syntax.InstAltMatch:
		return c.generateAltMatchInst(label, inst)

	case syntax.InstEmptyWidth:
		return c.generateEmptyWidthInst(label, inst)

	case syntax.InstNop:
		return c.generateNopInst(label, inst)

	default:
		return nil, fmt.Errorf("unsupported instruction type: %v", inst.Op)
	}
}

// generateMatchInstWithCaptures generates code for InstMatch with capture extraction.
func (c *Compiler) generateMatchInstWithCaptures(label *jen.Statement, structName string, isBytes bool) ([]jen.Code, error) {
	// Build struct fields from captures array
	structFields := jen.Dict{}

	if isBytes {
		// Zero-copy []byte view
		structFields[jen.Id("Match")] = jen.Id(codegen.InputName).Index(
			jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(1)),
		)
	} else {
		// String (may need conversion from []byte)
		structFields[jen.Id("Match")] = jen.String().Call(
			jen.Id(codegen.InputName).Index(
				jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(1)),
			),
		)
	}

	// Add capture group fields (skip group 0)
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}

		captureStart := i * 2
		captureEnd := i*2 + 1

		// Generate a ternary-like expression using function call to handle invalid captures
		// If start > end (invalid capture), use empty string/slice
		if isBytes {
			structFields[jen.Id(fieldName)] = jen.Func().Params().Index().Byte().Block(
				jen.If(
					jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op("<=").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).
						Op("&&").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).Op("<=").Len(jen.Id(codegen.InputName)),
				).Block(
					jen.Return(jen.Id(codegen.InputName).Index(
						jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)),
					)),
				),
				jen.Return(jen.Nil()),
			).Call()
		} else {
			structFields[jen.Id(fieldName)] = jen.Func().Params().String().Block(
				jen.If(
					jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op("<=").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).
						Op("&&").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).Op("<=").Len(jen.Id(codegen.InputName)),
				).Block(
					jen.Return(jen.String().Call(jen.Id(codegen.InputName).Index(
						jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)),
					))),
				),
				jen.Return(jen.Lit("")),
			).Call()
		}
	}

	return []jen.Code{
		label,
		jen.Block(
			// Set captures[1] to mark end of match
			jen.Id(codegen.CapturesName).Index(jen.Lit(1)).Op("=").Id(codegen.OffsetName),
			jen.Return(
				jen.Op("&").Id(structName).Values(structFields),
				jen.True(),
			),
		),
	}, nil
}

// generateCaptureInst generates code for InstCapture (record capture position).
func (c *Compiler) generateCaptureInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.Id(codegen.CapturesName).Index(jen.Lit(int(inst.Arg))).Op("=").Id(codegen.OffsetName),
			jen.Id(codegen.NextInstructionName).Op("=").Lit(int(inst.Out)),
			jen.Goto().Id(codegen.StepSelectName),
		),
	}, nil
}

// Rune instructions with captures (same as without, but return nil instead of false)
func (c *Compiler) generateRune1InstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").Lit(byte(inst.Rune[0]))).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

func (c *Compiler) generateRuneInstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(c.generateRuneCheck(inst.Rune)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

func (c *Compiler) generateRuneAnyInstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

func (c *Compiler) generateRuneAnyNotNLInstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(
				jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName).Op("||").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("==").Lit('\n'),
			).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// isAnchored checks if the pattern is anchored to the start of text.
// This allows optimizing the search loop to only run at offset 0.
func isAnchored(prog *syntax.Prog) bool {
	if prog == nil {
		return false
	}

	pc := uint32(prog.Start)
	for {
		inst := &prog.Inst[pc]
		switch inst.Op {
		case syntax.InstEmptyWidth:
			// Check for \A or ^ (BeginText)
			if syntax.EmptyOp(inst.Arg)&syntax.EmptyBeginText != 0 {
				return true
			}
			// Continue if it's another empty width assertion (like \b)
			// But wait, if we have \b^, it is anchored.
			// If we have ^\b, it is anchored.
			// If we have \b, it is NOT anchored.
			// So we should continue traversing.
			pc = inst.Out
		case syntax.InstCapture, syntax.InstNop:
			pc = inst.Out
		default:
			// Any other instruction (Match, Rune, Alt, etc.) means we didn't find an anchor
			// at the start of the execution path.
			return false
		}
	}
}

// Package compiler implements the core regex compilation logic.
package compiler

import (
	"fmt"
	"regexp/syntax"

	"github.com/KromDaniel/regengo/internal/codegen"
	"github.com/dave/jennifer/jen"
)

// Config holds the configuration for code generation.
type Config struct {
	Pattern          string
	Name             string
	OutputFile       string
	Package          string
	Program          *syntax.Prog
	RegexAST         *syntax.Regexp // For extracting capture group names
	UsePool          bool           // Enable sync.Pool for stack reuse
	WithCaptures     bool           // Generate capture group functions
	BytesView        bool           // Generate separate []byte struct for FindBytes (zero-copy)
	GenerateTestFile bool           // Generate test file with tests and benchmarks
	TestFileInputs   []string       // Test inputs for generated test file
}

// Compiler generates optimized Go code from regex patterns.
type Compiler struct {
	config               Config
	file                 *jen.File
	captureNames         []string // Capture group names (empty string for unnamed groups)
	hasRepeatingCaptures bool     // True if any capture groups are in repeating context
}

// New creates a new compiler instance.
func New(config Config) *Compiler {
	compiler := &Compiler{
		config: config,
		file:   jen.NewFile(config.Package),
	}

	// Extract capture group names if WithCaptures is enabled
	if config.WithCaptures && config.RegexAST != nil {
		compiler.captureNames = extractCaptureNames(config.RegexAST)
		compiler.hasRepeatingCaptures = hasRepeatingCaptures(config.RegexAST)
	}

	return compiler
}

// NewCompiler is an alias for New for backward compatibility.
func NewCompiler(config Config) *Compiler {
	return New(config)
}

// SetOutputFile sets the output file path.
func (c *Compiler) SetOutputFile(path string) {
	c.config.OutputFile = path
}

// Generate generates the Go code and writes it to the output file.
func (c *Compiler) Generate() error {
	c.file.Comment(fmt.Sprintf("Code generated by regengo for pattern: %s", c.config.Pattern))
	c.file.Comment("DO NOT EDIT.")
	c.file.Line()

	// Add sync.Pool if enabled
	if c.config.UsePool {
		c.generateStackPool()
	}

	// Always generate Match functions
	matchStringCode, err := c.generateMatchFunction()
	if err != nil {
		return fmt.Errorf("failed to generate match function: %w", err)
	}

	// Add MatchString function
	c.file.Func().
		Id(fmt.Sprintf("%sMatchString", c.config.Name)).
		Params(jen.Id(codegen.InputName).String()).
		Params(jen.Bool()).
		Block(matchStringCode...)

	// Add MatchBytes function
	c.file.Func().
		Id(fmt.Sprintf("%sMatchBytes", c.config.Name)).
		Params(jen.Id(codegen.InputName).Index().Byte()).
		Params(jen.Bool()).
		Block(matchStringCode...)

	// Generate capture group functions if pattern has captures
	if c.config.WithCaptures {
		if err := c.generateCaptureFunctions(); err != nil {
			return fmt.Errorf("failed to generate capture functions: %w", err)
		}
	}

	// Save to file
	if err := c.file.Save(c.config.OutputFile); err != nil {
		return fmt.Errorf("failed to save file: %w", err)
	}

	// Generate test file if requested
	if c.config.GenerateTestFile {
		if err := c.generateTestFile(); err != nil {
			return fmt.Errorf("failed to generate test file: %w", err)
		}
	}

	return nil
}

// generateMatchFunction generates the main matching logic.
func (c *Compiler) generateMatchFunction() ([]jen.Code, error) {
	code := []jen.Code{
		// Initialize length
		jen.Id(codegen.InputLenName).Op(":=").Len(jen.Id(codegen.InputName)),
		// Initialize offset
		jen.Id(codegen.OffsetName).Op(":=").Lit(0),
	}

	// Add stack initialization (pooled or regular)
	if c.config.UsePool {
		code = append(code, c.generatePooledStackInit()...)
	} else {
		code = append(code,
			jen.Id(codegen.StackName).Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
		)
	}

	code = append(code,
		// Initialize next instruction
		jen.Id(codegen.NextInstructionName).Op(":=").Lit(int(c.config.Program.Start)),
		// Jump to step selector
		jen.Goto().Id(codegen.StepSelectName),
	)

	// Add backtracking logic
	code = append(code, c.generateBacktracking()...)

	// Add step selector
	code = append(code, c.generateStepSelector()...)

	// Generate instructions
	instructions, err := c.generateInstructions()
	if err != nil {
		return nil, err
	}
	code = append(code, instructions...)

	return code, nil
}

// generateBacktracking generates the backtracking logic.
func (c *Compiler) generateBacktracking() []jen.Code {
	return []jen.Code{
		jen.Id(codegen.TryFallbackName).Op(":"),
		jen.If(jen.Len(jen.Id(codegen.StackName)).Op(">").Lit(0)).Block(
			jen.Id("last").Op(":=").Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Id(codegen.OffsetName).Op("=").Id("last").Index(jen.Lit(0)),
			jen.Id(codegen.NextInstructionName).Op("=").Id("last").Index(jen.Lit(1)),
			jen.Id(codegen.StackName).Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Goto().Id(codegen.StepSelectName),
		).Else().Block(
			jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
				jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
				jen.Id(codegen.OffsetName).Op("++"),
				jen.Goto().Id(codegen.StepSelectName),
			),
			jen.Return(jen.False()),
		),
	}
}

// generateBacktrackingWithCaptures generates the backtracking logic for capture functions.
func (c *Compiler) generateBacktrackingWithCaptures() []jen.Code {
	return []jen.Code{
		jen.Id(codegen.TryFallbackName).Op(":"),
		jen.If(jen.Len(jen.Id(codegen.StackName)).Op(">").Lit(0)).Block(
			jen.Id("last").Op(":=").Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Id(codegen.OffsetName).Op("=").Id("last").Index(jen.Lit(0)),
			jen.Id(codegen.NextInstructionName).Op("=").Id("last").Index(jen.Lit(1)),
			jen.Id(codegen.StackName).Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)),
			jen.Goto().Id(codegen.StepSelectName),
		).Else().Block(
			jen.If(jen.Id(codegen.InputLenName).Op(">").Id(codegen.OffsetName)).Block(
				jen.Id(codegen.OffsetName).Op("++"),
				// Reset captures array for new match attempt
				jen.For(jen.Id("i").Op(":=").Range().Id(codegen.CapturesName)).Block(
					jen.Id(codegen.CapturesName).Index(jen.Id("i")).Op("=").Lit(0),
				),
				// Set capture[0] to mark start of match attempt (after incrementing offset)
				jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op("=").Id(codegen.OffsetName),
				jen.Id(codegen.NextInstructionName).Op("=").Lit(int(c.config.Program.Start)),
				jen.Goto().Id(codegen.StepSelectName),
			),
			jen.Return(jen.Nil(), jen.False()),
		),
	}
}

// generateStepSelector generates the instruction dispatch switch.
func (c *Compiler) generateStepSelector() []jen.Code {
	cases := []jen.Code{}
	for i := range c.config.Program.Inst {
		cases = append(cases,
			jen.Case(jen.Lit(i)).Block(jen.Goto().Id(codegen.InstructionName(uint32(i)))),
		)
	}

	return []jen.Code{
		jen.Id(codegen.StepSelectName).Op(":"),
		jen.Switch(jen.Id(codegen.NextInstructionName)).Block(cases...),
	}
}

// generateInstructions generates code for all instructions.
func (c *Compiler) generateInstructions() ([]jen.Code, error) {
	var code []jen.Code

	for i, inst := range c.config.Program.Inst {
		instCode, err := c.generateInstruction(uint32(i), &inst)
		if err != nil {
			return nil, fmt.Errorf("failed to generate instruction %d: %w", i, err)
		}
		code = append(code, instCode...)
	}

	return code, nil
}

// generateInstruction generates code for a single instruction.
func (c *Compiler) generateInstruction(id uint32, inst *syntax.Inst) ([]jen.Code, error) {
	label := jen.Id(codegen.InstructionName(id)).Op(":")

	switch inst.Op {
	case syntax.InstMatch:
		return []jen.Code{
			label,
			jen.Block(jen.Return(jen.True())),
		}, nil

	case syntax.InstFail:
		return []jen.Code{
			label,
			jen.Block(jen.Return(jen.False())),
		}, nil

	case syntax.InstCapture:
		// For Match functions without captures, just skip capture instructions
		return []jen.Code{
			label,
			jen.Block(
				jen.Goto().Id(codegen.InstructionName(inst.Out)),
			),
		}, nil

	case syntax.InstRune:
		return c.generateRuneInst(label, inst)

	case syntax.InstRune1:
		return c.generateRune1Inst(label, inst)

	case syntax.InstRuneAny:
		return c.generateRuneAnyInst(label, inst)

	case syntax.InstRuneAnyNotNL:
		return c.generateRuneAnyNotNLInst(label, inst)

	case syntax.InstAlt:
		return c.generateAltInst(label, inst)

	case syntax.InstAltMatch:
		return c.generateAltMatchInst(label, inst)

	case syntax.InstEmptyWidth:
		return c.generateEmptyWidthInst(label, inst)

	case syntax.InstNop:
		return c.generateNopInst(label, inst)

	default:
		return nil, fmt.Errorf("unsupported instruction type: %v", inst.Op)
	}
}

// generateRune1Inst generates code for InstRune1 (single rune match).
func (c *Compiler) generateRune1Inst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").Lit(byte(inst.Rune[0]))).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateRuneInst generates code for InstRune (character class match).
func (c *Compiler) generateRuneInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(c.generateRuneCheck(inst.Rune)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateRuneCheck generates the condition for checking if a rune matches.
func (c *Compiler) generateRuneCheck(runes []rune) *jen.Statement {
	if len(runes) == 0 {
		return jen.True()
	}

	// Build condition for character class
	// We need to check if the byte does NOT match any of the ranges
	var stmt *jen.Statement
	for i := 0; i < len(runes); i += 2 {
		lo, hi := runes[i], runes[i+1]
		var condition *jen.Statement
		if lo == hi {
			condition = jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").Lit(byte(lo))
		} else {
			condition = jen.Parens(
				jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("<").Lit(byte(lo)).
					Op("||").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op(">").Lit(byte(hi)),
			)
		}

		if stmt == nil {
			stmt = condition
		} else {
			stmt = stmt.Op("&&").Add(condition)
		}
	}

	return stmt
} // generateRuneAnyInst generates code for InstRuneAny (match any character).
func (c *Compiler) generateRuneAnyInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateRuneAnyNotNLInst generates code for InstRuneAnyNotNL (match any character except newline).
func (c *Compiler) generateRuneAnyNotNLInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(
				jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName).Op("||").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("==").Lit('\n'),
			).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateAltInst generates code for InstAlt (alternation with backtracking).
func (c *Compiler) generateAltInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Cap(jen.Id(codegen.StackName)).Op(">").Len(jen.Id(codegen.StackName))).Block(
				jen.Id(codegen.StackName).Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Len(jen.Id(codegen.StackName)).Op("+").Lit(1)),
				jen.Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)).Index(jen.Lit(0)).Op("=").Id(codegen.OffsetName),
				jen.Id(codegen.StackName).Index(jen.Len(jen.Id(codegen.StackName)).Op("-").Lit(1)).Index(jen.Lit(1)).Op("=").Lit(int(inst.Arg)),
			).Else().Block(
				jen.Id(codegen.StackName).Op("=").Append(jen.Id(codegen.StackName), jen.Index(jen.Lit(2)).Int().Values(jen.Id(codegen.OffsetName), jen.Lit(int(inst.Arg)))),
			),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateAltMatchInst generates code for InstAltMatch (alternation without backtracking).
func (c *Compiler) generateAltMatchInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateEmptyWidthInst generates code for InstEmptyWidth (position assertions).
func (c *Compiler) generateEmptyWidthInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	// For now, simple implementation - just continue
	return []jen.Code{
		label,
		jen.Block(
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateNopInst generates code for InstNop (no operation).
func (c *Compiler) generateNopInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

// generateStackPool generates a sync.Pool for stack reuse.
func (c *Compiler) generateStackPool() {
	poolName := fmt.Sprintf("%sStackPool", codegen.LowerFirst(c.config.Name))

	c.file.Var().Id(poolName).Op("=").Qual("sync", "Pool").Values(jen.Dict{
		jen.Id("New"): jen.Func().Params().Interface().Block(
			jen.Id("stack").Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
			jen.Return(jen.Op("&").Id("stack")),
		),
	})
	c.file.Line()
}

// generatePooledStackInit generates code to get a stack from the pool.
func (c *Compiler) generatePooledStackInit() []jen.Code {
	poolName := fmt.Sprintf("%sStackPool", codegen.LowerFirst(c.config.Name))

	return []jen.Code{
		// Get stack from pool
		jen.Id("stackPtr").Op(":=").Id(poolName).Dot("Get").Call().Assert(jen.Op("*").Index().Index(jen.Lit(2)).Int()),
		jen.Id(codegen.StackName).Op(":=").Parens(jen.Op("*").Id("stackPtr")).Index(jen.Empty(), jen.Lit(0)),
		// Defer return to pool
		jen.Defer().Func().Params().Block(
			// Clear references to prevent memory leaks
			jen.For(jen.Id("i").Op(":=").Range().Id(codegen.StackName)).Block(
				jen.Id(codegen.StackName).Index(jen.Id("i")).Op("=").Index(jen.Lit(2)).Int().Values(jen.Lit(0), jen.Lit(0)),
			),
			jen.Op("*").Id("stackPtr").Op("=").Id(codegen.StackName).Index(jen.Empty(), jen.Lit(0)),
			jen.Id(poolName).Dot("Put").Call(jen.Id("stackPtr")),
		).Call(),
	}
}

// extractCaptureNames extracts capture group names from the regex AST.
func extractCaptureNames(re *syntax.Regexp) []string {
	var names []string
	names = append(names, "") // Group 0 is always the full match (unnamed)

	var walk func(*syntax.Regexp)
	walk = func(r *syntax.Regexp) {
		if r.Op == syntax.OpCapture {
			names = append(names, r.Name)
		}
		for _, sub := range r.Sub {
			walk(sub)
		}
	}

	walk(re)
	return names
}

// hasRepeatingCaptures checks if the regex has any capture groups in repeating context.
// Repeating contexts include *, +, ?, and {n,m} quantifiers.
// Note: Standard regex behavior (including Go's stdlib) captures only the LAST match
// from repeating groups. For example, (\w)+ matching "abc" will capture "c", not ["a","b","c"].
func hasRepeatingCaptures(re *syntax.Regexp) bool {
	return walkCheckRepeating(re, false)
}

// walkCheckRepeating recursively walks the AST to detect captures in repeating context.
func walkCheckRepeating(re *syntax.Regexp, inRepeat bool) bool {
	// If this is a capture and we're in a repeating context
	if re.Op == syntax.OpCapture && inRepeat {
		return true
	}

	// Check if this node introduces repetition
	isRepeating := false
	switch re.Op {
	case syntax.OpStar, syntax.OpPlus, syntax.OpQuest, syntax.OpRepeat:
		isRepeating = true
	}

	// Recursively check children
	for _, sub := range re.Sub {
		if walkCheckRepeating(sub, inRepeat || isRepeating) {
			return true
		}
	}

	return false
}

// generateCaptureFunctions generates Find and FindAll functions with capture groups.
func (c *Compiler) generateCaptureFunctions() error {
	// Generate capture struct
	structName := fmt.Sprintf("%sMatch", c.config.Name)
	c.generateCaptureStruct(structName)

	// Generate FindString function
	if err := c.generateFindStringFunction(structName); err != nil {
		return fmt.Errorf("failed to generate FindString: %w", err)
	}

	// Generate FindBytes function
	if c.config.BytesView {
		bytesStructName := fmt.Sprintf("%sMatchBytes", c.config.Name)
		c.generateCaptureStructBytes(bytesStructName)
		if err := c.generateFindBytesFunction(bytesStructName); err != nil {
			return fmt.Errorf("failed to generate FindBytes: %w", err)
		}
	} else {
		// Use same struct, convert []byte to string
		if err := c.generateFindBytesFunction(structName); err != nil {
			return fmt.Errorf("failed to generate FindBytes: %w", err)
		}
	}

	return nil
}

// generateCaptureStruct generates the Match struct with string fields.
func (c *Compiler) generateCaptureStruct(structName string) {
	// Add warning comment if there are repeating captures
	if c.hasRepeatingCaptures {
		c.file.Comment("Note: This pattern contains capture groups in repeating/optional context.")
		c.file.Comment("Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).")
		c.file.Comment("For example: (\\w)+ matching 'abc' captures 'c', not ['a','b','c'].")
		c.file.Comment("Optional groups (?) return empty string when not matched.")
		c.file.Line()
	}

	fields := []jen.Code{
		jen.Id("Match").String().Comment("Full match"),
	}

	// Add fields for each capture group (skip group 0 which is the full match)
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}
		fields = append(fields, jen.Id(fieldName).String())
	}

	c.file.Type().Id(structName).Struct(fields...)
	c.file.Line()
}

// generateCaptureStructBytes generates the Match struct with []byte fields for BytesView.
func (c *Compiler) generateCaptureStructBytes(structName string) {
	// Add warning comment if there are repeating captures
	if c.hasRepeatingCaptures {
		c.file.Comment("Note: This pattern contains capture groups in repeating/optional context.")
		c.file.Comment("Go's regex engine captures only the LAST match from repeating groups (* + {n,m}).")
		c.file.Comment("For example: (\\w)+ matching 'abc' captures 'c', not ['a','b','c'].")
		c.file.Comment("Optional groups (?) return empty slice when not matched.")
		c.file.Line()
	}

	fields := []jen.Code{
		jen.Id("Match").Index().Byte().Comment("Full match"),
	}

	// Add fields for each capture group (skip group 0 which is the full match)
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}
		fields = append(fields, jen.Id(fieldName).Index().Byte())
	}

	c.file.Type().Id(structName).Struct(fields...)
	c.file.Line()
}

// generateFindStringFunction generates the FindString function with captures.
func (c *Compiler) generateFindStringFunction(structName string) error {
	code, err := c.generateFindFunction(structName, false)
	if err != nil {
		return err
	}

	c.file.Func().
		Id(fmt.Sprintf("%sFindString", c.config.Name)).
		Params(jen.Id(codegen.InputName).String()).
		Params(jen.Op("*").Id(structName), jen.Bool()).
		Block(code...)

	return nil
}

// generateFindBytesFunction generates the FindBytes function with captures.
func (c *Compiler) generateFindBytesFunction(structName string) error {
	code, err := c.generateFindFunction(structName, c.config.BytesView)
	if err != nil {
		return err
	}

	c.file.Func().
		Id(fmt.Sprintf("%sFindBytes", c.config.Name)).
		Params(jen.Id(codegen.InputName).Index().Byte()).
		Params(jen.Op("*").Id(structName), jen.Bool()).
		Block(code...)

	return nil
}

// generateFindFunction generates the main Find logic with captures.
func (c *Compiler) generateFindFunction(structName string, isBytes bool) ([]jen.Code, error) {
	numCaptures := c.config.Program.NumCap

	code := []jen.Code{
		// Initialize length
		jen.Id(codegen.InputLenName).Op(":=").Len(jen.Id(codegen.InputName)),
		// Initialize offset
		jen.Id(codegen.OffsetName).Op(":=").Lit(0),
		// Initialize captures array
		jen.Id(codegen.CapturesName).Op(":=").Make(jen.Index().Int(), jen.Lit(numCaptures)),
	}

	// Add stack initialization (pooled or regular)
	if c.config.UsePool {
		code = append(code, c.generatePooledStackInit()...)
	} else {
		code = append(code,
			jen.Id(codegen.StackName).Op(":=").Make(jen.Index().Index(jen.Lit(2)).Int(), jen.Lit(0), jen.Lit(32)),
		)
	}

	code = append(code,
		// Set captures[0] to mark start of first match attempt
		jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op("=").Lit(0),
		// Initialize next instruction
		jen.Id(codegen.NextInstructionName).Op(":=").Lit(int(c.config.Program.Start)),
		// Jump to step selector
		jen.Goto().Id(codegen.StepSelectName),
	)

	// Add backtracking logic (with nil return for captures)
	code = append(code, c.generateBacktrackingWithCaptures()...)

	// Add step selector
	code = append(code, c.generateStepSelector()...)

	// Generate instructions with captures
	instructions, err := c.generateInstructionsWithCaptures(structName, isBytes)
	if err != nil {
		return nil, err
	}
	code = append(code, instructions...)

	return code, nil
}

// generateInstructionsWithCaptures generates code for all instructions with capture support.
func (c *Compiler) generateInstructionsWithCaptures(structName string, isBytes bool) ([]jen.Code, error) {
	var code []jen.Code

	for i, inst := range c.config.Program.Inst {
		instCode, err := c.generateInstructionWithCaptures(uint32(i), &inst, structName, isBytes)
		if err != nil {
			return nil, fmt.Errorf("failed to generate instruction %d: %w", i, err)
		}
		code = append(code, instCode...)
	}

	return code, nil
}

// generateInstructionWithCaptures generates code for a single instruction with capture support.
func (c *Compiler) generateInstructionWithCaptures(id uint32, inst *syntax.Inst, structName string, isBytes bool) ([]jen.Code, error) {
	label := jen.Id(codegen.InstructionName(id)).Op(":")

	switch inst.Op {
	case syntax.InstMatch:
		return c.generateMatchInstWithCaptures(label, structName, isBytes)

	case syntax.InstCapture:
		return c.generateCaptureInst(label, inst)

	case syntax.InstFail:
		return []jen.Code{
			label,
			jen.Block(jen.Return(jen.Nil(), jen.False())),
		}, nil

	case syntax.InstRune:
		return c.generateRuneInstWithCaptures(label, inst)

	case syntax.InstRune1:
		return c.generateRune1InstWithCaptures(label, inst)

	case syntax.InstRuneAny:
		return c.generateRuneAnyInstWithCaptures(label, inst)

	case syntax.InstRuneAnyNotNL:
		return c.generateRuneAnyNotNLInstWithCaptures(label, inst)

	case syntax.InstAlt:
		return c.generateAltInst(label, inst)

	case syntax.InstAltMatch:
		return c.generateAltMatchInst(label, inst)

	case syntax.InstEmptyWidth:
		return c.generateEmptyWidthInst(label, inst)

	case syntax.InstNop:
		return c.generateNopInst(label, inst)

	default:
		return nil, fmt.Errorf("unsupported instruction type: %v", inst.Op)
	}
}

// generateMatchInstWithCaptures generates code for InstMatch with capture extraction.
func (c *Compiler) generateMatchInstWithCaptures(label *jen.Statement, structName string, isBytes bool) ([]jen.Code, error) {
	// Build struct fields from captures array
	structFields := jen.Dict{}

	if isBytes {
		// Zero-copy []byte view
		structFields[jen.Id("Match")] = jen.Id(codegen.InputName).Index(
			jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(1)),
		)
	} else {
		// String (may need conversion from []byte)
		structFields[jen.Id("Match")] = jen.String().Call(
			jen.Id(codegen.InputName).Index(
				jen.Id(codegen.CapturesName).Index(jen.Lit(0)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(1)),
			),
		)
	}

	// Add capture group fields (skip group 0)
	for i := 1; i < len(c.captureNames); i++ {
		fieldName := c.captureNames[i]
		if fieldName == "" {
			fieldName = fmt.Sprintf("Group%d", i)
		} else {
			fieldName = codegen.UpperFirst(fieldName)
		}

		captureStart := i * 2
		captureEnd := i*2 + 1

		// Generate a ternary-like expression using function call to handle invalid captures
		// If start > end (invalid capture), use empty string/slice
		if isBytes {
			structFields[jen.Id(fieldName)] = jen.Func().Params().Index().Byte().Block(
				jen.If(
					jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op("<=").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).
						Op("&&").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).Op("<=").Len(jen.Id(codegen.InputName)),
				).Block(
					jen.Return(jen.Id(codegen.InputName).Index(
						jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)),
					)),
				),
				jen.Return(jen.Nil()),
			).Call()
		} else {
			structFields[jen.Id(fieldName)] = jen.Func().Params().String().Block(
				jen.If(
					jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op("<=").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).
						Op("&&").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)).Op("<=").Len(jen.Id(codegen.InputName)),
				).Block(
					jen.Return(jen.String().Call(jen.Id(codegen.InputName).Index(
						jen.Id(codegen.CapturesName).Index(jen.Lit(captureStart)).Op(":").Id(codegen.CapturesName).Index(jen.Lit(captureEnd)),
					))),
				),
				jen.Return(jen.Lit("")),
			).Call()
		}
	}

	return []jen.Code{
		label,
		jen.Block(
			// Set captures[1] to mark end of match
			jen.Id(codegen.CapturesName).Index(jen.Lit(1)).Op("=").Id(codegen.OffsetName),
			jen.Return(
				jen.Op("&").Id(structName).Values(structFields),
				jen.True(),
			),
		),
	}, nil
}

// generateCaptureInst generates code for InstCapture (record capture position).
func (c *Compiler) generateCaptureInst(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.Id(codegen.CapturesName).Index(jen.Lit(int(inst.Arg))).Op("=").Id(codegen.OffsetName),
			jen.Id(codegen.NextInstructionName).Op("=").Lit(int(inst.Out)),
			jen.Goto().Id(codegen.StepSelectName),
		),
	}, nil
}

// Rune instructions with captures (same as without, but return nil instead of false)
func (c *Compiler) generateRune1InstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(jen.Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("!=").Lit(byte(inst.Rune[0]))).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

func (c *Compiler) generateRuneInstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
		),
		jen.Block(
			jen.If(c.generateRuneCheck(inst.Rune)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

func (c *Compiler) generateRuneAnyInstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName)).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

func (c *Compiler) generateRuneAnyNotNLInstWithCaptures(label *jen.Statement, inst *syntax.Inst) ([]jen.Code, error) {
	return []jen.Code{
		label,
		jen.Block(
			jen.If(
				jen.Id(codegen.InputLenName).Op("<=").Id(codegen.OffsetName).Op("||").
					Id(codegen.InputName).Index(jen.Id(codegen.OffsetName)).Op("==").Lit('\n'),
			).Block(
				jen.Goto().Id(codegen.TryFallbackName),
			),
			jen.Id(codegen.OffsetName).Op("++"),
			jen.Goto().Id(codegen.InstructionName(inst.Out)),
		),
	}, nil
}

package compiler

import (
	"fmt"

	"github.com/KromDaniel/regengo/internal/codegen"
	"github.com/dave/jennifer/jen"
)

// generateTestFile generates a test file with tests and benchmarks against standard regexp.
func (c *Compiler) generateTestFile() error {
	testFile := jen.NewFile(c.config.Package)

	testFile.Comment("Code generated by regengo")
	testFile.Comment("Tests and benchmarks for pattern: " + c.config.Pattern)
	testFile.Line()

	testFile.ImportName("testing", "testing")
	testFile.ImportName("regexp", "regexp")
	testFile.Line()

	// Create regexp variable for comparison
	regexpVarName := fmt.Sprintf("%sRegexp", codegen.LowerFirst(c.config.Name))
	testFile.Var().Id(regexpVarName).Op("=").Qual("regexp", "MustCompile").Call(jen.Lit(c.config.Pattern))
	testFile.Line()

	// Test inputs
	testFile.Var().Id("testInputs").Op("=").Index().String().Values(
		jen.ListFunc(func(g *jen.Group) {
			for _, input := range c.config.TestFileInputs {
				g.Lit(input)
			}
		}),
	)
	testFile.Line()

	// Generate TestMatchString
	testFile.Func().Id(fmt.Sprintf("Test%sMatchString", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Id("expected").Op(":=").Id(regexpVarName).Dot("MatchString").Call(jen.Id("input")),
			jen.Id("got").Op(":=").Id(c.config.Name).Values().Dot("MatchString").Call(jen.Id("input")),
			jen.If(jen.Id("got").Op("!=").Id("expected")).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("MatchString(%q) = %v, want %v"),
					jen.Id("input"),
					jen.Id("got"),
					jen.Id("expected"),
				),
			),
		),
	)
	testFile.Line()

	// Generate TestMatchBytes
	testFile.Func().Id(fmt.Sprintf("Test%sMatchBytes", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Id("inputBytes").Op(":=").Index().Byte().Call(jen.Id("input")),
			jen.Id("expected").Op(":=").Id(regexpVarName).Dot("Match").Call(jen.Id("inputBytes")),
			jen.Id("got").Op(":=").Id(c.config.Name).Values().Dot("MatchBytes").Call(jen.Id("inputBytes")),
			jen.If(jen.Id("got").Op("!=").Id("expected")).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("MatchBytes(%q) = %v, want %v"),
					jen.Id("input"),
					jen.Id("got"),
					jen.Id("expected"),
				),
			),
		),
	)
	testFile.Line()

	// Generate capture group tests if applicable
	if c.config.WithCaptures {
		// TestFindString
		testFile.Func().Id(fmt.Sprintf("Test%sFindString", c.config.Name)).Params(
			jen.Id("t").Op("*").Qual("testing", "T"),
		).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("expectedMatches").Op(":=").Id(regexpVarName).Dot("FindStringSubmatch").Call(jen.Id("input")),
				jen.Id("result").Op(",").Id("ok").Op(":=").Id(c.config.Name).Values().Dot("FindString").Call(jen.Id("input")),
				jen.Line(),
				jen.If(jen.Len(jen.Id("expectedMatches")).Op(">").Lit(0)).Block(
					jen.If(jen.Op("!").Id("ok")).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindString(%q) returned false, expected match"),
							jen.Id("input"),
						),
						jen.Continue(),
					),
					// Check full match
					jen.If(jen.Id("result").Dot("Match").Op("!=").Id("expectedMatches").Index(jen.Lit(0))).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindString(%q).Match = %q, want %q"),
							jen.Id("input"),
							jen.Id("result").Dot("Match"),
							jen.Id("expectedMatches").Index(jen.Lit(0)),
						),
					),
					// Check each capture group
					jen.BlockFunc(func(g *jen.Group) {
						usedNames := make(map[string]bool)
						usedNames["Match"] = true // Reserve for full match
						for i := 1; i < len(c.captureNames); i++ {
							captureName := c.captureNames[i]
							if captureName == "" {
								captureName = fmt.Sprintf("Group%d", i)
							} else {
								captureName = codegen.UpperFirst(captureName)
							}
							// Handle collisions by adding group number suffix
							if usedNames[captureName] {
								captureName = fmt.Sprintf("%s%d", captureName, i)
							}
							usedNames[captureName] = true
							// Compare capture group with stdlib result
							g.If(jen.Id("result").Dot(captureName).Op("!=").Id("expectedMatches").Index(jen.Lit(i))).Block(
								jen.Id("t").Dot("Errorf").Call(
									jen.Lit(fmt.Sprintf("FindString(%%q).%s = %%q, want %%q", captureName)),
									jen.Id("input"),
									jen.Id("result").Dot(captureName),
									jen.Id("expectedMatches").Index(jen.Lit(i)),
								),
							)
						}
					}),
				).Else().Block(
					jen.If(jen.Id("ok")).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindString(%q) returned true, expected no match"),
							jen.Id("input"),
						),
					),
				),
			),
		)
		testFile.Line()

		// TestFindAllString
		testFile.Func().Id(fmt.Sprintf("Test%sFindAllString", c.config.Name)).Params(
			jen.Id("t").Op("*").Qual("testing", "T"),
		).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("expectedAll").Op(":=").Id(regexpVarName).Dot("FindAllStringSubmatch").Call(jen.Id("input"), jen.Lit(-1)),
				jen.Id("results").Op(":=").Id(c.config.Name).Values().Dot("FindAllString").Call(jen.Id("input"), jen.Lit(-1)),
				jen.Line(),
				// Check length matches
				jen.If(jen.Len(jen.Id("results")).Op("!=").Len(jen.Id("expectedAll"))).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("FindAllString(%q, -1) returned %d results, want %d"),
						jen.Id("input"),
						jen.Len(jen.Id("results")),
						jen.Len(jen.Id("expectedAll")),
					),
					jen.Continue(),
				),
				// Check each match
				jen.For(jen.Id("i").Op(":=").Range().Id("results")).Block(
					jen.If(jen.Id("results").Index(jen.Id("i")).Dot("Match").Op("!=").Id("expectedAll").Index(jen.Id("i")).Index(jen.Lit(0))).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindAllString(%q, -1)[%d].Match = %q, want %q"),
							jen.Id("input"),
							jen.Id("i"),
							jen.Id("results").Index(jen.Id("i")).Dot("Match"),
							jen.Id("expectedAll").Index(jen.Id("i")).Index(jen.Lit(0)),
						),
					),
					// Check each capture group for this match
					jen.BlockFunc(func(g *jen.Group) {
						usedNames := make(map[string]bool)
						usedNames["Match"] = true // Reserve for full match
						for j := 1; j < len(c.captureNames); j++ {
							captureName := c.captureNames[j]
							if captureName == "" {
								captureName = fmt.Sprintf("Group%d", j)
							} else {
								captureName = codegen.UpperFirst(captureName)
							}
							// Handle collisions by adding group number suffix
							if usedNames[captureName] {
								captureName = fmt.Sprintf("%s%d", captureName, j)
							}
							usedNames[captureName] = true
							g.If(jen.Id("results").Index(jen.Id("i")).Dot(captureName).Op("!=").Id("expectedAll").Index(jen.Id("i")).Index(jen.Lit(j))).Block(
								jen.Id("t").Dot("Errorf").Call(
									jen.Lit(fmt.Sprintf("FindAllString(%%q, -1)[%%d].%s = %%q, want %%q", captureName)),
									jen.Id("input"),
									jen.Id("i"),
									jen.Id("results").Index(jen.Id("i")).Dot(captureName),
									jen.Id("expectedAll").Index(jen.Id("i")).Index(jen.Lit(j)),
								),
							)
						}
					}),
				),
			),
		)
		testFile.Line()
	}

	// Generate BenchmarkMatchString
	testFile.Func().Id(fmt.Sprintf("Benchmark%sMatchString", c.config.Name)).Params(
		jen.Id("b").Op("*").Qual("testing", "B"),
	).Block(
		jen.Id("b").Dot("ReportAllocs").Call(),
		jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("_").Op("=").Id(c.config.Name).Values().Dot("MatchString").Call(jen.Id("input")),
			),
		),
	)
	testFile.Line()

	// Generate BenchmarkStdlibMatchString for comparison
	testFile.Func().Id(fmt.Sprintf("BenchmarkStdlib%sMatchString", c.config.Name)).Params(
		jen.Id("b").Op("*").Qual("testing", "B"),
	).Block(
		jen.Id("b").Dot("ReportAllocs").Call(),
		jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("_").Op("=").Id(regexpVarName).Dot("MatchString").Call(jen.Id("input")),
			),
		),
	)
	testFile.Line()

	// Generate capture group benchmarks if applicable
	if c.config.WithCaptures {
		// BenchmarkFindString
		testFile.Func().Id(fmt.Sprintf("Benchmark%sFindString", c.config.Name)).Params(
			jen.Id("b").Op("*").Qual("testing", "B"),
		).Block(
			jen.Id("b").Dot("ReportAllocs").Call(),
			jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
				jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
					jen.Id("_").Op(",").Id("_").Op("=").Id(c.config.Name).Values().Dot("FindString").Call(jen.Id("input")),
				),
			),
		)
		testFile.Line()

		// BenchmarkStdlibFindStringSubmatch
		testFile.Func().Id(fmt.Sprintf("BenchmarkStdlib%sFindStringSubmatch", c.config.Name)).Params(
			jen.Id("b").Op("*").Qual("testing", "B"),
		).Block(
			jen.Id("b").Dot("ReportAllocs").Call(),
			jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
				jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
					jen.Id("_").Op("=").Id(regexpVarName).Dot("FindStringSubmatch").Call(jen.Id("input")),
				),
			),
		)
		testFile.Line()

		// Add streaming tests
		c.generateStreamingTests(testFile, regexpVarName)

		// Add replace tests if replacers are configured
		if len(c.config.TestFileReplacers) > 0 {
			c.generateReplaceTests(testFile, regexpVarName)
		}
	}

	// Determine test file path
	testFilePath := c.config.OutputFile
	if len(testFilePath) > 3 && testFilePath[len(testFilePath)-3:] == ".go" {
		testFilePath = testFilePath[:len(testFilePath)-3] + "_test.go"
	} else {
		testFilePath = testFilePath + "_test.go"
	}

	// Save test file
	if err := testFile.Save(testFilePath); err != nil {
		return fmt.Errorf("failed to save test file: %w", err)
	}

	return nil
}

// generateStreamingTests generates streaming API tests for the test file.
func (c *Compiler) generateStreamingTests(testFile *jen.File, regexpVarName string) {
	streamPkg := "github.com/KromDaniel/regengo/stream"
	bytesStructName := fmt.Sprintf("%sBytesResult", c.config.Name)

	// TestFindReader - compare streaming results with stdlib FindAllStringSubmatch
	testFile.Func().Id(fmt.Sprintf("Test%sFindReader", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Comment("Get expected matches from stdlib"),
			jen.Id("expectedAll").Op(":=").Id(regexpVarName).Dot("FindAllString").Call(jen.Id("input"), jen.Lit(-1)),
			jen.Line(),
			jen.Comment("Get matches from streaming API"),
			jen.Var().Id("streamMatches").Index().String(),
			jen.Id("err").Op(":=").Id(c.config.Name).Values().Dot("FindReader").Call(
				jen.Qual("strings", "NewReader").Call(jen.Id("input")),
				jen.Qual(streamPkg, "Config").Values(),
				jen.Func().Params(jen.Id("m").Qual(streamPkg, "Match").Types(jen.Op("*").Id(bytesStructName))).Bool().Block(
					jen.Id("streamMatches").Op("=").Append(jen.Id("streamMatches"), jen.String().Call(jen.Id("m").Dot("Result").Dot("Match"))),
					jen.Return(jen.True()),
				),
			),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("FindReader(%q) error: %v"),
					jen.Id("input"),
					jen.Id("err"),
				),
				jen.Continue(),
			),
			jen.Line(),
			jen.Comment("Compare results"),
			jen.If(jen.Len(jen.Id("streamMatches")).Op("!=").Len(jen.Id("expectedAll"))).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("FindReader(%q) got %d matches, want %d"),
					jen.Id("input"),
					jen.Len(jen.Id("streamMatches")),
					jen.Len(jen.Id("expectedAll")),
				),
				jen.Continue(),
			),
			jen.For(jen.Id("i").Op(":=").Range().Id("streamMatches")).Block(
				jen.If(jen.Id("streamMatches").Index(jen.Id("i")).Op("!=").Id("expectedAll").Index(jen.Id("i"))).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("FindReader(%q)[%d] = %q, want %q"),
						jen.Id("input"),
						jen.Id("i"),
						jen.Id("streamMatches").Index(jen.Id("i")),
						jen.Id("expectedAll").Index(jen.Id("i")),
					),
				),
			),
		),
	)
	testFile.Line()

	// TestFindReaderCount
	testFile.Func().Id(fmt.Sprintf("Test%sFindReaderCount", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Id("expectedAll").Op(":=").Id(regexpVarName).Dot("FindAllString").Call(jen.Id("input"), jen.Lit(-1)),
			jen.Id("expected").Op(":=").Int64().Call(jen.Len(jen.Id("expectedAll"))),
			jen.Line(),
			jen.List(jen.Id("count"), jen.Id("err")).Op(":=").Id(c.config.Name).Values().Dot("FindReaderCount").Call(
				jen.Qual("strings", "NewReader").Call(jen.Id("input")),
				jen.Qual(streamPkg, "Config").Values(),
			),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("FindReaderCount(%q) error: %v"),
					jen.Id("input"),
					jen.Id("err"),
				),
				jen.Continue(),
			),
			jen.If(jen.Id("count").Op("!=").Id("expected")).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("FindReaderCount(%q) = %d, want %d"),
					jen.Id("input"),
					jen.Id("count"),
					jen.Id("expected"),
				),
			),
		),
	)
	testFile.Line()

	// TestFindReaderFirst
	testFile.Func().Id(fmt.Sprintf("Test%sFindReaderFirst", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Id("expected").Op(":=").Id(regexpVarName).Dot("FindString").Call(jen.Id("input")),
			jen.Line(),
			jen.List(jen.Id("result"), jen.Id("_"), jen.Id("err")).Op(":=").Id(c.config.Name).Values().Dot("FindReaderFirst").Call(
				jen.Qual("strings", "NewReader").Call(jen.Id("input")),
				jen.Qual(streamPkg, "Config").Values(),
			),
			jen.If(jen.Id("err").Op("!=").Nil()).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("FindReaderFirst(%q) error: %v"),
					jen.Id("input"),
					jen.Id("err"),
				),
				jen.Continue(),
			),
			jen.Line(),
			jen.If(jen.Id("expected").Op("==").Lit("")).Block(
				jen.If(jen.Id("result").Op("!=").Nil()).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("FindReaderFirst(%q) = %q, want no match"),
						jen.Id("input"),
						jen.String().Call(jen.Id("result").Dot("Match")),
					),
				),
			).Else().Block(
				jen.If(jen.Id("result").Op("==").Nil()).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("FindReaderFirst(%q) = nil, want %q"),
						jen.Id("input"),
						jen.Id("expected"),
					),
				).Else().If(jen.String().Call(jen.Id("result").Dot("Match")).Op("!=").Id("expected")).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("FindReaderFirst(%q) = %q, want %q"),
						jen.Id("input"),
						jen.String().Call(jen.Id("result").Dot("Match")),
						jen.Id("expected"),
					),
				),
			),
		),
	)
	testFile.Line()

	// TestMatchLengthInfo
	testFile.Func().Id(fmt.Sprintf("Test%sMatchLengthInfo", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.List(jen.Id("minLen"), jen.Id("maxLen")).Op(":=").Id(c.config.Name).Values().Dot("MatchLengthInfo").Call(),
		jen.Comment("Just verify we get sensible values"),
		jen.If(jen.Id("minLen").Op("<").Lit(0)).Block(
			jen.Id("t").Dot("Errorf").Call(jen.Lit("MinMatchLen = %d, expected >= 0"), jen.Id("minLen")),
		),
		jen.If(jen.Id("maxLen").Op("!=").Lit(-1).Op("&&").Id("maxLen").Op("<").Id("minLen")).Block(
			jen.Id("t").Dot("Errorf").Call(jen.Lit("MaxMatchLen = %d < MinMatchLen = %d"), jen.Id("maxLen"), jen.Id("minLen")),
		),
	)
	testFile.Line()
}

// generateReplaceTests generates Replace API tests for the test file.
// Tests compare regengo's ReplaceAllString with stdlib's ReplaceAllString.
func (c *Compiler) generateReplaceTests(testFile *jen.File, regexpVarName string) {
	replacers := c.config.TestFileReplacers

	// Generate test replacers variable
	testFile.Var().Id("testReplacers").Op("=").Index().String().Values(
		jen.ListFunc(func(g *jen.Group) {
			for _, r := range replacers {
				g.Lit(r)
			}
		}),
	)
	testFile.Line()

	// Generate helper function to convert regengo template to stdlib format
	// regengo uses $name, stdlib uses ${name}
	testFile.Comment("convertToStdlibTemplate converts regengo template syntax to stdlib syntax.")
	testFile.Comment("regengo: $name, $1, $0 -> stdlib: ${name}, ${1}, ${0}")
	testFile.Func().Id("convertToStdlibTemplate").Params(jen.Id("template").String()).String().Block(
		jen.Var().Id("result").Qual("strings", "Builder"),
		jen.Id("i").Op(":=").Lit(0),
		jen.For(jen.Id("i").Op("<").Len(jen.Id("template"))).Block(
			jen.If(jen.Id("template").Index(jen.Id("i")).Op("!=").LitRune('$')).Block(
				jen.Id("result").Dot("WriteByte").Call(jen.Id("template").Index(jen.Id("i"))),
				jen.Id("i").Op("++"),
				jen.Continue(),
			),
			jen.Comment("Found $"),
			jen.If(jen.Id("i").Op("+").Lit(1).Op(">=").Len(jen.Id("template"))).Block(
				jen.Id("result").Dot("WriteByte").Call(jen.LitRune('$')),
				jen.Id("i").Op("++"),
				jen.Continue(),
			),
			jen.Id("next").Op(":=").Id("template").Index(jen.Id("i").Op("+").Lit(1)),
			jen.Switch(jen.Empty()).Block(
				jen.Case(jen.Id("next").Op("==").LitRune('$')).Block(
					jen.Comment("$$ -> $"),
					jen.Id("result").Dot("WriteString").Call(jen.Lit("$$")),
					jen.Id("i").Op("+=").Lit(2),
				),
				jen.Case(jen.Id("next").Op("==").LitRune('{')).Block(
					jen.Comment("${...} -> ${...} (already in stdlib format)"),
					jen.Id("closeIdx").Op(":=").Qual("strings", "Index").Call(jen.Id("template").Index(jen.Id("i").Op(":")), jen.Lit("}")),
					jen.If(jen.Id("closeIdx").Op("==").Lit(-1)).Block(
						jen.Id("result").Dot("WriteByte").Call(jen.LitRune('$')),
						jen.Id("i").Op("++"),
					).Else().Block(
						jen.Id("result").Dot("WriteString").Call(jen.Id("template").Index(jen.Id("i").Op(":").Id("i").Op("+").Id("closeIdx").Op("+").Lit(1))),
						jen.Id("i").Op("+=").Id("closeIdx").Op("+").Lit(1),
					),
				),
				jen.Case(jen.Id("next").Op(">=").LitRune('0').Op("&&").Id("next").Op("<=").LitRune('9')).Block(
					jen.Comment("$0, $1, etc -> ${0}, ${1}, etc"),
					jen.Id("j").Op(":=").Id("i").Op("+").Lit(1),
					jen.For(jen.Id("j").Op("<").Len(jen.Id("template")).Op("&&").Id("template").Index(jen.Id("j")).Op(">=").LitRune('0').Op("&&").Id("template").Index(jen.Id("j")).Op("<=").LitRune('9')).Block(
						jen.Id("j").Op("++"),
					),
					jen.Id("result").Dot("WriteString").Call(jen.Lit("${")),
					jen.Id("result").Dot("WriteString").Call(jen.Id("template").Index(jen.Id("i").Op("+").Lit(1).Op(":").Id("j"))),
					jen.Id("result").Dot("WriteByte").Call(jen.LitRune('}')),
					jen.Id("i").Op("=").Id("j"),
				),
				jen.Case(
					jen.Id("next").Op("==").LitRune('_').Op("||").
						Parens(jen.Id("next").Op(">=").LitRune('a').Op("&&").Id("next").Op("<=").LitRune('z')).Op("||").
						Parens(jen.Id("next").Op(">=").LitRune('A').Op("&&").Id("next").Op("<=").LitRune('Z')),
				).Block(
					jen.Comment("$name -> ${name}"),
					jen.Id("j").Op(":=").Id("i").Op("+").Lit(1),
					jen.For(jen.Id("j").Op("<").Len(jen.Id("template")).Op("&&").Parens(
						jen.Id("template").Index(jen.Id("j")).Op("==").LitRune('_').Op("||").
							Parens(jen.Id("template").Index(jen.Id("j")).Op(">=").LitRune('a').Op("&&").Id("template").Index(jen.Id("j")).Op("<=").LitRune('z')).Op("||").
							Parens(jen.Id("template").Index(jen.Id("j")).Op(">=").LitRune('A').Op("&&").Id("template").Index(jen.Id("j")).Op("<=").LitRune('Z')).Op("||").
							Parens(jen.Id("template").Index(jen.Id("j")).Op(">=").LitRune('0').Op("&&").Id("template").Index(jen.Id("j")).Op("<=").LitRune('9')),
					)).Block(
						jen.Id("j").Op("++"),
					),
					jen.Id("result").Dot("WriteString").Call(jen.Lit("${")),
					jen.Id("result").Dot("WriteString").Call(jen.Id("template").Index(jen.Id("i").Op("+").Lit(1).Op(":").Id("j"))),
					jen.Id("result").Dot("WriteByte").Call(jen.LitRune('}')),
					jen.Id("i").Op("=").Id("j"),
				),
				jen.Default().Block(
					jen.Comment("Lone $ followed by something else"),
					jen.Id("result").Dot("WriteByte").Call(jen.LitRune('$')),
					jen.Id("i").Op("++"),
				),
			),
		),
		jen.Return(jen.Id("result").Dot("String").Call()),
	)
	testFile.Line()

	// TestReplaceAllString - compare runtime Replace with stdlib
	testFile.Func().Id(fmt.Sprintf("Test%sReplaceAllString", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("replacer")).Op(":=").Range().Id("testReplacers")).Block(
				jen.Id("stdlibTemplate").Op(":=").Id("convertToStdlibTemplate").Call(jen.Id("replacer")),
				jen.Id("expected").Op(":=").Id(regexpVarName).Dot("ReplaceAllString").Call(jen.Id("input"), jen.Id("stdlibTemplate")),
				jen.Id("got").Op(":=").Id(c.config.Name).Values().Dot("ReplaceAllString").Call(jen.Id("input"), jen.Id("replacer")),
				jen.If(jen.Id("got").Op("!=").Id("expected")).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("ReplaceAllString(%q, %q) = %q, want %q"),
						jen.Id("input"),
						jen.Id("replacer"),
						jen.Id("got"),
						jen.Id("expected"),
					),
				),
			),
		),
	)
	testFile.Line()

	// TestReplaceFirstString - compare runtime ReplaceFirst with stdlib (using Func to only replace first)
	testFile.Func().Id(fmt.Sprintf("Test%sReplaceFirstString", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("replacer")).Op(":=").Range().Id("testReplacers")).Block(
				jen.Comment("Simulate ReplaceFirst using ReplaceAllStringFunc with a once flag"),
				jen.Id("stdlibTemplate").Op(":=").Id("convertToStdlibTemplate").Call(jen.Id("replacer")),
				jen.Id("replaced").Op(":=").False(),
				jen.Id("expected").Op(":=").Id(regexpVarName).Dot("ReplaceAllStringFunc").Call(
					jen.Id("input"),
					jen.Func().Params(jen.Id("match").String()).String().Block(
						jen.If(jen.Id("replaced")).Block(
							jen.Return(jen.Id("match")),
						),
						jen.Id("replaced").Op("=").True(),
						jen.Comment("Use Expand to apply template to single match"),
						jen.Id("submatch").Op(":=").Id(regexpVarName).Dot("FindStringSubmatchIndex").Call(jen.Id("match")),
						jen.If(jen.Id("submatch").Op("==").Nil()).Block(
							jen.Return(jen.Id("match")),
						),
						jen.Var().Id("dst").Index().Byte(),
						jen.Id("dst").Op("=").Id(regexpVarName).Dot("ExpandString").Call(jen.Id("dst"), jen.Id("stdlibTemplate"), jen.Id("match"), jen.Id("submatch")),
						jen.Return(jen.String().Call(jen.Id("dst"))),
					),
				),
				jen.Id("got").Op(":=").Id(c.config.Name).Values().Dot("ReplaceFirstString").Call(jen.Id("input"), jen.Id("replacer")),
				jen.If(jen.Id("got").Op("!=").Id("expected")).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit("ReplaceFirstString(%q, %q) = %q, want %q"),
						jen.Id("input"),
						jen.Id("replacer"),
						jen.Id("got"),
						jen.Id("expected"),
					),
				),
			),
		),
	)
	testFile.Line()

	// Generate tests for pre-compiled replacers
	for i, replacer := range replacers {
		// TestReplaceAllStringN - compare pre-compiled with runtime
		testFile.Func().Id(fmt.Sprintf("Test%sReplaceAllString%d", c.config.Name, i)).Params(
			jen.Id("t").Op("*").Qual("testing", "T"),
		).Block(
			jen.Id("replacer").Op(":=").Lit(replacer),
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("runtime").Op(":=").Id(c.config.Name).Values().Dot("ReplaceAllString").Call(jen.Id("input"), jen.Id("replacer")),
				jen.Id("precompiled").Op(":=").Id(c.config.Name).Values().Dot(fmt.Sprintf("ReplaceAllString%d", i)).Call(jen.Id("input")),
				jen.If(jen.Id("precompiled").Op("!=").Id("runtime")).Block(
					jen.Id("t").Dot("Errorf").Call(
						jen.Lit(fmt.Sprintf("ReplaceAllString%d(%%q) = %%q, want %%q (runtime)", i)),
						jen.Id("input"),
						jen.Id("precompiled"),
						jen.Id("runtime"),
					),
				),
			),
		)
		testFile.Line()
	}
}

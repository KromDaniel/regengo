package compiler

import (
	"fmt"

	"github.com/KromDaniel/regengo/internal/codegen"
	"github.com/dave/jennifer/jen"
)

// generateTestFile generates a test file with tests and benchmarks against standard regexp.
func (c *Compiler) generateTestFile() error {
	testFile := jen.NewFile(c.config.Package)

	testFile.Comment("Code generated by regengo")
	testFile.Comment("Tests and benchmarks for pattern: " + c.config.Pattern)
	testFile.Line()

	testFile.ImportName("testing", "testing")
	testFile.ImportName("regexp", "regexp")
	testFile.Line()

	// Create regexp variable for comparison
	regexpVarName := fmt.Sprintf("%sRegexp", codegen.LowerFirst(c.config.Name))
	testFile.Var().Id(regexpVarName).Op("=").Qual("regexp", "MustCompile").Call(jen.Lit(c.config.Pattern))
	testFile.Line()

	// Test inputs
	testFile.Var().Id("testInputs").Op("=").Index().String().Values(
		jen.ListFunc(func(g *jen.Group) {
			for _, input := range c.config.TestFileInputs {
				g.Lit(input)
			}
		}),
	)
	testFile.Line()

	// Generate TestMatchString
	testFile.Func().Id(fmt.Sprintf("Test%sMatchString", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Id("expected").Op(":=").Id(regexpVarName).Dot("MatchString").Call(jen.Id("input")),
			jen.Id("got").Op(":=").Id(fmt.Sprintf("%sMatchString", c.config.Name)).Call(jen.Id("input")),
			jen.If(jen.Id("got").Op("!=").Id("expected")).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("MatchString(%q) = %v, want %v"),
					jen.Id("input"),
					jen.Id("got"),
					jen.Id("expected"),
				),
			),
		),
	)
	testFile.Line()

	// Generate TestMatchBytes
	testFile.Func().Id(fmt.Sprintf("Test%sMatchBytes", c.config.Name)).Params(
		jen.Id("t").Op("*").Qual("testing", "T"),
	).Block(
		jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
			jen.Id("inputBytes").Op(":=").Index().Byte().Call(jen.Id("input")),
			jen.Id("expected").Op(":=").Id(regexpVarName).Dot("Match").Call(jen.Id("inputBytes")),
			jen.Id("got").Op(":=").Id(fmt.Sprintf("%sMatchBytes", c.config.Name)).Call(jen.Id("inputBytes")),
			jen.If(jen.Id("got").Op("!=").Id("expected")).Block(
				jen.Id("t").Dot("Errorf").Call(
					jen.Lit("MatchBytes(%q) = %v, want %v"),
					jen.Id("input"),
					jen.Id("got"),
					jen.Id("expected"),
				),
			),
		),
	)
	testFile.Line()

	// Generate capture group tests if applicable
	if c.config.WithCaptures {
		// TestFindString
		testFile.Func().Id(fmt.Sprintf("Test%sFindString", c.config.Name)).Params(
			jen.Id("t").Op("*").Qual("testing", "T"),
		).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("expectedMatches").Op(":=").Id(regexpVarName).Dot("FindStringSubmatch").Call(jen.Id("input")),
				jen.Id("result").Op(",").Id("ok").Op(":=").Id(fmt.Sprintf("%sFindString", c.config.Name)).Call(jen.Id("input")),
				jen.Line(),
				jen.If(jen.Len(jen.Id("expectedMatches")).Op(">").Lit(0)).Block(
					jen.If(jen.Op("!").Id("ok")).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindString(%q) returned false, expected match"),
							jen.Id("input"),
						),
						jen.Continue(),
					),
					jen.If(jen.Id("result").Dot("Match").Op("!=").Id("expectedMatches").Index(jen.Lit(0))).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindString(%q).Match = %q, want %q"),
							jen.Id("input"),
							jen.Id("result").Dot("Match"),
							jen.Id("expectedMatches").Index(jen.Lit(0)),
						),
					),
				).Else().Block(
					jen.If(jen.Id("ok")).Block(
						jen.Id("t").Dot("Errorf").Call(
							jen.Lit("FindString(%q) returned true, expected no match"),
							jen.Id("input"),
						),
					),
				),
			),
		)
		testFile.Line()
	}

	// Generate BenchmarkMatchString
	testFile.Func().Id(fmt.Sprintf("Benchmark%sMatchString", c.config.Name)).Params(
		jen.Id("b").Op("*").Qual("testing", "B"),
	).Block(
		jen.Id("b").Dot("ReportAllocs").Call(),
		jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("_").Op("=").Id(fmt.Sprintf("%sMatchString", c.config.Name)).Call(jen.Id("input")),
			),
		),
	)
	testFile.Line()

	// Generate BenchmarkStdlibMatchString for comparison
	testFile.Func().Id(fmt.Sprintf("BenchmarkStdlib%sMatchString", c.config.Name)).Params(
		jen.Id("b").Op("*").Qual("testing", "B"),
	).Block(
		jen.Id("b").Dot("ReportAllocs").Call(),
		jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
			jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
				jen.Id("_").Op("=").Id(regexpVarName).Dot("MatchString").Call(jen.Id("input")),
			),
		),
	)
	testFile.Line()

	// Generate capture group benchmarks if applicable
	if c.config.WithCaptures {
		// BenchmarkFindString
		testFile.Func().Id(fmt.Sprintf("Benchmark%sFindString", c.config.Name)).Params(
			jen.Id("b").Op("*").Qual("testing", "B"),
		).Block(
			jen.Id("b").Dot("ReportAllocs").Call(),
			jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
				jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
					jen.Id("_").Op(",").Id("_").Op("=").Id(fmt.Sprintf("%sFindString", c.config.Name)).Call(jen.Id("input")),
				),
			),
		)
		testFile.Line()

		// BenchmarkStdlibFindStringSubmatch
		testFile.Func().Id(fmt.Sprintf("BenchmarkStdlib%sFindStringSubmatch", c.config.Name)).Params(
			jen.Id("b").Op("*").Qual("testing", "B"),
		).Block(
			jen.Id("b").Dot("ReportAllocs").Call(),
			jen.For(jen.Id("i").Op(":=").Lit(0), jen.Id("i").Op("<").Id("b").Dot("N"), jen.Id("i").Op("++")).Block(
				jen.For(jen.List(jen.Id("_"), jen.Id("input")).Op(":=").Range().Id("testInputs")).Block(
					jen.Id("_").Op("=").Id(regexpVarName).Dot("FindStringSubmatch").Call(jen.Id("input")),
				),
			),
		)
		testFile.Line()
	}

	// Determine test file path
	testFilePath := c.config.OutputFile
	if len(testFilePath) > 3 && testFilePath[len(testFilePath)-3:] == ".go" {
		testFilePath = testFilePath[:len(testFilePath)-3] + "_test.go"
	} else {
		testFilePath = testFilePath + "_test.go"
	}

	// Save test file
	if err := testFile.Save(testFilePath); err != nil {
		return fmt.Errorf("failed to save test file: %w", err)
	}

	return nil
}

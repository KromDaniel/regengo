package main

import (
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/KromDaniel/regengo/pkg/regengo"
)

var (
	pattern    = flag.String("pattern", "", "Regular expression pattern to compile")
	name       = flag.String("name", "", "Name prefix for generated functions")
	output     = flag.String("output", "", "Output file path")
	pkg        = flag.String("package", "main", "Package name for generated code")
	noPool     = flag.Bool("no-pool", false, "Disable sync.Pool for stack reuse (pool is enabled by default)")
	bytesView  = flag.Bool("bytes-view", false, "Generate separate []byte struct for FindBytes (zero-copy, auto-enabled if pattern has captures)")
	noTest     = flag.Bool("no-test", false, "Disable automatic test file generation")
	testInputs = flag.String("test-inputs", "", "Comma-separated test inputs for generated tests (default: 'example')")
	version    = flag.Bool("version", false, "Print version information")
	helpFlag   = flag.Bool("help", false, "Show help message")
)

const (
	appVersion = "1.0.0"
	appName    = "regengo"
)

func main() {
	flag.Parse()

	if *helpFlag {
		printHelp()
		return
	}

	if *version {
		fmt.Printf("%s version %s\n", appName, appVersion)
		return
	}

	if *pattern == "" {
		fmt.Fprintf(os.Stderr, "Error: -pattern flag is required\n\n")
		printHelp()
		os.Exit(1)
	}

	if *name == "" {
		fmt.Fprintf(os.Stderr, "Error: -name flag is required\n\n")
		printHelp()
		os.Exit(1)
	}

	if *output == "" {
		fmt.Fprintf(os.Stderr, "Error: -output flag is required\n\n")
		printHelp()
		os.Exit(1)
	}

	// Parse test inputs
	var testInputsList []string
	if *testInputs != "" {
		// Split by comma and trim whitespace
		for _, input := range strings.Split(*testInputs, ",") {
			trimmed := strings.TrimSpace(input)
			if trimmed != "" {
				testInputsList = append(testInputsList, trimmed)
			}
		}
	}

	opts := regengo.Options{
		Pattern:          *pattern,
		Name:             *name,
		OutputFile:       *output,
		Package:          *pkg,
		NoPool:           *noPool,
		BytesView:        *bytesView,
		GenerateTestFile: !*noTest,
		TestFileInputs:   testInputsList,
	}

	if err := regengo.Compile(opts); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", *output)
	if opts.GenerateTestFile {
		testFile := *output
		if len(testFile) > 3 && testFile[len(testFile)-3:] == ".go" {
			testFile = testFile[:len(testFile)-3] + "_test.go"
		} else {
			testFile = testFile + "_test.go"
		}
		fmt.Printf("Successfully generated %s\n", testFile)
	}
}

func printHelp() {
	const helpText = `%s - Compile regular expressions to optimized Go code

Usage:
  %s [options]

Options:
  -pattern string
      Regular expression pattern to compile (required)
  -name string
      Name prefix for generated functions (required)
  -output string
      Output file path (required)
  -package string
      Package name for generated code (default "main")
  -no-pool
      Disable sync.Pool for stack reuse (pool is ENABLED by default)
      Pool achieves 0 allocations and 3-5x faster than standard regexp
  -bytes-view
      Generate separate []byte struct for FindBytes (zero-copy)
      Auto-applies when pattern has capture groups
      FindBytes returns *BytesMatch with []byte fields instead of strings
  -no-test
      Disable automatic test file generation (tests are generated by default)
  -test-inputs string
      Comma-separated test inputs for generated tests (default: "example")
      Example: -test-inputs "test@example.com,user@domain.org"
  -version
      Print version information
  -help
      Show this help message

Features:
  - Pool optimization enabled by default (use -no-pool to disable)
  - Auto-detects capture groups and generates Find functions
  - Always generates both MatchString and MatchBytes
  - Automatic test file generation with benchmarks

Examples:
  # Generate email matcher (pool enabled by default, includes tests)
  regengo -pattern '[\w\.+-]+@[\w\.-]+\.[\w\.-]+' -name Email -output email.go

  # With custom test inputs
  regengo -pattern '[\w\.+-]+@[\w\.-]+' -name Email -output email.go \
          -test-inputs "test@example.com,user@domain.org,invalid@"

  # With capture groups (auto-detected, generates Find functions)
  regengo -pattern '(?P<user>\w+)@(?P<domain>\w+)' -name Email -output email.go

  # With zero-copy []byte captures
  regengo -pattern '(?P<user>\w+)@(?P<domain>\w+)' -name Email -output email.go -bytes-view

  # Disable pool and tests
  regengo -pattern '\w+' -name Word -output word.go -no-pool -no-test

For more information, visit: https://github.com/KromDaniel/regengo
`
	fmt.Printf(helpText, appName, appName)
}

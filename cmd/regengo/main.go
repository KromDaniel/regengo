package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"

	"github.com/KromDaniel/regengo"
)

// arrayFlags allows multiple -replacer flags to be passed
type arrayFlags []string

func (a *arrayFlags) String() string {
	return strings.Join(*a, ", ")
}

func (a *arrayFlags) Set(value string) error {
	*a = append(*a, value)
	return nil
}

var (
	pattern       = flag.String("pattern", "", "Regular expression pattern to compile")
	name          = flag.String("name", "", "Name prefix for generated functions")
	output        = flag.String("output", "", "Output file path")
	pkg           = flag.String("package", "main", "Package name for generated code")
	noPool        = flag.Bool("no-pool", false, "Disable sync.Pool for stack reuse (pool is enabled by default)")
	noTest        = flag.Bool("no-test", false, "Disable automatic test file generation")
	testInputs    = flag.String("test-inputs", "", "Comma-separated test inputs for generated tests (default: 'example')")
	verbose       = flag.Bool("verbose", false, "Enable verbose logging of analysis decisions")
	forceThompson = flag.Bool("force-thompson", false, "Force Thompson NFA for match functions (guarantees O(n*m) complexity)")
	forceTNFA     = flag.Bool("force-tnfa", false, "Force Tagged NFA for capture functions (guarantees linear-time captures)")
	forceTDFA     = flag.Bool("force-tdfa", false, "Force Tagged DFA for capture functions (guarantees O(n) captures)")
	tdfaThreshold = flag.Int("tdfa-threshold", 500, "Max DFA states before falling back to other engines")
	analyze       = flag.Bool("analyze", false, "Analyze pattern and output labels as JSON (no code generation)")
	version       = flag.Bool("version", false, "Print version information")
	helpFlag      = flag.Bool("help", false, "Show help message")
	replacers     arrayFlags
)

func init() {
	flag.Var(&replacers, "replacer", "Pre-compiled replacement template (can be used multiple times)")
}

const (
	appVersion = "1.0.0"
	appName    = "regengo"
)

func main() {
	flag.Parse()

	if *helpFlag {
		printHelp()
		return
	}

	if *version {
		fmt.Printf("%s version %s\n", appName, appVersion)
		return
	}

	// Handle analyze mode
	if *analyze {
		if *pattern == "" {
			fmt.Fprintf(os.Stderr, "Error: -pattern flag is required for -analyze\n")
			os.Exit(1)
		}

		result, err := regengo.AnalyzeWithThreshold(*pattern, *tdfaThreshold)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error: %v\n", err)
			os.Exit(1)
		}

		output, err := json.MarshalIndent(result, "", "  ")
		if err != nil {
			fmt.Fprintf(os.Stderr, "Error marshaling JSON: %v\n", err)
			os.Exit(1)
		}

		fmt.Println(string(output))
		return
	}

	if *pattern == "" {
		fmt.Fprintf(os.Stderr, "Error: -pattern flag is required\n\n")
		printHelp()
		os.Exit(1)
	}

	if *name == "" {
		fmt.Fprintf(os.Stderr, "Error: -name flag is required\n\n")
		printHelp()
		os.Exit(1)
	}

	if *output == "" {
		fmt.Fprintf(os.Stderr, "Error: -output flag is required\n\n")
		printHelp()
		os.Exit(1)
	}

	// Parse test inputs
	var testInputsList []string
	if *testInputs != "" {
		// Split by comma and trim whitespace
		for _, input := range strings.Split(*testInputs, ",") {
			trimmed := strings.TrimSpace(input)
			if trimmed != "" {
				testInputsList = append(testInputsList, trimmed)
			}
		}
	}

	opts := regengo.Options{
		Pattern:           *pattern,
		Name:              *name,
		OutputFile:        *output,
		Package:           *pkg,
		NoPool:            *noPool,
		GenerateTestFile:  !*noTest,
		TestFileInputs:    testInputsList,
		Verbose:           *verbose,
		ForceThompson:     *forceThompson,
		ForceTNFA:         *forceTNFA,
		ForceTDFA:         *forceTDFA,
		TDFAThreshold:     *tdfaThreshold,
		Replacers:         replacers,
		TestFileReplacers: replacers, // Also test replacers in generated test file
	}

	if err := regengo.Compile(opts); err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Successfully generated %s\n", *output)
	if opts.GenerateTestFile {
		testFile := *output
		if len(testFile) > 3 && testFile[len(testFile)-3:] == ".go" {
			testFile = testFile[:len(testFile)-3] + "_test.go"
		} else {
			testFile = testFile + "_test.go"
		}
		fmt.Printf("Successfully generated %s\n", testFile)
	}
}

func printHelp() {
	const helpText = `%s - Compile regular expressions to optimized Go code

Usage:
  %s [options]

Options:
  -pattern string
      Regular expression pattern to compile (required)
  -name string
      Name prefix for generated functions (required)
  -output string
      Output file path (required)
  -package string
      Package name for generated code (default "main")
  -no-pool
      Disable sync.Pool for stack reuse (pool is ENABLED by default)
      Pool achieves 0 allocations and 3-5x faster than standard regexp
  -no-test
      Disable automatic test file generation (tests are generated by default)
  -test-inputs string
      Comma-separated test inputs for generated tests (default: "example")
      Example: -test-inputs "test@example.com,user@domain.org"
  -verbose
      Enable verbose logging of analysis decisions to stderr
      Shows pattern analysis, engine selection, and code generation details
  -force-thompson
      Force Thompson NFA for match functions (guarantees O(n*m) complexity)
      Use for patterns that may cause catastrophic backtracking
  -force-tnfa
      Force Tagged NFA for capture functions (guarantees linear-time captures)
      Use for patterns with captures that may cause backtracking issues
  -force-tdfa
      Force Tagged DFA for capture functions (guarantees O(n) captures)
      2-3x faster than stdlib for patterns with captures
  -tdfa-threshold int
      Max DFA states before falling back to other engines (default: 500)
      Higher values allow more complex patterns to use TDFA
  -replacer string
      Pre-compiled replacement template (can be used multiple times)
      Generates optimized ReplaceAllString0, ReplaceAllString1, etc.
      Example: -replacer '$user@REDACTED.$tld' -replacer '[$0]'
  -analyze
      Analyze pattern and output labels as JSON (no code generation)
      Only requires -pattern flag. Outputs feature_labels and engine_labels.
  -version
      Print version information
  -help
      Show this help message

Features:
  - Pool optimization enabled by default (use -no-pool to disable)
  - Auto-detects capture groups and generates Find functions
  - Always generates both MatchString and MatchBytes
  - Automatic test file generation with benchmarks
  - Auto-detects patterns at risk of catastrophic backtracking

Examples:
  # Generate email matcher (pool enabled by default, includes tests)
  regengo -pattern '[\w\.+-]+@[\w\.-]+\.[\w\.-]+' -name Email -output email.go

  # With custom test inputs
  regengo -pattern '[\w\.+-]+@[\w\.-]+' -name Email -output email.go \
          -test-inputs "test@example.com,user@domain.org,invalid@"

  # With capture groups (auto-detected, generates Find functions)
  regengo -pattern '(?P<user>\w+)@(?P<domain>\w+)' -name Email -output email.go

  # Disable pool and tests
  regengo -pattern '\w+' -name Word -output word.go -no-pool -no-test

  # With verbose logging to see analysis decisions
  regengo -pattern '(a+)+b' -name Pathological -output pathological.go -verbose

For more information, visit: https://github.com/KromDaniel/regengo
`
	fmt.Printf(helpText, appName, appName)
}

package testdata

import (
	"bytes"
	stream "github.com/KromDaniel/regengo/stream"
	"io"
	"sync"
)

// Code generated by regengo for pattern: ([\w.+-]+@[\w.-]+\.\w+)
// DO NOT EDIT.

var emailPatternStackPool = sync.Pool{New: func() interface{} {
	stack := make([][3]int, 0, 32)
	return &stack
}}

var emailPatternCaptureStackPool = sync.Pool{New: func() interface{} {
	stack := make([]int, 0, 64)
	return &stack
}}

type EmailPattern struct{}

var CompiledEmailPattern = EmailPattern{}

// MinMatchLen is the minimum number of bytes any match can have.
const EmailPatternMinMatchLen = 5

// MaxMatchLen is the maximum number of bytes any match can have.
// -1 means unbounded (pattern contains * or + quantifiers).
const EmailPatternMaxMatchLen = -1

func (EmailPattern) MatchLengthInfo() (minLen, maxLen int) {
	return EmailPatternMinMatchLen, EmailPatternMaxMatchLen
}

func (EmailPattern) MatchString(input string) bool {
	l := len(input)
	offset := 0
	stackPtr := emailPatternStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		emailPatternStackPool.Put(stackPtr)
	}()
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		stack = append(stack, [3]int{offset, 2, 0})
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		stack = append(stack, [3]int{offset, 5, 0})
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || (input[offset] > uint8(0x39) && input[offset] < uint8(0x41)) || (input[offset] > uint8(0x5a) && input[offset] < uint8(0x5f)) || (input[offset] > uint8(0x5f) && input[offset] < uint8(0x61)) || input[offset] > uint8(0x7a) {
			goto TryFallback
		}
		offset++
		goto Ins9
	}
Ins9:
	{
		stack = append(stack, [3]int{offset, 8, 0})
		goto Ins10
	}
Ins10:
	{
		goto Ins11
	}
Ins11:
	{
		return true
	}
}
func (EmailPattern) MatchBytes(input []byte) bool {
	l := len(input)
	offset := 0
	stackPtr := emailPatternStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		emailPatternStackPool.Put(stackPtr)
	}()
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	}
Ins0:
	{
		return false
	}
Ins1:
	{
		goto Ins2
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		stack = append(stack, [3]int{offset, 2, 0})
		goto Ins4
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		stack = append(stack, [3]int{offset, 5, 0})
		goto Ins7
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || (input[offset] > uint8(0x39) && input[offset] < uint8(0x41)) || (input[offset] > uint8(0x5a) && input[offset] < uint8(0x5f)) || (input[offset] > uint8(0x5f) && input[offset] < uint8(0x61)) || input[offset] > uint8(0x7a) {
			goto TryFallback
		}
		offset++
		goto Ins9
	}
Ins9:
	{
		stack = append(stack, [3]int{offset, 8, 0})
		goto Ins10
	}
Ins10:
	{
		goto Ins11
	}
Ins11:
	{
		return true
	}
}

type EmailPatternResult struct {
	Match  string // Full match
	Group1 string
}

type EmailPatternBytesResult struct {
	Match  []byte // Full match
	Group1 []byte
}

func (EmailPattern) FindStringReuse(input string, r *EmailPatternResult) (*EmailPatternResult, bool) {
	l := len(input)
	offset := 0
	var captures [4]int
	captureStackPtr := emailPatternCaptureStackPool.Get().(*[]int)
	captureStack := (*captureStackPtr)[:0]
	defer func() {
		*captureStackPtr = captureStack[:0]
		emailPatternCaptureStackPool.Put(captureStackPtr)
	}()
	stackPtr := emailPatternStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		emailPatternStackPool.Put(stackPtr)
	}()
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		if last[2] == 1 && len(captureStack) > 0 {
			n := len(captures)
			top := len(captureStack) - n
			copy(captures[:], captureStack[top:])
			captureStack = captureStack[:top]
		}
		goto StepSelect
	} else {
		if l > offset {
			offset++
			for i := range captures {
				captures[i] = 0
			}
			captureStack = captureStack[:0]
			captures[0] = offset
			nextInstruction = 1
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [3]int{offset, 4, 1})
		goto Ins2
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [3]int{offset, 7, 1})
		goto Ins5
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || (input[offset] > uint8(0x39) && input[offset] < uint8(0x41)) || (input[offset] > uint8(0x5a) && input[offset] < uint8(0x5f)) || (input[offset] > uint8(0x5f) && input[offset] < uint8(0x61)) || input[offset] > uint8(0x7a) {
			goto TryFallback
		}
		offset++
		goto Ins9
	}
Ins9:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [3]int{offset, 10, 1})
		goto Ins8
	}
Ins10:
	{
		captures[3] = offset
		nextInstruction = 11
		goto StepSelect
	}
Ins11:
	{
		captures[1] = offset
		if r == nil {
			r = &EmailPatternResult{}
		}
		r.Match = string(input[captures[0]:captures[1]])
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.Group1 = string(input[captures[2]:captures[3]])
		} else {
			r.Group1 = ""
		}
		return r, true
	}
}
func (recv EmailPattern) FindString(input string) (*EmailPatternResult, bool) {
	return recv.FindStringReuse(input, nil)
}
func (EmailPattern) FindAllStringAppend(input string, n int, s []*EmailPatternResult) []*EmailPatternResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	captureStackPtr := emailPatternCaptureStackPool.Get().(*[]int)
	captureStack := (*captureStackPtr)[:0]
	defer func() {
		*captureStackPtr = captureStack[:0]
		emailPatternCaptureStackPool.Put(captureStackPtr)
	}()
	stackPtr := emailPatternStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		emailPatternStackPool.Put(stackPtr)
	}()
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [4]int
		captureStack = captureStack[:0]
		stack = stack[:0]
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		if len(stack) > 0 {
			last := stack[len(stack)-1]
			offset = last[0]
			nextInstruction = last[1]
			stack = stack[:len(stack)-1]
			if last[2] == 1 && len(captureStack) > 0 {
				n := len(captures)
				top := len(captureStack) - n
				copy(captures[:], captureStack[top:])
				captureStack = captureStack[:top]
			}
			goto StepSelect
		} else {
			searchStart++
			continue
		}
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [3]int{offset, 4, 1})
			goto Ins2
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x40) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [3]int{offset, 7, 1})
			goto Ins5
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2e) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || (input[offset] > uint8(0x39) && input[offset] < uint8(0x41)) || (input[offset] > uint8(0x5a) && input[offset] < uint8(0x5f)) || (input[offset] > uint8(0x5f) && input[offset] < uint8(0x61)) || input[offset] > uint8(0x7a) {
				goto TryFallback
			}
			offset++
			goto Ins9
		}
	Ins9:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [3]int{offset, 10, 1})
			goto Ins8
		}
	Ins10:
		{
			captures[3] = offset
			nextInstruction = 11
			goto StepSelect
		}
	Ins11:
		{
			captures[1] = offset
			var item *EmailPatternResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &EmailPatternResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &EmailPatternResult{}
				result = append(result, item)
			}
			item.Match = string(input[captures[0]:captures[1]])
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.Group1 = string(input[captures[2]:captures[3]])
			} else {
				item.Group1 = ""
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r EmailPattern) FindAllString(input string, n int) []*EmailPatternResult {
	return r.FindAllStringAppend(input, n, nil)
}
func (EmailPattern) FindBytesReuse(input []byte, r *EmailPatternBytesResult) (*EmailPatternBytesResult, bool) {
	l := len(input)
	offset := 0
	var captures [4]int
	captureStackPtr := emailPatternCaptureStackPool.Get().(*[]int)
	captureStack := (*captureStackPtr)[:0]
	defer func() {
		*captureStackPtr = captureStack[:0]
		emailPatternCaptureStackPool.Put(captureStackPtr)
	}()
	stackPtr := emailPatternStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		emailPatternStackPool.Put(stackPtr)
	}()
	captures[0] = 0
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		if last[2] == 1 && len(captureStack) > 0 {
			n := len(captures)
			top := len(captureStack) - n
			copy(captures[:], captureStack[top:])
			captureStack = captureStack[:top]
		}
		goto StepSelect
	} else {
		if l > offset {
			offset++
			for i := range captures {
				captures[i] = 0
			}
			captureStack = captureStack[:0]
			captures[0] = offset
			nextInstruction = 1
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [3]int{offset, 4, 1})
		goto Ins2
	}
Ins4:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x40) {
			goto TryFallback
		}
		offset++
		goto Ins5
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [3]int{offset, 7, 1})
		goto Ins5
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != uint8(0x2e) {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] < uint8(0x30) || (input[offset] > uint8(0x39) && input[offset] < uint8(0x41)) || (input[offset] > uint8(0x5a) && input[offset] < uint8(0x5f)) || (input[offset] > uint8(0x5f) && input[offset] < uint8(0x61)) || input[offset] > uint8(0x7a) {
			goto TryFallback
		}
		offset++
		goto Ins9
	}
Ins9:
	{
		captureStack = append(captureStack, captures[:]...)
		stack = append(stack, [3]int{offset, 10, 1})
		goto Ins8
	}
Ins10:
	{
		captures[3] = offset
		nextInstruction = 11
		goto StepSelect
	}
Ins11:
	{
		captures[1] = offset
		if r == nil {
			r = &EmailPatternBytesResult{}
		}
		r.Match = input[captures[0]:captures[1]]
		if captures[2] <= captures[3] && captures[3] <= len(input) {
			r.Group1 = input[captures[2]:captures[3]]
		} else {
			r.Group1 = nil
		}
		return r, true
	}
}
func (recv EmailPattern) FindBytes(input []byte) (*EmailPatternBytesResult, bool) {
	return recv.FindBytesReuse(input, nil)
}
func (EmailPattern) FindAllBytesAppend(input []byte, n int, s []*EmailPatternBytesResult) []*EmailPatternBytesResult {
	if n == 0 {
		return s
	}
	result := s
	l := len(input)
	searchStart := 0
	captureStackPtr := emailPatternCaptureStackPool.Get().(*[]int)
	captureStack := (*captureStackPtr)[:0]
	defer func() {
		*captureStackPtr = captureStack[:0]
		emailPatternCaptureStackPool.Put(captureStackPtr)
	}()
	stackPtr := emailPatternStackPool.Get().(*[][3]int)
	stack := (*stackPtr)[:0]
	defer func() {
		for i := range stack {
			stack[i] = [3]int{0, 0, 0}
		}
		*stackPtr = stack[:0]
		emailPatternStackPool.Put(stackPtr)
	}()
	for true {
		if n > 0 && len(result) >= n {
			break
		}
		if searchStart >= l {
			break
		}
		offset := searchStart
		var captures [4]int
		captureStack = captureStack[:0]
		stack = stack[:0]
		captures[0] = searchStart
		nextInstruction := 1
		goto StepSelect
	TryFallback:
		if len(stack) > 0 {
			last := stack[len(stack)-1]
			offset = last[0]
			nextInstruction = last[1]
			stack = stack[:len(stack)-1]
			if last[2] == 1 && len(captureStack) > 0 {
				n := len(captures)
				top := len(captureStack) - n
				copy(captures[:], captureStack[top:])
				captureStack = captureStack[:top]
			}
			goto StepSelect
		} else {
			searchStart++
			continue
		}
	StepSelect:
		switch nextInstruction {
		case 0:
			goto Ins0
		case 1:
			goto Ins1
		case 2:
			goto Ins2
		case 3:
			goto Ins3
		case 4:
			goto Ins4
		case 5:
			goto Ins5
		case 6:
			goto Ins6
		case 7:
			goto Ins7
		case 8:
			goto Ins8
		case 9:
			goto Ins9
		case 10:
			goto Ins10
		case 11:
			goto Ins11
		}
	Ins0:
		{
			goto TryFallback
		}
	Ins1:
		{
			captures[2] = offset
			nextInstruction = 2
			goto StepSelect
		}
	Ins2:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x68), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins3
		}
	Ins3:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [3]int{offset, 4, 1})
			goto Ins2
		}
	Ins4:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x40) {
				goto TryFallback
			}
			offset++
			goto Ins5
		}
	Ins5:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if [32]byte{uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x60), uint8(0xff), uint8(0x3), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x87), uint8(0xfe), uint8(0xff), uint8(0xff), uint8(0x7), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0), uint8(0x0)}[input[offset]/8]&(1<<(input[offset]%8)) == 0 {
				goto TryFallback
			}
			offset++
			goto Ins6
		}
	Ins6:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [3]int{offset, 7, 1})
			goto Ins5
		}
	Ins7:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] != uint8(0x2e) {
				goto TryFallback
			}
			offset++
			goto Ins8
		}
	Ins8:
		{
			if l <= offset {
				goto TryFallback
			}
		}
		{
			if input[offset] < uint8(0x30) || (input[offset] > uint8(0x39) && input[offset] < uint8(0x41)) || (input[offset] > uint8(0x5a) && input[offset] < uint8(0x5f)) || (input[offset] > uint8(0x5f) && input[offset] < uint8(0x61)) || input[offset] > uint8(0x7a) {
				goto TryFallback
			}
			offset++
			goto Ins9
		}
	Ins9:
		{
			captureStack = append(captureStack, captures[:]...)
			stack = append(stack, [3]int{offset, 10, 1})
			goto Ins8
		}
	Ins10:
		{
			captures[3] = offset
			nextInstruction = 11
			goto StepSelect
		}
	Ins11:
		{
			captures[1] = offset
			var item *EmailPatternBytesResult
			if len(result) < cap(result) {
				result = result[:len(result)+1]
				item = result[len(result)-1]
				if item == nil {
					item = &EmailPatternBytesResult{}
					result[len(result)-1] = item
				}
			} else {
				item = &EmailPatternBytesResult{}
				result = append(result, item)
			}
			item.Match = input[captures[0]:captures[1]]
			if captures[2] <= captures[3] && captures[3] <= len(input) {
				item.Group1 = input[captures[2]:captures[3]]
			} else {
				item.Group1 = nil
			}
			if captures[1] > searchStart {
				searchStart = captures[1]
			} else {
				searchStart++
			}
			continue
		}
	}
	return result
}
func (r EmailPattern) FindAllBytes(input []byte, n int) []*EmailPatternBytesResult {
	return r.FindAllBytesAppend(input, n, nil)
}

// DefaultMaxLeftover returns the recommended MaxLeftover value for streaming.
// For bounded patterns, this is 10 * MaxMatchLen.
// For unbounded patterns, this returns 1MB as a safety limit.
func (EmailPattern) DefaultMaxLeftover() int {
	return 1048576
}

// FindReader streams matches from an io.Reader.
//
// The onMatch callback is called for each match found. Return false to stop
// processing early. The StreamMatch.Result points into an internal buffer
// and is only valid during the callback - copy if needed.
//
// Returns nil on success (including early termination via callback).
// Returns error on read failure.
func (EmailPattern) FindReader(r io.Reader, cfg stream.Config, onMatch func(stream.Match[*EmailPatternBytesResult]) bool) error {
	if err := cfg.Validate(65536); err != nil {
		return err
	}
	cfg = cfg.ApplyDefaults(65536, 1048576)

	buf := make([]byte, cfg.BufferSize)
	leftover := 0
	streamOffset := int64(0)
	chunkIndex := 0

	reuseResult := &EmailPatternBytesResult{}

	for {
		n, err := r.Read(buf[leftover:])
		if n == 0 && err != nil {
			if err == io.EOF {
				// Process any remaining data in leftover
				if leftover > 0 {
					chunk := buf[:leftover]
					searchPos := 0
					for searchPos < len(chunk) {
						result, ok := EmailPattern{}.FindBytesReuse(chunk[searchPos:], reuseResult)
						if !ok {
							break
						}
						matchIdx := bytes.Index(chunk[searchPos:], result.Match)
						if matchIdx < 0 {
							break
						}
						matchStart := searchPos + matchIdx

						m := stream.Match[*EmailPatternBytesResult]{
							ChunkIndex:   chunkIndex,
							Result:       result,
							StreamOffset: streamOffset + int64(matchStart),
						}
						if !onMatch(m) {
							return nil
						}
						if len(result.Match) > 0 {
							searchPos = matchStart + len(result.Match)
						} else {
							searchPos++
						}
					}
				}
				return nil
			}
			return err
		}

		dataLen := leftover + n
		chunk := buf[:dataLen]
		isFull := n == cfg.BufferSize-leftover

		searchPos := 0
		committed := 0
		for searchPos < len(chunk) {
			result, ok := EmailPattern{}.FindBytesReuse(chunk[searchPos:], reuseResult)
			if !ok {
				break
			}
			matchIdx := bytes.Index(chunk[searchPos:], result.Match)
			if matchIdx < 0 {
				break
			}
			matchStart := searchPos + matchIdx
			matchEnd := matchStart + len(result.Match)

			if isFull && matchEnd > dataLen-cfg.MaxLeftover {
				// Match too close to boundary, defer to next chunk
				break
			}

			m := stream.Match[*EmailPatternBytesResult]{
				ChunkIndex:   chunkIndex,
				Result:       result,
				StreamOffset: streamOffset + int64(matchStart),
			}
			if !onMatch(m) {
				return nil
			}
			committed = matchEnd
			if len(result.Match) > 0 {
				searchPos = matchEnd
			} else {
				searchPos++
			}
		}

		// Prepare leftover for next iteration
		if isFull {
			// Buffer was full, need to keep leftover
			keepFrom := dataLen - cfg.MaxLeftover
			if keepFrom < committed {
				keepFrom = committed
			}
			leftover = dataLen - keepFrom
			streamOffset += int64(keepFrom)
			copy(buf[:leftover], buf[keepFrom:dataLen])
		} else {
			// Reached EOF or short read, no more data
			leftover = 0
		}
		chunkIndex++
		if err == io.EOF {
			return nil
		}
	}
}

// FindReaderCount counts matches without allocating result structs.
// More efficient when you only need the count.
func (EmailPattern) FindReaderCount(r io.Reader, cfg stream.Config) (int64, error) {
	var count int64
	err := EmailPattern{}.FindReader(r, cfg, func(_ stream.Match[*EmailPatternBytesResult]) bool {
		count++
		return true
	})
	return count, err
}

// FindReaderFirst returns the first match, or nil if none found.
// The returned result is a copy (safe to use after call returns).
func (EmailPattern) FindReaderFirst(r io.Reader, cfg stream.Config) (*EmailPatternBytesResult, int64, error) {
	var result *EmailPatternBytesResult
	var offset int64
	err := EmailPattern{}.FindReader(r, cfg, func(m stream.Match[*EmailPatternBytesResult]) bool {
		// Copy the result since buffer will be reused
		result = EmailPattern{}.copyBytesResult(m.Result)
		offset = m.StreamOffset
		return false
	})
	return result, offset, err
}

// copyBytesResult creates a deep copy of a BytesResult.
// This is needed because the original slices point into the stream buffer.
func (EmailPattern) copyBytesResult(src *EmailPatternBytesResult) *EmailPatternBytesResult {
	if src == nil {
		return nil
	}
	dst := &EmailPatternBytesResult{}
	// Copy Match slice
	dst.Match = append([]byte{}, src.Match...)
	return dst
}

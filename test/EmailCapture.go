package test

// Code generated by regengo for pattern: (?P<user>\w+)@(?P<domain>\w+)\.(?P<tld>\w+)
// DO NOT EDIT.

// EmailCaptureMatch holds the result of a successful match with capture groups.
type EmailCaptureMatch struct {
	Match  string // The full matched string
	Start  int    // Start position in input
	End    int    // End position in input
	User   string // Capture group 1
	Domain string // Capture group 2
	Tld    string // Capture group 3
}

func EmailCaptureFindString(input string) (*EmailCaptureMatch, bool) {
	l := len(input)
	offset := 0
	captures := make([]int, 8)
	stack := make([][2]int, 0)
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < '0' || input[offset] > '9') && (input[offset] < 'A' || input[offset] > 'Z') && (input[offset] != '_') && (input[offset] < 'a' || input[offset] > 'z') {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 4
		} else {
			stack = append(stack, [2]int{offset, 4})
		}
		goto Ins2
	}
Ins4:
	{
		captures[3] = offset
		nextInstruction = 5
		goto StepSelect
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != '@' {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[4] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < '0' || input[offset] > '9') && (input[offset] < 'A' || input[offset] > 'Z') && (input[offset] != '_') && (input[offset] < 'a' || input[offset] > 'z') {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 9
		} else {
			stack = append(stack, [2]int{offset, 9})
		}
		goto Ins7
	}
Ins9:
	{
		captures[5] = offset
		nextInstruction = 10
		goto StepSelect
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != '.' {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[6] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < '0' || input[offset] > '9') && (input[offset] < 'A' || input[offset] > 'Z') && (input[offset] != '_') && (input[offset] < 'a' || input[offset] > 'z') {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 14
		} else {
			stack = append(stack, [2]int{offset, 14})
		}
		goto Ins12
	}
Ins14:
	{
		captures[7] = offset
		nextInstruction = 15
		goto StepSelect
	}
Ins15:
	{
		return &EmailCaptureMatch{Match: string(input[captures[0]:captures[1]]), Start: captures[0], End: captures[1], User: string(input[captures[2]:captures[3]]), Domain: string(input[captures[4]:captures[5]]), Tld: string(input[captures[6]:captures[7]])}, true
	}
}
func EmailCaptureFindBytes(input []byte) (*EmailCaptureMatch, bool) {
	l := len(input)
	offset := 0
	captures := make([]int, 8)
	stack := make([][2]int, 0)
	nextInstruction := 1
	goto StepSelect
TryFallback:
	if len(stack) > 0 {
		last := stack[len(stack)-1]
		offset = last[0]
		nextInstruction = last[1]
		stack = stack[:len(stack)-1]
		goto StepSelect
	} else {
		if l > offset {
			nextInstruction = 1
			offset++
			goto StepSelect
		}
		return nil, false
	}
StepSelect:
	switch nextInstruction {
	case 0:
		goto Ins0
	case 1:
		goto Ins1
	case 2:
		goto Ins2
	case 3:
		goto Ins3
	case 4:
		goto Ins4
	case 5:
		goto Ins5
	case 6:
		goto Ins6
	case 7:
		goto Ins7
	case 8:
		goto Ins8
	case 9:
		goto Ins9
	case 10:
		goto Ins10
	case 11:
		goto Ins11
	case 12:
		goto Ins12
	case 13:
		goto Ins13
	case 14:
		goto Ins14
	case 15:
		goto Ins15
	}
Ins0:
	{
		return nil, false
	}
Ins1:
	{
		captures[2] = offset
		nextInstruction = 2
		goto StepSelect
	}
Ins2:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < '0' || input[offset] > '9') && (input[offset] < 'A' || input[offset] > 'Z') && (input[offset] != '_') && (input[offset] < 'a' || input[offset] > 'z') {
			goto TryFallback
		}
		offset++
		goto Ins3
	}
Ins3:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 4
		} else {
			stack = append(stack, [2]int{offset, 4})
		}
		goto Ins2
	}
Ins4:
	{
		captures[3] = offset
		nextInstruction = 5
		goto StepSelect
	}
Ins5:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != '@' {
			goto TryFallback
		}
		offset++
		goto Ins6
	}
Ins6:
	{
		captures[4] = offset
		nextInstruction = 7
		goto StepSelect
	}
Ins7:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < '0' || input[offset] > '9') && (input[offset] < 'A' || input[offset] > 'Z') && (input[offset] != '_') && (input[offset] < 'a' || input[offset] > 'z') {
			goto TryFallback
		}
		offset++
		goto Ins8
	}
Ins8:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 9
		} else {
			stack = append(stack, [2]int{offset, 9})
		}
		goto Ins7
	}
Ins9:
	{
		captures[5] = offset
		nextInstruction = 10
		goto StepSelect
	}
Ins10:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if input[offset] != '.' {
			goto TryFallback
		}
		offset++
		goto Ins11
	}
Ins11:
	{
		captures[6] = offset
		nextInstruction = 12
		goto StepSelect
	}
Ins12:
	{
		if l <= offset {
			goto TryFallback
		}
	}
	{
		if (input[offset] < '0' || input[offset] > '9') && (input[offset] < 'A' || input[offset] > 'Z') && (input[offset] != '_') && (input[offset] < 'a' || input[offset] > 'z') {
			goto TryFallback
		}
		offset++
		goto Ins13
	}
Ins13:
	{
		if cap(stack) > len(stack) {
			stack = stack[:len(stack)+1]
			stack[len(stack)-1][0] = offset
			stack[len(stack)-1][1] = 14
		} else {
			stack = append(stack, [2]int{offset, 14})
		}
		goto Ins12
	}
Ins14:
	{
		captures[7] = offset
		nextInstruction = 15
		goto StepSelect
	}
Ins15:
	{
		return &EmailCaptureMatch{Match: string(input[captures[0]:captures[1]]), Start: captures[0], End: captures[1], User: string(input[captures[2]:captures[3]]), Domain: string(input[captures[4]:captures[5]]), Tld: string(input[captures[6]:captures[7]])}, true
	}
}
